<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/14/hello-world/"/>
      <url>/2021/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/2020/09/25/node/"/>
      <url>/2020/09/25/node/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a><strong>Node.js简介</strong></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl这哥们，鬼才般的，把这个V8搬到了服务器上，用于做服务器的软件。</p><p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。</p><p>但Node似乎有点不同：</p><p>● <strong>Node.js不是一种独立的语言</strong>，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js使用JavaScript进行编程，运行在JavaScript引擎上（V8）。</p><p>● 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力</p><p>特点：Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a><strong>单线程</strong></h3><p>在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。</p><p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p><p>另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。</p><p>坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。</p><p>多线程、单线程的一个对比。</p><p>也就是说，单线程也能造成宏观上的“并发”。</p><h3 id="非阻塞I-O-non-blocking-I-O"><a href="#非阻塞I-O-non-blocking-I-O" class="headerlink" title="非阻塞I/O  non-blocking I/O"></a><strong>非阻塞I/O  non-blocking I/O</strong></h3><p>例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。</p><p>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</p><p>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</p><p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。<strong>而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%，所以：</strong>与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</p><h3 id="事件驱动event-driven"><a href="#事件驱动event-driven" class="headerlink" title="事件驱动event-driven"></a><strong>事件驱动event-driven</strong></h3><p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</p><p>Node.js底层是C++（V8也是C++写的）。<strong>底层代码中，近半数都用于事件队列、回调函数队列的构建</strong>用事件驱动来完成服务器的任务调度，这是鬼才才能想到的。针尖上的舞蹈，用一个线程，担负起了处理非常多的任务的使命。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml3268\wps3.jpg" alt="img"> </p><p>单线程，单线程的好处，减少了内存开销，操作系统的内存换页。</p><p>如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。</p><p>非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。</p><p>非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？</p><p>事件驱动，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。</p><p>Node.js中所有的I/O都是异步的，回调函数，套回调函数。</p><h2 id="适合开发什么"><a href="#适合开发什么" class="headerlink" title="适合开发什么"></a>适合开发什么</h2><p>Node.js适合用来开发什么样的应用程序呢？</p><p>善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。</p><p><strong>当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。</strong></p><p>比如：</p><p>● 用户表单收集</p><p>● 考试系统</p><p>● 聊天室</p><p>● 图文直播</p><p>● 提供JSON的API（为前台Angular使用） </p><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);<span class="comment">//require引包，引包就是引用一个功能模块</span></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//req表示请求request，res表示响应response</span></span><br><span class="line">    <span class="comment">//发送一个响应头给请求。设置HTTP头部，状态码是200，文件类型是html，字符集是UTF-8</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-type&quot;</span>:<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&#125;);</span><br><span class="line">    res.end(<span class="string">&quot;hello world&quot;</span>+(<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//运送服务器,监听3000端口（端口可以任意改动）</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到url:url=req.url;</span></span><br><span class="line"><span class="comment">//通过if判断选择哪个html文件</span></span><br><span class="line"> <span class="keyword">if</span>(url == <span class="string">&quot;/test&quot;</span>)&#123;   </span><br><span class="line">     fs.readFile(</span><br><span class="line">     path.join(__dirname,<span class="string">&#x27;../code/test.html&#x27;</span>),</span><br><span class="line">     <span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123; <span class="keyword">throw</span> err ;&#125;</span><br><span class="line">            response.end(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>var url = require(“url”);获取地址栏的地址</p><p> url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathname = url.parse(req.url).pathname;<span class="comment">//获取路径</span></span><br><span class="line"><span class="keyword">var</span> query = url.parse(req.url,<span class="literal">true</span>).query;<span class="comment">//true,是将url字符串转化成对象，获取参数</span></span><br></pre></td></tr></table></figure><ul><li><p>var fs= require(“fs”);readfile读取文件，readdir读取文件或者文件夹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path.join(__dirname,<span class="string">&quot;../code/1.txt&quot;</span>),<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"> res.end(data);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path.join(__dirname,<span class="string">&quot;../img&quot;</span>),<span class="function"><span class="keyword">function</span>(<span class="params">err,files</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//files是一个数组，表示img中所有东西，包括文件和文件夹</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;files.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> filename = files[i];</span><br><span class="line">            <span class="comment">//stat检测状态.      fs.stat(path.join(__dirname,&quot;../img/&quot;+filename),function(err,stats)&#123;</span></span><br><span class="line">           <span class="comment">//检测是否是文件夹</span></span><br><span class="line">          <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">             doc.push(filename);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.mkdir创建文件，rmdir删除文件，创建aaa文件夹     fs.mkdir(path.join(__dirname,&quot;../code/aaa&quot;),function(err,data)&#123;&#125;);</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formidabel = <span class="built_in">require</span>(<span class="string">&#x27;formidable&#x27;</span>);<span class="comment">//进行文件上传的功能模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sd = <span class="built_in">require</span>(<span class="string">&#x27;silly-datetime&#x27;</span>);<span class="comment">//进行文件日期的功能模块</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="keyword">new</span> formidabel.IncomingForm();<span class="comment">//创建一个正在进行的表单</span></span><br><span class="line">form.uploadDir = <span class="string">&#x27;./uploads&#x27;</span><span class="comment">//设置文件上传存放的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行里面的回调函数时，表单已经接受完毕form.parse(req,function(err,fields,files)&#123; </span></span><br><span class="line"><span class="comment">//所有的文本域，单选框都在fields存放    </span></span><br><span class="line"><span class="comment">//所有的文件域，files   </span></span><br><span class="line"><span class="comment">//时间，使用silly-datetime模块    </span></span><br><span class="line"><span class="keyword">var</span> ttt = sd.format(<span class="keyword">new</span> <span class="built_in">Date</span>(),<span class="string">&#x27;YYYYMMDDHHmm&#x27;</span>);    </span><br><span class="line"><span class="comment">//随机数    var ran =parseInt(Math.random()*89999+10000);    </span></span><br><span class="line"><span class="comment">//拓展名    var extname = path.extname(files.tupian.name);    </span></span><br><span class="line"><span class="comment">//执行改名   </span></span><br><span class="line"><span class="keyword">var</span> oldpath = __dirname+<span class="string">&quot;/&quot;</span>+files.tupian.path;    </span><br><span class="line"><span class="keyword">var</span> newpath = __dirname+<span class="string">&quot;/uploads/&quot;</span>+ttt+ran+extname;    </span><br><span class="line"><span class="comment">//改名    </span></span><br><span class="line">fs.rename(oldpath,newpath,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">if</span>(err)&#123;  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;改名失败&quot;</span>);  &#125;        </span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);        res.write(<span class="string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&#x27;</span>);        res.end(<span class="string">&#x27;成功&#x27;</span>);    &#125;)&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>1.module.exports</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports 返回的是模块对象</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>，</span><br><span class="line">    <span class="attr">version</span>: <span class="string">&#x27;1.0.0&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>这种方法可以返回全局共享的变量或者方法。<br>调用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app.js&#x27;</span>);</span><br><span class="line">app.sayName(<span class="string">&#x27;hello&#x27;</span>);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure><p>2.exports.     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports 返回的是模块函数</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">;</span><br><span class="line"><span class="built_in">exports</span>.function1 = func1;</span><br><span class="line"><span class="built_in">exports</span>.function2 = func2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    func1,</span><br><span class="line">    func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functions = <span class="built_in">require</span>(<span class="string">&quot;./functions&quot;</span>);</span><br><span class="line">functions.function1();</span><br><span class="line">functions.function2();</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//express</span></span><br><span class="line">cnpm iexpress -g</span><br><span class="line"></span><br><span class="line"><span class="comment">//express-generator</span></span><br><span class="line">npm install express-generator -g</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成项目文件</span></span><br><span class="line">express nodeproject</span><br></pre></td></tr></table></figure><p><strong>目录结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/bin: 用于应用启动</span><br><span class="line"></span><br><span class="line">/public: 静态资源目录</span><br><span class="line"></span><br><span class="line">/routes：可以认为是controller（控制器）目录</span><br><span class="line"></span><br><span class="line">/views: jade模板目录，可以认为是view(视图)目录</span><br><span class="line"></span><br><span class="line">app.js 程序main文件</span><br></pre></td></tr></table></figure><h1 id="process"><a href="#process" class="headerlink" title="process"></a>process</h1><p>在node中，有全局变量process表示的是当前的node进程。process.env包含着关于系统环境的信息。process.env 属性返回的是一个包含用户环境信息的对象，它可以区分开发环境或正式环境的依据。<strong>打开终端，输入node,输入process，就可以看到对应的描述信息</strong></p><h2 id="cross-env"><a href="#cross-env" class="headerlink" title="cross-env"></a><strong>cross-env</strong></h2><p><strong>1、什么是cross-env?</strong><br>它是运行跨平台设置和使用环境变量(<a href="https://blog.csdn.net/Mweb_demo/article/details/100896756">Node中的环境变量</a>)的脚本。<br><strong>2、为什么需要cross-env?</strong><br>我们在自定义配置环境变量的时候，由于在不同的环境下，配置方式也是不同的。例如在window和linux下配置环境变量。</p><p><strong>cross-env能跨平台地设置及使用环境变量</strong></p><p>大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）</p><p>cross-env让这一切变得简单，不同平台使用唯一指令，无需担心跨平台问题</p>]]></content>
      
      
      <categories>
          
          <category> node学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码片段</title>
      <link href="/2020/09/25/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
      <url>/2020/09/25/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pauseEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.stopPropagation) e.stopPropagation();</span><br><span class="line">        <span class="keyword">if</span> (e.preventDefault) e.preventDefault();</span><br><span class="line">        e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        e.returnValue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event </span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth </span><br><span class="line"><span class="keyword">var</span> target = ev.srcElement||ev.target</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取设备像素比</span></span><br><span class="line"><span class="keyword">var</span> getPixelRatio = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> backingStore =</span><br><span class="line">context.backingStorePixelRatio ||</span><br><span class="line">context.webkitBackingStorePixelRatio ||</span><br><span class="line">context.mozBackingStorePixelRatio ||</span><br><span class="line">context.msBackingStorePixelRatio ||</span><br><span class="line">context.oBackingStorePixelRatio ||</span><br><span class="line">context.backingStorePixelRatio ||</span><br><span class="line"><span class="number">1</span>;js</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>) / backingStore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> pixelRatio = getPixelRatio(canvas);</span><br></pre></td></tr></table></figure><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="蒙版"><a href="#蒙版" class="headerlink" title="蒙版"></a>蒙版</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span>:after&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(data-text);</span><br><span class="line">    <span class="comment">/* transition:all 1s ease; */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* .page:hover:after&#123;</span></span><br><span class="line"><span class="comment">    transform: translateY(0);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图标固定</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line">  $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = $(<span class="built_in">document</span>).scrollTop() - $(<span class="string">&quot;.guide-box&quot;</span>).offset().top;</span><br><span class="line">    <span class="keyword">let</span> b = $(<span class="string">&quot;.guide-ico&quot;</span>).css(<span class="string">&quot;margin-top&quot;</span>);</span><br><span class="line">    b = b.substr(<span class="number">0</span>, b.length - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; a - c &gt; <span class="number">0</span> &amp;&amp; a &lt; $(<span class="string">&quot;.guide-box&quot;</span>).height() * <span class="number">0.8</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a  &gt; b) &#123;</span><br><span class="line">        $(<span class="string">&quot;.guide-ico&quot;</span>).css(&#123;</span><br><span class="line">          <span class="attr">top</span>: a - b,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; a - c &lt; <span class="number">0</span> &amp;&amp;a &lt; $(<span class="string">&quot;.guide-box&quot;</span>).height() * <span class="number">0.8</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        $(<span class="string">&quot;.guide-ico&quot;</span>).css(&#123;</span><br><span class="line">          <span class="attr">top</span>: a-b,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c = a;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="async"><a href="#async" class="headerlink" title="async"></a><strong>async</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在async中将异步的代码同步执行</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> fn()</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolved(<span class="number">3</span>);</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 ​​​​​at ​quokka.js:2:2​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​quokka.js:10:4​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​v​​​ ​quokka.js:13:4​</span><br><span class="line"></span><br><span class="line">4 ​​​​​at ​quokka.js:16:2​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​quokka.js:5:8​</span><br></pre></td></tr></table></figure><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a><strong>promise</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">a.then(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 ​​​​​at ​quokka.js:2:2​</span><br><span class="line"></span><br><span class="line">Promise &#123;&#125; ​​​​​at ​​​a​​​ ​quokka.js:11:0​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​quokka.js:4:4​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​​​index​​​ ​quokka.js:9:2​</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sortNums = <span class="built_in">Array</span>.from(nums).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = sortNums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> l = nums[left];</span><br><span class="line">    <span class="keyword">const</span> r = nums[right];</span><br><span class="line">    <span class="keyword">const</span> currentNum = l + r;</span><br><span class="line">    <span class="keyword">if</span> (currentNum === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> [left, right];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNum &gt; target) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>数组去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p> 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstUniqChar = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (position.has(i)) &#123;</span><br><span class="line">      position.set(i, position.get(i) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      position.set(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (position.get(s[i]) === <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//s = &quot;leetcode&quot;</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s = &quot;loveleetcode&quot;</span></span><br><span class="line">返回 <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</p></blockquote><p>  <strong>快速排序的思想很简单，整个排序过程只需要三步：</strong></p><ul><li>（1）在数据集之中，找一个基准点</li><li>（2）建立两个数组，分别存储左边和右边的数组</li><li>（3）利用递归进行下次比较</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];    <span class="comment">// 返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> c = arr.splice(cIndex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> l = [];</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; c) &#123;</span><br><span class="line">            l.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(l).concat(c, quickSort(r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="1-阶乘"><a href="#1-阶乘" class="headerlink" title="1.阶乘"></a>1.阶乘</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="https://user-gold-cdn.xitu.io/2020/5/18/17226641e33cf0db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><p>  f(6) = n * f(5)，所以 f(6) 需要拆解成 f(5) 子问题进行求解，以此类推 f(5) = n * f(4) ，也需要进一步拆分 … 直到 f(1)，「这是递的过程。」 f(1) 解决后，依次可以解决f(2)…. f(n)最后也被解决，「这是归的过程。」</p><p>  归无非就是把问题拆解成具有相同解决思路的子问题，直到最后被拆解的子问题不能够拆分，这个过程是“递”。当解决了最小粒度可求解的子问题后，在“归”的过程中顺其自然的解决了最开始的问题。</p><p>  <strong>复杂度分析</strong></p><ul><li>空间复杂度为 O(n)</li><li>时间复杂度 O(2^n)</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总时间 = 子问题个数 * 解决一个子问题需要的时间</span><br></pre></td></tr></table></figure><ul><li>子问题个数即递归树中的节点总数 2^n</li><li>解决一个子问题需要的时间，因为只有一个加法操作 <code>fib(n-1) + fib(n-2)</code> ，所以解决一个子问题的时间为 <code>O(1)</code></li></ul><p>  二者相乘，得出算法的时间复杂度为 <code>O(2^n)</code></p><h3 id="2-实现深拷贝"><a href="#2-实现深拷贝" class="headerlink" title="2.实现深拷贝"></a>2.实现深拷贝</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = deepClone(source[key])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target = source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a =&#123;<span class="attr">name</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],<span class="attr">age</span>:[<span class="number">10</span>,<span class="number">15</span>],<span class="attr">book</span>:&#123;<span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>,k]&#125;&#125;</span><br><span class="line">  <span class="keyword">let</span> b = deepClone(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a == b)</span><br><span class="line">  <span class="keyword">let</span> c = a</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="built_in">console</span>.log(c == a)</span><br></pre></td></tr></table></figure><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h3><ul><li><p>使用递归实现<code>getElementsByClassName</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">byClass</span>(<span class="params">node, className, arr</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//得到传入节点的所有子节点</span></span><br><span class="line">       <span class="keyword">var</span> lists = node.childNodes;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">           <span class="comment">//判断是否有相同className元素</span></span><br><span class="line">           <span class="keyword">if</span>(arr[i],className == className)&#123;</span><br><span class="line">               arr.push(arr[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断子节点是否还有子节点</span></span><br><span class="line">           <span class="keyword">if</span>(arr[i].childNodes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               byClass(arr[i],className,arr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>有一堆桃子，每天吃掉一半，挑出一个坏的扔掉，第6天的时候发现还剩1个桃子，问原来有多少个桃子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = (fn(n-<span class="number">1</span>)+<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">7</span>)) <span class="comment">//190</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> 代码片段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/09/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/09/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h1><ul><li>普通字符abc  123</li><li>特殊字符(元字符)：正则表达式中有特殊意义的字符\d  \w</li></ul><p>示例演示：</p><ul><li><code>\d</code> 匹配数字</li><li><code>ab\d</code> 匹配 ab1、ab2</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h3><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线</td></tr><tr><td>\W</td><td>匹配任意不是字母，数字，下划线</td></tr><tr><td>\s</td><td>匹配任意的空白符（包括空格、制表符、换页符）</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>.</td><td>匹配除换行符以外的任意单个字符</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>在限定符之后的表达式能够匹配成功的情况下，不定次数的限定符总是尽可能的多匹配。如果之后的表达式匹配失败，限定符可适当“让出”能够匹配的字符，以使整个表达式匹配成功。这种模式就叫“贪婪模式”。</p><table><thead><tr><th>限定符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>表达式尽可能的多匹配，最少可以不匹配，相当于 <strong>{0, }</strong></td></tr><tr><td>+</td><td>表达式尽可能的多匹配，至少匹配1次，相当于 <strong>{1, }</strong></td></tr><tr><td>?</td><td>表达式尽可能匹配1次，也可以不匹配，相当于 <strong>{0, 1}</strong></td></tr><tr><td>{n}</td><td>表达式固定重复n次</td></tr><tr><td>{n,}</td><td>表达式尽可能的多匹配，至少重复n次</td></tr><tr><td>{n,m}</td><td>表达式尽可能重复m次，至少重复n次</td></tr><tr><td><strong>{n, m}?</strong></td><td>表达式尽量只匹配n次，最多重复m次。</td></tr><tr><td><strong>{m, n}+</strong></td><td>表达式尽可能重复n次，至少重复m次。</td></tr></tbody></table><p>在限定符之后添加问号(?)，则使限定符成为“勉强模式”。勉强模式的限定符，<strong>总是尽可能少的匹配</strong>。如果之后的表达式匹配失败，勉强模式也可以尽可能少的再匹配一些，以使整个表达式匹配成功。</p><p>在限定符之后添加加号(+)，则使限定符成为“占有模式”。占有模式的限定符，总是尽可能多的匹配。与“贪婪模式”不同的是，即使之后的表达式匹配失败，“占有模式”也不会“让出”自己能够匹配的字符。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><p>边界</p><table><thead><tr><th>^</th><th>表示匹配行首的文本(以谁开始)</th></tr></thead><tbody><tr><td>$</td><td>表示匹配行尾的文本(以谁结束)</td></tr><tr><td><strong>\b</strong></td><td>当前位置的左右两侧，只能有一侧是字母数字或下划线</td></tr></tbody></table></li><li><p>转义符</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td>\r, \n</td><td>代表回车和换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 “&quot; 本身</td></tr></tbody></table></li><li><p><strong>有特殊用处的标点符号，在前面加 “\” 后，就代表该符号本身</strong></p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td>^</td><td>匹配 ^ 符号本身</td></tr><tr><td>\ $</td><td>匹配 $ 符号本身</td></tr><tr><td>\ .</td><td>匹配小数点（.）本身</td></tr></tbody></table></li><li><p>方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。[^]  匹配除中括号以内的内容</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><strong>[ab5@]</strong></td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td><strong>[^abc]</strong></td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td><strong>[f-k]</strong></td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td><strong>[^A-F0-3]</strong></td><td>匹配 “A”<del>“F”,”0”</del>“3” 之外的任意一个字符</td></tr></tbody></table></li><li><p>| 选择左右两边的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱。</p></li><li><p>() 从两个直接量中选择一个，分组<br>   eg：gr(a|e)y匹配gray和grey<br>[\u4e00-\u9fa5]  匹配汉字</p></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>验证手机号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">11</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证邮编：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">6</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证日期 2012-5-01 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证邮箱 <a href="mailto:&#x78;&#x78;&#x78;&#64;&#105;&#x74;&#99;&#97;&#115;&#116;&#x2e;&#x63;&#x6e;">&#x78;&#x78;&#x78;&#64;&#105;&#x74;&#99;&#97;&#115;&#116;&#x2e;&#x63;&#x6e;</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\w+@\w+\.\w+$</span><br></pre></td></tr></table></figure><p>验证IP地址 192.168.1.10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\(.\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)&#123;<span class="number">3</span>&#125;$</span><br></pre></td></tr></table></figure><h1 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h1><h2 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h2><p>方式1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局匹配</td></tr><tr><td>gi</td><td>全局匹配+忽略大小写</td></tr></tbody></table><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2015-10-10&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure><h2 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2016-1-5&#x27;</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc,efg,123，abc,123，a&quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散装的学习笔记</title>
      <link href="/2020/09/25/learn-tip/"/>
      <url>/2020/09/25/learn-tip/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><p>fe-interview-code</p><p>工作时间，平时福利待遇，节假日，电脑，5险一金，年终奖，出差，加班（），技术栈,</p><p><strong>uniapp</strong></p><p>tab选项卡，滑动切换</p><p>页面跳转动画</p><p><strong>react</strong></p><p>css-in-js</p><p>postcss</p><p><strong>css</strong></p><p>history.pushState()和history.replaceState()</p><p><strong>vue</strong></p><p>Vue 中使用<code>lib-flexible</code>和<code>postcss-pxtorem</code>将<code>px</code>单位转化为<code>rem</code>单位</p><p>left，d3，openlayers，gis</p><p><strong>data100</strong></p><p>月报，周报，日报</p><p>打卡</p><p><strong>关于测试、Bug处理、代码检查要求</strong></p><p>git流程，功能迭代流程</p><p><strong>关于TAPD的使用规则</strong></p><h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>按F1或ctrl+shift+P键入<code>Live Sass: Watch Sass</code>以开始实时编译，或者按键入<code>Live Sass: Stop Watching Sass</code>以停止实时编译。</p><h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>window+r —&gt; sysdm.cpl —&gt; 高级 —&gt;环境变量</p><h3 id="任务进程"><a href="#任务进程" class="headerlink" title="任务进程"></a>任务进程</h3><p>查看任务进程：tasklist<br>删除任务pid ：taskkill /f /pid<br>taskkill /f /im 程序名 杀掉对应程序名称的所有进程<br>netstat -ano | find “3306”查看3306端口的任务进程</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="Windows-字体"><a href="#Windows-字体" class="headerlink" title="Windows 字体"></a>Windows 字体</h3><p><a href="https://sspai.com/post/35133">https://sspai.com/post/35133</a></p><h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p><a href="https://www.zhihu.com/question/45120814">https://www.zhihu.com/question/45120814</a></p><p>软媒桌面</p><p>TranslucentTB</p><h3 id="录屏工具"><a href="#录屏工具" class="headerlink" title="录屏工具"></a>录屏工具</h3><p>LICEcap</p><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>snipaste</p><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><h4 id="babun"><a href="#babun" class="headerlink" title="babun"></a>babun</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vscode配置babun</span><br><span class="line"><span class="string">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="string">&quot;C:\\Users\\YOURUSERNAME\\.babun\\cygwin\\bin\\zsh.exe&quot;</span>,</span><br></pre></td></tr></table></figure><ul><li><p>WARNING: UNPROTECTED PRIVATE KEY FILE!   </p><p>tips:chmod 700 ~/.ssh/id_rsa  更改权限</p></li></ul><h4 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h4><h5 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h5><p><a href="https://blog.csdn.net/weixin_42595232/article/details/106012575?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_42595232/article/details/106012575?spm=1001.2014.3001.5506</a></p><ul><li><p>创建命令行数据文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &quot;%USERPROFILE%\AppData\Local\terminal&quot;</span><br><span class="line">对应我自己电脑的文件目录就是：</span><br><span class="line">C:\Users\niefajun\AppData\Local\terminal</span><br></pre></td></tr></table></figure></li><li><p>下载（<a href="https://github.com/microsoft/terminal/tree/master/res%EF%BC%89terminal.ico%EF%BC%8C">https://github.com/microsoft/terminal/tree/master/res）terminal.ico，</a> 存储到刚才创建的目录当中 </p></li><li><p>编写注册表文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@=&quot;Windows terminal here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;C:\\Users\\niefajun\\AppData\\Local\\terminal\\terminal.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@=&quot;C:\\Users\\niefajun\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后另存文件为：<code>wt.reg</code>，要保证格式正确。<br>程序说明：</p><ol><li>第一部分，说明是windows注册表</li><li>第二部分，是说明鼠标右键显示菜单缩略图的存储位置</li><li>第三部分，说明<code>Windows Terminate</code>的实际命令的存储位置</li></ol></li><li><p>运行生效注册表文件</p></li><li><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加如下内容：</span><br><span class="line">&quot;startingDirectory&quot;: &quot;.&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200509095325779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU5NTIzMg==,size_16,color_FFFFFF,t_70" alt="01-10"> </p></li></ul><h5 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h5><p><a href="https://blog.csdn.net/lmz_lmz/article/details/88341807">https://blog.csdn.net/lmz_lmz/article/details/88341807</a></p><ul><li><p>管理员权限运行powershell并运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure></li><li><p>重启电脑</p></li><li><p>打开应用商城搜索“WSL”，可根据自己需求选择安装一个或多个Linux系统：ubuntu</p></li><li><p>安装完成后可在开始菜单里找到快捷方式并启动，第一次运行需要等待安装并设置用户名、密码。</p></li><li><p>访问WSL的根目录:</p><p>C:\Users\EDZ\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</p></li></ul><h5 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h5><p>安装zsh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><p>安装oh-my-zsh</p><p><a href="https://www.jianshu.com/p/30388763cf63">https://www.jianshu.com/p/30388763cf63</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>设置默认 shell 为 zsh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><p>设置完成后使用下列命令检查是否设置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><h5 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h5><p>然后在 .zshrc 中增加：</p><p>export NVM_DIR=”$HOME/.nvm”<br>[ -s “$NVM_DIR/nvm.sh” ] &amp;&amp; . “$NVM_DIR/nvm.sh”  # This loads nvm<br>[ -s “$NVM_DIR/bash_completion” ] &amp;&amp; . “$NVM_DIR/bash_completion”  # This loads nvm bash_completion<br>1<br>2<br>3</p><p>————————————————<br>版权声明：本文为CSDN博主「亮子介」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/henryhu712/article/details/85217165">https://blog.csdn.net/henryhu712/article/details/85217165</a></p><ul><li><p>插件权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755  /root/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></li><li><p>vscode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\WINDOWS\\System32\\wsl.exe&quot;,</span><br></pre></td></tr></table></figure></li></ul><h1 id="ubuntu-1"><a href="#ubuntu-1" class="headerlink" title="ubuntu"></a>ubuntu</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h3><p>**1.非常有用的清理命令：                                                                                                                                      **</p><p>sudo apt-get autoclean        清理旧版本的软件缓存<br>sudo apt-get clean          清理所有软件缓存<br>sudo apt-get autoremove       删除系统不再使用的孤立软件<br>这三个命令主要清理升级缓存以及无用包的。</p><p><strong>2.清理opera firefox的缓存文件：</strong><br>ls ~/.opera/cache4<br>ls ~/.mozilla/firefox/*.default/Cache</p><p><strong>3.删除文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf  + 要删除的文件   进行删除</span><br><span class="line">-r 表示向下递归</span><br><span class="line">-f 表示强制删除，不作任何提示</span><br><span class="line"></span><br><span class="line">rm -rf generated/*</span><br></pre></td></tr></table></figure><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>ls -al查看文件读写权限</p><h3 id="ps进程指令"><a href="#ps进程指令" class="headerlink" title="ps进程指令"></a><strong>ps进程指令</strong></h3><p>linux上进程有5种状态:</p><ol><li><p>运行(正在运行或在运行队列中等待)</p></li><li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p></li><li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p></li><li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p></li><li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p></li></ol><p>1）ps a      显示现行终端机下的所有程序，包括其他用户的程序。</p><p>2）ps -A    显示所有程序。</p><p>3）ps u     以用户为主的格式来显示程序状况。</p><p>4）ps x 　 显示所有程序，不以终端机来区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">//查看username下的进程</span><br><span class="line">ps  -u username</span><br><span class="line">//查看程序的PID</span><br><span class="line">pgrep 程序名</span><br><span class="line">//结束进程</span><br><span class="line">kill -9 PID # PID是进程号,查看进程时会显示</span><br><span class="line">//结束某个程序</span><br><span class="line">pkill  程序名</span><br></pre></td></tr></table></figure><p>Ubuntu中找到并杀死僵尸进程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//status</span><br><span class="line">D 无法中断的休眠状态（通常 IO 的进程）；</span><br><span class="line">R 正在运行可中在队列中可过行的；</span><br><span class="line">S 处于休眠状态；</span><br><span class="line">T 停止或被追踪；</span><br><span class="line">W 进入内存交换 （从内核2.6开始无效）；</span><br><span class="line">X 死掉的进程  （基本很少見）；</span><br><span class="line">Z 僵尸进程；</span><br><span class="line"></span><br><span class="line">ps aux | grep &#x27;Z&#x27; 来找到僵尸进程</span><br><span class="line">//pstree树状显示进程信息</span><br><span class="line">pstree -p -s PID来寻找编号为PID进程也就是僵尸进程的父级进程。</span><br></pre></td></tr></table></figure><h3 id="删除多余内核"><a href="#删除多余内核" class="headerlink" title="删除多余内核"></a><strong>删除多余内核</strong></h3><p><strong>1，首先要使用这个命令查看当前Ubuntu系统使用的内核</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>2，再查看所有内核</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections|grep linux </span><br></pre></td></tr></table></figure><p><strong>3，最后小心翼翼地删除吧</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove linux-image-2.6.32-22-generic</span><br></pre></td></tr></table></figure><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建目录mkdir</span><br><span class="line">创建文件touch</span><br><span class="line">查询绝对路径pwd</span><br><span class="line">将文件1复制到文件2或者某个路径中       cp 文件1 文件2/路径 </span><br><span class="line">移动文件  mv </span><br><span class="line">重命名   mv 文件1文件2</span><br><span class="line"></span><br><span class="line">删除 rm -rf generated/*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls     </span><br><span class="line">ll(文件详细信息)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> du -sh *  查看文件列表和大小</span><br><span class="line">--------</span><br><span class="line">217M@tarojs</span><br><span class="line">5.0Mautocannon</span><br><span class="line"> 58Mcnpm</span><br><span class="line"> 53Mcommitizen</span><br><span class="line">  0Bcw-tool</span><br><span class="line"> 65Melasticdump</span><br></pre></td></tr></table></figure><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim 文件</span><br><span class="line"></span><br><span class="line">1.插入模式：i</span><br><span class="line"></span><br><span class="line">2.正常模式:esc</span><br><span class="line">复制一行/N行yy /Nyy</span><br><span class="line">粘贴p</span><br><span class="line">剪切一行/N行dd/Ndd</span><br><span class="line">撤销u</span><br><span class="line"></span><br><span class="line">3.命令模式：shift+：</span><br></pre></td></tr></table></figure><h2 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a><strong>软件</strong></h2><h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><p>输入<code>dpkg --list</code> ,按下Enter键，终端输出以下内容，显示的是你电脑上安装的所有软件。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//安装软件包</span><br><span class="line">sudo dpkg -i  </span><br><span class="line">//安装软件</span><br><span class="line"> sudo apt-get install</span><br><span class="line"> //安装源码包</span><br><span class="line"> ./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">//安装出错，修复依赖</span><br><span class="line">sudo apt-get install -f</span><br><span class="line"></span><br><span class="line">//卸载</span><br><span class="line">sudo dpkg -r linuxqq </span><br><span class="line">sudo apt-get remove  linuxqq </span><br><span class="line">1）移除式卸载：apt-get remove softname1 softname2 …;（移除软件包，当包尾部有+时，意为安装）</span><br><span class="line">2）清除式卸载 ：apt-get –purge remove softname1 softname2…;(同时清除配置)</span><br><span class="line"></span><br><span class="line">//更新软件信息数据库</span><br><span class="line">sudo apt-get update——更新源</span><br><span class="line">sudo apt-get dist-upgrade </span><br><span class="line">apt-get upgrade ——更新已安装的包</span><br><span class="line">//进行系统升级</span><br><span class="line">apt-get dist-upgrade # ———升级系统</span><br><span class="line"></span><br><span class="line">apt-get check #——-检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><h3 id="截图软件flameshot"><a href="#截图软件flameshot" class="headerlink" title="截图软件flameshot"></a>截图软件flameshot</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flameshot</span><br></pre></td></tr></table></figure><p><strong>快捷键设置：</strong></p><p>设置——设备——键盘，拉到最下面，添加快捷键，“命令”输入“flameshot gui”</p><p><img src="https://img-blog.csdnimg.cn/20190710114019202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd5dWFua2wxMjM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="zsh（终端）"><a href="#zsh（终端）" class="headerlink" title="zsh（终端）"></a>zsh（终端）</h3><p>windows下好用的终端: consolez, <a href="https://github.com/babun/babun">babun</a> +cmder,wsl</p><p>1.安装zsh<br>2.在根目录下的.zshrc文件中可以添加插件</p><ul><li><p>z 是跳转目录，他会记得你进入过的目录<br>先<code>cd /usr/share/fonts/</code><br>下一次直接<code>z fonts</code>即可</p></li><li><p>web-search<br>这个插件允许你直接从终端打开浏览器进行搜索<br>比如<code>baidu 随意随缘</code></p></li><li><p>extract<br>万能解压，不管什么压缩文件包括zip,rar,tar<br>输入<code>x 文件名</code>即可调用正确工具进行解压（前提是已经安装好工具）</p></li><li><p>git-open</p><p><a href="https://github.com/paulirish/git-open">git-open</a>插件可以在你git项目下打开远程仓库浏览项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git open</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">git</span><br><span class="line">z</span><br><span class="line">git-open</span><br><span class="line">zsh-autosuggestions</span><br><span class="line">zsh-syntax-highlighting</span><br><span class="line">web-search</span><br><span class="line">extract</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>终端执行 source .zshrc，加载扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以下是当source .zshrc执行时，一些扩展没有添加，从而命令行执行</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//切换zsh终端</span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"></span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//安装zsh后nvm、npm失效</span><br><span class="line">安装zsh后原来安装的nvm及npm都失效了</span><br><span class="line">查看原来的配置nvm的信息还在</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">在 ~/.zshrc 中再次添加原nvm在 ~/.bashrc 中的配置(搜索export可找到nvm配置)，并 source ~/.zshrc 即可</span><br><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure><p>3.将命令行翻墙脚本放在.zshrc文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias proxy=&quot;export all_proxy=socks5://127.0.0.1:1089&quot;</span><br><span class="line">alias unproxy=&quot;unset all_proxy&quot;</span><br></pre></td></tr></table></figure><h3 id="dingding"><a href="#dingding" class="headerlink" title="dingding"></a>dingding</h3><ul><li><a href="https://github.com/nashaofu/dingtalk">https://github.com/nashaofu/dingtalk</a></li></ul><h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><p><strong>rar</strong></p><p>压缩功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rar</span><br></pre></td></tr></table></figure><p>解压功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install unrar</span><br></pre></td></tr></table></figure><p>使用</p><ol><li>可以直接在UI界面使用了</li><li><code>rar x test.rar</code></li></ol><p><strong>.tar</strong></p><p>解包：tar xvf FileName.tar</p><p>打包：tar cvf FileName.tar DirName</p><p><strong>.gz</strong></p><p>解压1：gunzip FileName.gz</p><p>解压2：gzip -d FileName.gz</p><p>压缩：gzip FileName</p><p><strong>.tar.gz 和 .tgz</strong></p><p>解压：tar zxvf FileName.tar.gz</p><p>压缩：tar zcvf FileName.tar.gz DirName</p><p><strong>.zip</strong></p><p>解压：unzip FileName.zip</p><p>压缩：zip FileName.zip DirName</p><h3 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h3><p><a href="https://snapcraft.io/install/qv2ray/ubuntu#install">https://snapcraft.io/install/qv2ray/ubuntu#install</a></p><h3 id="Synaptic-Package-Manager"><a href="#Synaptic-Package-Manager" class="headerlink" title="Synaptic Package Manager"></a>Synaptic Package Manager</h3><p>是基于APT的图形化包管理工具，它不仅能列出ubuntu系统中所有已经安装的程序，还可以用于安装、卸载、升级软件。系统默认没有此工具，因此需要先通过命令行来安装它。<br>1、运行命令行<br>2、sudo apt update<br>3、sudo apt install synaptic<br>4、运行Synaptic</p><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><p><a href="https://blog.csdn.net/henryhu712/article/details/85217165">https://blog.csdn.net/henryhu712/article/details/85217165</a></p><p><a href="https://blog.csdn.net/geol200709/article/details/82117103">https://blog.csdn.net/geol200709/article/details/82117103</a></p><p>cd ~/ - -切到主目录<br>git clone <a href="https://github.com/creationix/nvm.git">https://github.com/creationix/nvm.git</a> .nvm - -克隆代码到文件夹 .nvm<br>cd ~/.nvm - -进入nvm代码目录<br>git checkout v0.33.11 - -切换到v0.33.11版本</p><p>设置国内镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</span><br></pre></td></tr></table></figure><p>查看可供安装的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure><p>安装一个nodejs版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v12.16.1</span><br></pre></td></tr></table></figure><p>查看本地安装的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><ul><li><p>在.zshrc中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure></li></ul><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Ctr+L 选中当前句子<br>Ctr+D 选中当前词<br>Ctr+J  跳转到光标<br>Ctr+数字 标题<br>Ctr+Shift +K 代码块<br>Ctr+Shift +` 代码</p><h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><table><thead><tr><th align="left">功能</th><th align="left">热键（Windows / Linux）</th><th align="left">热键（macOS）</th></tr></thead><tbody><tr><td align="left">新</td><td align="left">Ctrl + N.</td><td align="left">Command + N.</td></tr><tr><td align="left">新窗户</td><td align="left">Ctrl + Shift + N.</td><td align="left">Command + Shift + N.</td></tr><tr><td align="left">新标签</td><td align="left"><em>（不支持）</em></td><td align="left">Command + T.</td></tr><tr><td align="left">打开</td><td align="left">Ctrl + O.</td><td align="left">Command + O.</td></tr><tr><td align="left">快速打开</td><td align="left">Ctrl + P.</td><td align="left">Command + Shift + O.</td></tr><tr><td align="left">重新打开已关闭的文件</td><td align="left">Ctrl + Shift + T.</td><td align="left">Command + Shift + T.</td></tr><tr><td align="left">保存</td><td align="left">Ctrl + S.</td><td align="left">Command + S.</td></tr><tr><td align="left">另存为/重复</td><td align="left">Ctrl + Shift + S.</td><td align="left">Command + Shift + S.</td></tr><tr><td align="left">偏爱</td><td align="left">Ctrl +，</td><td align="left">Command +，</td></tr><tr><td align="left">关</td><td align="left">Ctrl + W</td><td align="left">Command + W</td></tr></tbody></table><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><table><thead><tr><th align="left">功能</th><th align="left">热键（Windows / Linux）</th><th align="left">热键（macOS）</th></tr></thead><tbody><tr><td align="left">新段落</td><td align="left">输入</td><td align="left">输入</td></tr><tr><td align="left">新队</td><td align="left">Shift + Enter</td><td align="left">Shift + Enter</td></tr><tr><td align="left">切</td><td align="left">Ctrl + X.</td><td align="left">Command + X.</td></tr><tr><td align="left">复制</td><td align="left">Ctrl + C.</td><td align="left">Command + C.</td></tr><tr><td align="left">糊</td><td align="left">Ctrl + V.</td><td align="left">Command + V.</td></tr><tr><td align="left">复制为Markdown</td><td align="left">Ctrl + Shift + C.</td><td align="left">Command + Shift + C.</td></tr><tr><td align="left">粘贴为纯文本</td><td align="left">Ctrl + Shift + V.</td><td align="left">Command + Shift + V.</td></tr><tr><td align="left">全选</td><td align="left">Ctrl + A.</td><td align="left">Command + A.</td></tr><tr><td align="left">选择行/句子 选择行（在表格中）</td><td align="left">Ctrl + L.</td><td align="left">Command + L.</td></tr><tr><td align="left">删除行（在表中）</td><td align="left">Ctrl + Shift + Backspace</td><td align="left">Command + Shift + Backspace</td></tr><tr><td align="left">选择样式范围 选择单元格（在表格中）</td><td align="left">Ctrl + E.</td><td align="left">Command + E.</td></tr><tr><td align="left">选择Word</td><td align="left">Ctrl + D.</td><td align="left">Command + D.</td></tr><tr><td align="left">删除Word</td><td align="left">Ctrl + Shift + D.</td><td align="left">Command + Shift + D.</td></tr><tr><td align="left">跳到顶部</td><td align="left">Ctrl + Home</td><td align="left">Command +↑</td></tr><tr><td align="left">跳转到选择</td><td align="left">Ctrl + J</td><td align="left">Command + J</td></tr><tr><td align="left">跳到Buttom</td><td align="left">Ctrl + End</td><td align="left">Command +↓</td></tr><tr><td align="left">找</td><td align="left">Ctrl + F.</td><td align="left">Command + F.</td></tr><tr><td align="left">找下一个</td><td align="left">F3 /回车</td><td align="left">Command + G / Enter</td></tr><tr><td align="left">找到上一个</td><td align="left">Shift + F3 / Shift + Enter</td><td align="left">Command + Shift + G / Shift + Enter</td></tr><tr><td align="left">更换</td><td align="left">Ctrl + H.</td><td align="left">Command + H.</td></tr></tbody></table><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><table><thead><tr><th align="left">功能</th><th align="left">热键（Windows / Linux）</th><th align="left">热键（macOS）</th></tr></thead><tbody><tr><td align="left">标题1到6</td><td align="left">Ctrl + 1/2/3/4/5/6</td><td align="left">Command + 1/2/3/4/5/6</td></tr><tr><td align="left">段</td><td align="left">Ctrl + 0</td><td align="left">命令+ 0</td></tr><tr><td align="left">提高标题级别</td><td align="left">Ctrl + =</td><td align="left">命令+ =</td></tr><tr><td align="left">降低标题级别</td><td align="left">Ctrl + -</td><td align="left">命令+ -</td></tr><tr><td align="left">表</td><td align="left">Ctrl + T.</td><td align="left">Command + Option + T.</td></tr><tr><td align="left">代码围栏</td><td align="left">Ctrl + Shift + K.</td><td align="left">Command + Option + C.</td></tr><tr><td align="left">数学块</td><td align="left">Ctrl + Shift + M.</td><td align="left">Command + Option + B.</td></tr><tr><td align="left">引用</td><td align="left">Ctrl + Shift + Q.</td><td align="left">Command + Option + Q.</td></tr><tr><td align="left">订购清单</td><td align="left">Ctrl + Shift + [</td><td align="left">Command + Option + O.</td></tr><tr><td align="left">无序列表</td><td align="left">Ctrl + Shift +]</td><td align="left">Command + Option + U.</td></tr><tr><td align="left">缩进</td><td align="left">Ctrl + [/ Tab</td><td align="left">Command + [/ Tab</td></tr><tr><td align="left">减少缩进</td><td align="left">Ctrl +] / Shift + Tab</td><td align="left">Command +] / Shift + Tab</td></tr></tbody></table><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><table><thead><tr><th align="left">功能</th><th align="left">热键（Windows / Linux）</th><th align="left">热键（macOS）</th></tr></thead><tbody><tr><td align="left">强大</td><td align="left">Ctrl + B.</td><td align="left">Command + B.</td></tr><tr><td align="left">重点</td><td align="left">Ctrl + I</td><td align="left">命令+我</td></tr><tr><td align="left">强调</td><td align="left">Ctrl + U.</td><td align="left">Command + U.</td></tr><tr><td align="left">码</td><td align="left">Ctrl + Shift +`</td><td align="left">Command + Shift +`</td></tr><tr><td align="left">罢工</td><td align="left">Alt + Shift + 5</td><td align="left">Control + Shift +`</td></tr><tr><td align="left">超链接</td><td align="left">Ctrl + K.</td><td align="left">Command + K.</td></tr><tr><td align="left">图片</td><td align="left">Ctrl + Shift + I</td><td align="left">Command + Control + I</td></tr><tr><td align="left">清除格式</td><td align="left">Ctrl + \</td><td align="left">命令+</td></tr></tbody></table><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><table><thead><tr><th align="left">功能</th><th align="left">热键（Windows / Linux）</th><th align="left">热键（macOS）</th></tr></thead><tbody><tr><td align="left">切换补充工具栏</td><td align="left">Ctrl + Shift + L.</td><td align="left">Command + Shift + L.</td></tr><tr><td align="left">大纲</td><td align="left">Ctrl + Shift + 1</td><td align="left">Command + Control + 1</td></tr><tr><td align="left">用品</td><td align="left">Ctrl + Shift + 2</td><td align="left">Command + Control + 2</td></tr><tr><td align="left">文件树</td><td align="left">Ctrl + Shift + 3</td><td align="left">Command + Control + 3</td></tr><tr><td align="left">源代码模式</td><td align="left">Ctrl + /</td><td align="left">命令+ /</td></tr><tr><td align="left">Fouus模式</td><td align="left">F8</td><td align="left">F8</td></tr><tr><td align="left">打字机模式</td><td align="left">F9</td><td align="left">F9</td></tr><tr><td align="left">Toggler全屏</td><td align="left">F11</td><td align="left">Command + Option + F.</td></tr><tr><td align="left">真实大小</td><td align="left">Ctrl + Shift + 0</td><td align="left"><em>（不支持）</em></td></tr><tr><td align="left">放大</td><td align="left">Ctrl + Shift + =</td><td align="left"><em>（不支持）</em></td></tr><tr><td align="left">缩小</td><td align="left">Ctrl + Shift + -</td><td align="left"><em>（不支持）</em></td></tr><tr><td align="left">在打开的Documnets之间切换</td><td align="left">Ctrl + Tab</td><td align="left">命令+`</td></tr><tr><td align="left">切换DevTools</td><td align="left">Ctrl + Shift + I</td><td align="left">-</td></tr></tbody></table><h1 id="cmdr"><a href="#cmdr" class="headerlink" title="cmdr"></a>cmdr</h1><p>Tab       自动路径补全<br>Ctrl+T    建立新页签<br>Ctrl+W    关闭页签<br>Ctrl+Tab  切换页签<br>Alt+F4    关闭所有页签<br>Alt+Shift+1 开启cmd.exe<br>Alt+Shift+2 开启powershell.exe<br>Alt+Shift+3 开启powershell.exe (系统管理员权限)<br>Ctrl+1      快速切换到第1个页签<br>Ctrl+n      快速切换到第n个页签( n值无上限)<br>Alt + enter 切换到全屏状态<br>Ctr+r       历史命令搜索<br>Win+Alt+P   开启工具选项视窗</p>]]></content>
      
      
      <categories>
          
          <category> 散装的学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> wsl </tag>
            
            <tag> window </tag>
            
            <tag> ubuntu </tag>
            
            <tag> nvm </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp</title>
      <link href="/2020/09/25/uniapp/"/>
      <url>/2020/09/25/uniapp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="eBook"><a href="#eBook" class="headerlink" title="eBook"></a>eBook</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g <span class="keyword">@vue</span>/cli</span><br></pre></td></tr></table></figure><h1 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h1><h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1.命令"></a>1.命令</h2><ul><li><p>运行以下命令来创建一个新项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。</p><p><img src="https://cli.vuejs.org/cli-new-project.png" alt="CLI 预览"></p><p>手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。</p><p><img src="https://cli.vuejs.org/cli-select-features.png" alt="CLI 预览"></p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用uniapp模板创建项目</span><br><span class="line">vue create -p dcloudio/uni-preset-vue my-project</span><br></pre></td></tr></table></figure><h3 id="使用cli创建项目和使用HBuilderX可视化界面创建项目有什么区别"><a href="#使用cli创建项目和使用HBuilderX可视化界面创建项目有什么区别" class="headerlink" title="使用cli创建项目和使用HBuilderX可视化界面创建项目有什么区别"></a>使用cli创建项目和使用HBuilderX可视化界面创建项目有什么区别</h3><ul><li>编译器的区别<ul><li>cli创建的项目，编译器安装在项目下。并且不会跟随HBuilderX升级。如需升级编译器，执行n<strong>pm update</strong>。</li><li>HBuilderX可视化界面创建的项目，编译器在HBuilderX的安装目录下的plugin目录，随着HBuilderX的升级会自动升级编译器。</li><li>已经使用cli创建的项目，如果想继续在HBuilderX里使用，可以把工程拖到HBuilderX中。注意如果是把整个项目拖入HBuilderX，则编译时走的是项目下的编译器。如果是把src目录拖入到HBuilderX中，则走的是HBuilderX安装目录下plugin目录下的编译器。</li><li>cli版如果想安装less、scss、ts等编译器，需自己手动npm安装。在HBuilderX的插件管理界面安装无效，那个只作用于HBuilderX创建的项目。</li></ul></li><li>开发工具的区别<ul><li>cli创建的项目，内置了d.ts，同其他常规npm库一样，可在vscode、webstorm等支持d.ts的开发工具里正常开发并有语法提示。</li><li>使用HBuilderX创建的项目不带d.ts，HBuilderX内置了uni-app语法提示库。如需把HBuilderX创建的项目在其他编辑器打开并且补充d.ts，可以在项目下先执行 npm init，然后npm i @types/uni-app -D，来补充d.ts。</li><li>但vscode等其他开发工具，在vue或uni-app领域，开发效率比不过HBuilderX。详见：<a href="https://ask.dcloud.net.cn/article/35451">https://ask.dcloud.net.cn/article/35451</a></li><li>发布App时，仍然需要使用HBuilderX。其他开发工具无法发布App，但可以发布H5、各种小程序。如需开发App，可以先在HBuilderX里运行起来，然后在其他编辑器里修改保存代码，代码修改后会自动同步到手机基座。</li><li>如果使用cli创建项目，那下载HBuilderX时只需下载10M的标准版即可。因为编译器已经安装到项目下了。</li></ul></li></ul></li></ul><h2 id="2-使用图形化界面"><a href="#2-使用图形化界面" class="headerlink" title="2.使用图形化界面"></a>2.使用图形化界面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。</p><p>如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统</p><h3 id="1-模块的演进"><a href="#1-模块的演进" class="headerlink" title="1.模块的演进"></a>1.模块的演进</h3><p><strong>用于在模块化中定义规范</strong></p><h4 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a><strong>script标签</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;module1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 <code>window</code> 对象中</p><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong>CommonJS</strong></h4><p>是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。</p><p>核心思想<br>允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p><p><strong>优点：</strong>服务器端模块重用，NPM中模块包多，有将近20万个。</p><p><strong>缺点：</strong>加载模块是同步的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p><p><strong>实现</strong>：</p><ul><li>服务器端的 <a href="http://www.nodejs.org/">Node.js</a></li><li><a href="http://browserify.org/">Browserify</a>，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大</li><li><a href="https://github.com/medikoo/modules-webmake">modules-webmake</a>，类似Browserify，还不如 Browserify 灵活</li><li><a href="https://github.com/substack/wreq">wreq</a>，Browserify 的前身</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h4><p>鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。</p><p><strong>其核心接口是</strong>：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块提前执行，依赖前置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;module&quot;</span>, [<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module&quot;</span>, <span class="string">&quot;../file&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>在浏览器环境中异步加载模块；并行加载多个模块；</p><p><strong>缺点：</strong>开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h4><p>Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ = require(&#x27;jquery&#x27;);</span><br><span class="line">  var Spinning = require(&#x27;./spinning&#x27;);</span><br><span class="line">  exports.doSomething = ...</span><br><span class="line">  module.exports = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>依赖就近，延迟执行（对于依赖的模块延迟执行） 可以很容易在 Node.js 中运行；<br><strong>缺点：</strong>依赖 SPM 打包，模块的加载逻辑偏重；<br><strong>实现：Sea.js</strong> ；coolie</p><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><strong>ES6</strong></h4><p>ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。<a href="http://es6.ruanyifeng.com/#docs/module">ES6 模块</a>的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span> <span class="string">&quot;localModule&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>容易进行静态分析</li><li>面向未来的 ECMAScript 标准</li></ul><p>缺点：</p><ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令字，新版的 Node.js才支持</li></ul><p>实现：</p><ul><li><a href="https://babeljs.io/">Babel</a></li></ul><h3 id="2-前端模块加载原理"><a href="#2-前端模块加载原理" class="headerlink" title="2.前端模块加载原理"></a>2.前端模块加载原理</h3><p>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案</p><p><strong>分块传输</strong>，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有资源都是模块</span><br><span class="line">在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。</span><br><span class="line"></span><br><span class="line">解决:</span><br><span class="line">在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用 LESS 加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。</span><br></pre></td></tr></table></figure><h3 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3.Webpack"></a>3.Webpack</h3><p>Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p><img src="https://zhaoda.net/webpack-handbook/images/what-is-webpack.png" alt="什么是webpack"></p><h1 id="uniapp手册"><a href="#uniapp手册" class="headerlink" title="uniapp手册"></a>uniapp手册</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>一个uni-app工程，默认包含如下目录及文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─cloudfunctions        云函数目录（阿里云为aliyun，腾讯云为tcb，详见uniCloud）</span><br><span class="line">│─components            符合vue组件规范的uni-app组件目录</span><br><span class="line">│  └─comp-a.vue         可复用的a组件</span><br><span class="line">├─hybrid                存放本地网页的目录，详见</span><br><span class="line">├─platforms             存放各平台专用页面的目录，详见</span><br><span class="line">├─pages                 业务页面文件存放的目录</span><br><span class="line">│  ├─index</span><br><span class="line">│  │  └─index.vue       index页面</span><br><span class="line">│  └─list</span><br><span class="line">│     └─list.vue        list页面</span><br><span class="line">├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此</span><br><span class="line">├─wxcomponents          存放小程序组件的目录，详见</span><br><span class="line">├─main.js               Vue初始化入口文件</span><br><span class="line">├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期</span><br><span class="line">├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见</span><br><span class="line">└─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见</span><br></pre></td></tr></table></figure><h2 id="资源路径说明"><a href="#资源路径说明" class="headerlink" title="资源路径说明"></a>资源路径说明</h2><ul><li><p>编译到任意平台时，<code>static</code> 目录下的文件均会被打包进去，非 <code>static</code> 目录下的文件（vue、js、css 等）被引用到才会被包含进去。</p></li><li><p><code>static</code> 目录下的 <code>js</code> 文件不会被编译，如果里面有 <code>es6</code> 的代码，不经过转换直接运行，在手机设备上会报错。</p></li><li><p><code>css</code>、<code>less/scss</code> 等资源同样不要放在 <code>static</code> 目录下，建议这些公用的资源放在 <code>common</code> 目录下。</p></li><li><p>```</p><!-- 绝对路径，/static指根目录下的static目录，在cli项目中/static指src目录下的static目录 --><p><image class="logo" src="/static/logo.png"></image><br><image class="logo" src="@/static/logo.png"></image></p><!-- 相对路径 --><p><image class="logo" src="../../static/logo.png"></image></p><p>// 绝对路径，@指向项目根目录，在cli项目中@指向src目录<br>import add from ‘@/common/add.js’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 本地背景图片/字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。</span><br><span class="line"></span><br><span class="line">## 页面样式与布局</span><br><span class="line"></span><br><span class="line">`uni-app` 支持的通用 css 单位包括 px、rpx</span><br><span class="line"></span><br><span class="line">- px 即屏幕像素</span><br><span class="line"></span><br><span class="line">- rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大，但在 App 端和 H5 端屏幕宽度达到 960px 时，默认将按照 375px 的屏幕宽度进行计算，</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>{<br>  “globalStyle”: {</p><pre><code>&quot;rpxCalcMaxDeviceWidth&quot;: 960, // rpx 计算所支持的最大设备宽度，单位 px，默认值为 960&quot;rpxCalcBaseDeviceWidth&quot;: 375, // rpx 计算使用的基准设备宽度，设备实际宽度超出 rpx 计算所支持的最大设备宽度时将按基准宽度计算，单位 px，默认值为 375&quot;rpxCalcIncludeWidth&quot;: 750 // rpx 计算特殊处理的值，始终按实际的设备宽度计算，单位 rpx，默认值为 750</code></pre><p>  },<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - match-media组件  为组件指定一组 media query 媒体查询规则</span><br><span class="line"></span><br><span class="line">vue页面支持下面这些普通H5单位，但在nvue里不支持：</span><br><span class="line"></span><br><span class="line">- rem 根字体大小可以通过 [page-meta](https://uniapp.dcloud.io/component/page-meta?id=page-meta) 配置</span><br><span class="line">- vh viewpoint height，视窗高度，1vh等于视窗高度的1%</span><br><span class="line">- vw viewpoint width，视窗宽度，1vw等于视窗宽度的1%</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 750，结果为：100rpx。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**tip:**</span><br><span class="line"></span><br><span class="line">- rpx不支持动态横竖屏切换计算，使用rpx建议锁定屏幕方向</span><br><span class="line"></span><br><span class="line">## 生命周期</span><br><span class="line"></span><br><span class="line">https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e5%ba%94%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f</span><br><span class="line"></span><br><span class="line">- `uni-app` 支持如下**应用生命周期**函数：</span><br><span class="line"></span><br><span class="line">  | 函数名               | 说明                                                         |</span><br><span class="line">  | :------------------- | :----------------------------------------------------------- |</span><br><span class="line">  | onLaunch             | 当`uni-app` 初始化完成时触发（全局只触发一次）               |</span><br><span class="line">  | onShow               | 当 `uni-app` 启动，或从后台进入前台显示                      |</span><br><span class="line">  | onHide               | 当 `uni-app` 从前台进入后台                                  |</span><br><span class="line">  | onError              | 当 `uni-app` 报错时触发                                      |</span><br><span class="line">  | onUniNViewMessage    | 对 `nvue` 页面发送的数据进行监听，可参考 [nvue 向 vue 通讯](https://uniapp.dcloud.io/use-weex?id=nvue-向-vue-通讯) |</span><br><span class="line">  | onUnhandledRejection | 对未处理的 Promise 拒绝事件监听函数（2.8.1+）                |</span><br><span class="line">  | onPageNotFound       | 页面不存在监听函数                                           |</span><br><span class="line">  | onThemeChange        | 监听系统主题变化                                             |</span><br><span class="line"></span><br><span class="line">  **注意**</span><br><span class="line"></span><br><span class="line">  - 应用生命周期仅可在`App.vue`中监听，在其它页面监听无效。</span><br><span class="line">  - onlaunch里进行页面跳转，如遇白屏报错，请参考https://ask.dcloud.net.cn/article/35942</span><br><span class="line"></span><br><span class="line">- **页面生命周期**</span><br><span class="line"></span><br><span class="line">  | onInit                              | 监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad | 百度小程序                                                   | 3.1.0+ |</span><br><span class="line">  | ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |</span><br><span class="line">  | onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考[示例](https://uniapp.dcloud.io/api/router?id=navigateto) |                                                              |        |</span><br><span class="line">  | onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                              |        |</span><br><span class="line">  | onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                              |        |</span><br><span class="line">  | onHide                              | 监听页面隐藏                                                 |                                                              |        |</span><br><span class="line">  | onUnload                            | 监听页面卸载                                                 |                                                              |        |</span><br><span class="line">  | onResize                            | 监听窗口尺寸变化                                             | App、微信小程序                                              |        |</span><br><span class="line">  | onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，参考[示例](https://uniapp.dcloud.io/api/ui/pulldown) |                                                              |        |</span><br><span class="line">  | onReachBottom                       | 可在pages.json里定义具体页面底部的触发距离[onReachBottomDistance](https://uniapp.dcloud.io/collocation/pages)，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。 |                                                              |        |</span><br><span class="line">  | onTabItemTap                        | 点击 tab 时触发，参数为Object，具体见下方注意事项            | 微信小程序、支付宝小程序、百度小程序、H5、App（自定义组件模式） |        |</span><br><span class="line">  | onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、百度小程序、字节跳动小程序、支付宝小程序         |        |</span><br><span class="line">  | onPageScroll                        | 监听页面滚动，参数为Object                                   | nvue暂不支持                                                 |        |</span><br><span class="line">  | onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     | App、H5                                                      |        |</span><br><span class="line">  | onBackPress                         | 监听页面返回，返回 event = &#123;from:backbutton、 navigateBack&#125; ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解](http://ask.dcloud.net.cn/article/35120)。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。 | app、H5、支付宝小程序                                        |        |</span><br><span class="line">  | onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件                             | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onShareTimeline                     | 监听用户点击右上角转发到朋友圈                               | 微信小程序                                                   | 2.8.1+ |</span><br><span class="line">  | onAddToFavorites                    | 监听用户点击右上角收藏                                       | 微信小程序                                                   | 2.8.1+ |</span><br><span class="line"></span><br><span class="line">- **组件生命周期**</span><br><span class="line"></span><br><span class="line">  `uni-app` 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</span><br><span class="line"></span><br><span class="line">  | 函数名        | 说明                                                         | 平台差异说明 | 最低版本 |</span><br><span class="line">  | :------------ | :----------------------------------------------------------- | :----------- | :------- |</span><br><span class="line">  | beforeCreate  | 在实例初始化之后被调用。[详见](https://cn.vuejs.org/v2/api/#beforeCreate) |              |          |</span><br><span class="line">  | created       | 在实例创建完成后被立即调用。[详见](https://cn.vuejs.org/v2/api/#created) |              |          |</span><br><span class="line">  | beforeMount   | 在挂载开始之前被调用。[详见](https://cn.vuejs.org/v2/api/#beforeMount) |              |          |</span><br><span class="line">  | mounted       | 挂载到实例上去之后调用。[详见](https://cn.vuejs.org/v2/api/#mounted) 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用`$nextTick`[Vue官方文档](https://cn.vuejs.org/v2/api/#Vue-nextTick) |              |          |</span><br><span class="line">  | beforeUpdate  | 数据更新时调用，发生在虚拟 DOM 打补丁之前。[详见](https://cn.vuejs.org/v2/api/#beforeUpdate) | 仅H5平台支持 |          |</span><br><span class="line">  | updated       | 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。[详见](https://cn.vuejs.org/v2/api/#updated) | 仅H5平台支持 |          |</span><br><span class="line">  | beforeDestroy | 实例销毁之前调用。在这一步，实例仍然完全可用。[详见](https://cn.vuejs.org/v2/api/#beforeDestroy) |              |          |</span><br><span class="line">  | destroyed     | Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。[详见](https://cn.vuejs.org/v2/api/#destroyed) |              |          |</span><br><span class="line"></span><br><span class="line">## 路由</span><br><span class="line"></span><br><span class="line">### API</span><br><span class="line"></span><br><span class="line">框架以栈的形式管理当前所有页面， 当发生路由切换的时候，页面栈的表现如下：</span><br><span class="line"></span><br><span class="line">| 路由方式   | 页面栈表现                        | 触发时机                                                     |</span><br><span class="line">| ---------- | --------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">| 初始化     | 新页面入栈                        | uni-app 打开的第一个页面                                     |</span><br><span class="line">| 打开新页面 | 新页面入栈                        | 调用 API  [uni.navigateTo](https://uniapp.dcloud.io/api/router?id=navigateto) 、使用组件  [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line">| 页面重定向 | 当前页面出栈，新页面入栈          | 调用 API  [uni.redirectTo](https://uniapp.dcloud.io/api/router?id=redirectto) 、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line">| 页面返回   | 页面不断出栈，直到目标返回页      | 调用 API  [uni.navigateBack](https://uniapp.dcloud.io/api/router?id=navigateback)  、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) 、用户按左上角返回按钮、安卓用户点击物理back按键 |</span><br><span class="line">| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 | 调用 API  [uni.switchTab](https://uniapp.dcloud.io/api/router?id=switchtab) 、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) 、用户切换 Tab |</span><br><span class="line">| 重加载     | 页面全部出栈，只留下新的页面      | 调用 API  [uni.reLaunch](https://uniapp.dcloud.io/api/router?id=relaunch) 、使用组件  [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line"></span><br><span class="line">### 传参</span><br><span class="line"></span><br><span class="line">#### navigateBack</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//page-A<br>let pages = getCurrentPages();<br>let currPage = pages[pages.length - 1]; // 当前页的实例<br>this.cityCul = currPage.$vm.cityCul</p></li></ul><p>//page-B<br>let pages = getCurrentPages()<br>let nowPage = pages[pages.length - 1]; //当前页页面实例<br>let prevPage = pages[pages.length - 2]; //上一页页面实例<br>prevPage.$vm.cityCul = this.CityCul<br>uni.navigateBack({<br>        url: “../index/index?city=” + this.CityCul</p><p>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Tips:</span><br><span class="line"></span><br><span class="line">- **目前页面路径最多只能十层。**</span><br><span class="line"></span><br><span class="line">## 运行环境判断</span><br><span class="line"></span><br><span class="line">[开发环境和生产环境](https://uniapp.dcloud.io/frame?id=开发环境和生产环境)</span><br><span class="line"></span><br><span class="line">`uni-app` 可通过 `process.env.NODE_ENV` 判断当前环境是开发环境还是生产环境。一般用于连接测试服务器或生产服务器的动态切换。</span><br><span class="line"></span><br><span class="line">- 在HBuilderX 中，点击“运行”编译出来的代码是开发环境，点击“发行”编译出来的代码是生产环境</span><br><span class="line">- cli模式下，是通行的编译环境处理方式。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">if(process.env.NODE_ENV === &#x27;development&#x27;)&#123;</span><br><span class="line">    console.log(&#x27;开发环境&#x27;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&#x27;生产环境&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://uniapp.dcloud.io/frame?id=%E5%88%A4%E6%96%AD%E5%B9%B3%E5%8F%B0">判断平台</a></strong></p><p>平台判断有2种场景，一种是在编译期判断，一种是在运行期判断。</p><ul><li>编译期判断 编译期判断，即条件编译，不同平台在编译出包后已经是不同的代码。详见：<a href="https://uniapp.dcloud.io/platform">条件编译</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef H5</span></span><br><span class="line">    alert(<span class="string">&quot;只有h5平台才有alert方法&quot;</span>)</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure><ul><li><p>运行期判断 运行期判断是指代码已经打入包中，仍然需要在运行期判断平台，此时可使用 <code>uni.getSystemInfoSync().platform</code> 判断客户端环境是 Android、iOS 还是小程序开发工具（在百度小程序开发工具、微信小程序开发工具、支付宝小程序开发工具中使用 <code>uni.getSystemInfoSync().platform</code> 返回值均为 devtools）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(uni.getSystemInfoSync().platform)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;android&#x27;</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行Android上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ios&#x27;</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行iOS上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行在开发者工具上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="页面样式与尺寸"><a href="#页面样式与尺寸" class="headerlink" title="页面样式与尺寸"></a>页面样式与尺寸</h2><p><a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">尺寸单位</a></p><p><code>uni-app</code> 支持的通用 css 单位包括 px、rpx</p><ul><li><p>px 即屏幕像素</p></li><li><p>rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。</p><p>rpx 是相对于基准宽度的单位，可以根据屏幕宽度进行自适应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开发者可以通过设计稿基准宽度计算页面元素 rpx 值，设计稿 1px 与框架样式 1rpx 转换公式如下：</span><br><span class="line">设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx</span><br><span class="line">750 * 元素在设计稿中的宽度 / 设计稿基准宽度</span><br><span class="line"></span><br><span class="line">举例说明：</span><br><span class="line">若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 750，结果为：100rpx。</span><br><span class="line">若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 640，结果为：117rpx。</span><br></pre></td></tr></table></figure></li><li><h3 id="固定值"><a href="#固定值" class="headerlink" title="固定值"></a>固定值</h3></li></ul><p><code>uni-app</code> 中以下组件的高度是固定的，不可修改：</p><table><thead><tr><th align="left">组件</th><th align="left">描述</th><th align="left">App</th><th align="left">H5</th></tr></thead><tbody><tr><td align="left">NavigationBar</td><td align="left">导航栏</td><td align="left">44px</td><td align="left">44px</td></tr><tr><td align="left">TabBar</td><td align="left">底部选项卡</td><td align="left">HBuilderX 2.3.4之前为56px，2.3.4起和H5调为一致，统一为 50px。但可以自主更改高度）</td><td align="left"></td></tr></tbody></table><h2 id="renderjs"><a href="#renderjs" class="headerlink" title="renderjs"></a>renderjs</h2><p><code>renderjs</code>是一个运行在视图层的js。它比<a href="https://uniapp.dcloud.io/?id=wxs">WXS</a>更加强大。它只支持app-vue和h5。</p><p><code>renderjs</code>的主要作用有2个：</p><ul><li>大幅降低逻辑层和视图层的通讯损耗，提供高性能视图交互能力</li><li>在视图层操作dom，运行for web的js库</li></ul><p><strong>使用方式</strong></p><p>设置 script 节点的 lang 为 renderjs</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">module</span>=<span class="string">&quot;test&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;renderjs&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用vue注意事项"><a href="#使用vue注意事项" class="headerlink" title="使用vue注意事项"></a>使用vue注意事项</h2><h3 id="uniapp中nvue与vue的区别"><a href="#uniapp中nvue与vue的区别" class="headerlink" title="uniapp中nvue与vue的区别"></a>uniapp中nvue与vue的区别</h3><p>uni-app是逻辑和渲染分离的，渲染层在<strong>app端</strong>提供了两套排版引擎。<br>小程序方式的webview渲染，和weex方式的原生渲染，两种渲染引擎可以自己根据需要选。<br> <strong>vue文件走的webview渲染</strong><br> <strong>nvue走weex方式的原生渲染</strong></p><p>组件和js写法是一样的，css不一样，原生排版的能用的css必须是flex布局</p><p>虽然nvue也可以多端编译，输出H5和小程序，但nvue的css写法受限，所以如果你不开发App，那么不需要使用nvue。</p><p>一个<strong>App</strong>中可以同时使用两种页面，比如首页使用nvue，二级页使用vue页面，hello uni-app示例就是如此。</p><h3 id="nvue适用场景"><a href="#nvue适用场景" class="headerlink" title="nvue适用场景"></a>nvue适用场景</h3><p>在App端某些vue页面表现不佳的场景下使用 nvue 作为强化补充。这些场景如下：</p><ol><li>需要高性能的区域长列表或瀑布流滚动。webview的页面级长列表滚动时没有性能问题的（就是滚动条覆盖webview整体高度），但页面中某个区域做长列表滚动，则需要使用nvue的<code>list</code>、<code>recycle-list</code>、<code>waterfall</code>等组件(<a href="https://uniapp.dcloud.io/component/list">详见</a>)。这些组件的性能要高于vue页面里的区域滚动组件<code>scroll-view</code>。</li><li>复杂高性能的自定义下拉刷新。uni-app的pages.json里可以配置原生下拉刷新，但引擎内置的下拉刷新样式只有雪花和circle圈2种样式。如果你需要自己做复杂的下拉刷新，推荐使用nvue的refresh组件。当然<a href="https://ext.dcloud.net.cn/search?q=%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">插件市场</a>里也有很多vue下的自定义下拉刷新插件，只要是基于renderjs或wxs的，性能也可以商用，只是没有nvue的<code>refresh</code>组件更极致。</li><li>左右拖动的长列表。在webview里，通过<code>swiper</code>+<code>scroll-view</code>实现左右拖动的长列表，前端模拟下拉刷新，这套方案的性能不好。此时推荐使用nvue，比如新建uni-app项目时的<a href="https://ext.dcloud.net.cn/plugin?id=103">新闻示例模板</a>，就采用了nvue，切换很流畅。</li><li>实现区域滚动长列表+左右拖动列表+吸顶的复杂排版效果，效果可参考hello uni-app模板里的<code>swiper-list</code>。<a href="https://ext.dcloud.net.cn/plugin?id=2128">详见</a></li><li>如需要将软键盘右下角按钮文字改为“发送”，则需要使用nvue。比如聊天场景，除了软键盘右下角的按钮文字处理外，还涉及聊天记录区域长列表滚动，适合nvue来做。</li><li>解决前端控件无法覆盖原生控件的层级问题。当你使用<code>map</code>、<code>video</code>、<code>live-pusher</code>等原生组件时，会发现前端写的<code>view</code>等组件无法覆盖原生组件，层级问题处理比较麻烦，此时使用nvue更好。或者在vue页面上也可以覆盖一个subnvue（一种非全屏的nvue页面覆盖在webview上），以解决App上的原生控件层级问题。<a href="https://uniapp.dcloud.io/component/native-component">详见</a></li><li>如深度使用<code>map</code>组件，建议使用nvue。除了层级问题，App端nvue文件的map功能更完善，和小程序拉齐度更高，多端一致性更好。</li><li>如深度使用<code>video</code>，建议使用nvue。比如如下2个场景：video内嵌到swiper中，以实现抖音式视频滑动切换，例子见<a href="https://ext.dcloud.net.cn/search?q=%E4%BB%BF%E6%8A%96%E9%9F%B3">插件市场</a>；nvue的视频全屏后，通过<code>cover-view</code>实现内容覆盖，比如增加文字标题、分享按钮。</li><li>直播推流：nvue下有<code>live-pusher</code>组件，和小程序对齐，功能更完善，也没有层级问题。</li><li>对App启动速度要求极致化。App端v3编译器模式下，如果首页使用nvue且在manifest里配置fast模式，那么App的启动速度可以控制在1秒左右。而使用vue页面的话，App的启动速度一般是3秒起，取决于你的代码性能和体积。</li></ol><h3 id="nvue开发与vue开发的常见区别"><a href="#nvue开发与vue开发的常见区别" class="headerlink" title="nvue开发与vue开发的常见区别"></a><a href="https://uniapp.dcloud.io/use-weex?id=nvue%E5%BC%80%E5%8F%91%E4%B8%8Evue%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8C%BA%E5%88%AB">nvue开发与vue开发的常见区别</a></h3><p>基于原生引擎的渲染，虽然还是前端技术栈，但和web开发肯定是有区别的。</p><ol><li>nvue 页面控制显隐只可以使用<code>v-if</code>不可以使用<code>v-show</code></li><li>nvue 页面只能使用<code>flex</code>布局，不支持其他布局方式。页面开发前，首先想清楚这个页面的纵向内容有什么，哪些是要滚动的，然后每个纵向内容的横轴排布有什么，按 flex 布局设计好界面。</li><li>nvue 页面的布局排列方向默认为竖排（<code>column</code>），如需改变布局方向，可以在 <code>manifest.json</code> -&gt; <code>app-plus</code> -&gt; <code>nvue</code> -&gt; <code>flex-direction</code> 节点下修改，仅在 uni-app 模式下生效。<a href="https://uniapp.dcloud.io/collocation/manifest?id=nvue">详情</a>。</li><li>nvue页面编译为H5、小程序时，会做一件css默认值对齐的工作。因为weex渲染引擎只支持flex，并且默认flex方向是垂直。而H5和小程序端，使用web渲染，默认不是flex，并且设置<code>display:flex</code>后，它的flex方向默认是水平而不是垂直的。所以nvue编译为H5、小程序时，会自动把页面默认布局设为flex、方向为垂直。当然开发者手动设置后会覆盖默认设置。</li><li>文字内容，必须、只能在<code>&lt;text&gt;</code>组件下。不能在<code>&lt;div&gt;</code>、<code>&lt;view&gt;</code>的<code>text</code>区域里直接写文字。否则即使渲染了，也无法绑定js里的变量。</li><li>只有<code>text</code>标签可以设置字体大小，字体颜色。</li><li>布局不能使用百分比、没有媒体查询。</li><li>nvue 切换横竖屏时可能导致样式出现问题，建议有 nvue 的页面锁定手机方向。</li><li>支持的css有限，不过并不影响布局出你需要的界面，<code>flex</code>还是非常强大的。详见</li><li>不支持背景图。但可以使用<code>image</code>组件和层级来实现类似web中的背景效果。因为原生开发本身也没有web这种背景图概念</li><li>css选择器支持的比较少，只能使用 class 选择器。<a href="https://uniapp.dcloud.io/use-weex?id=%E6%A0%B7%E5%BC%8F">详见</a></li><li>nvue 的各组件在安卓端默认是透明的，如果不设置<code>background-color</code>，可能会导致出现重影的问题。</li><li><code>class</code> 进行绑定时只支持数组语法。</li><li>Android端在一个页面内使用大量圆角边框会造成性能问题，尤其是多个角的样式还不一样的话更耗费性能。应避免这类使用。</li><li>nvue页面没有<code>bounce</code>回弹效果，只有几个列表组件有<code>bounce</code>效果，包括 <code>list</code>、<code>recycle-list</code>、<code>waterfall</code>。</li><li>原生开发没有页面滚动的概念，页面内容高过屏幕高度并不会自动滚动，只有部分组件可滚动（<code>list</code>、<code>waterfall</code>、<code>scroll-view/scroller</code>），要滚得内容需要套在可滚动组件下。这不符合前端开发的习惯，所以在 nvue 编译为 uni-app模式时，给页面外层自动套了一个 <code>scroller</code>，页面内容过高会自动滚动。（组件不会套，页面有<code>recycle-list</code>时也不会套）。后续会提供配置，可以设置不自动套。</li><li>在 App.vue 中定义的全局js变量不会在 nvue 页面生效。<code>globalData</code>和<code>vuex</code>是生效的。</li><li>App.vue 中定义的全局css，对nvue和vue页面同时生效。如果全局css中有些css在nvue下不支持，编译时控制台会报警，建议把这些不支持的css包裹在<a href="https://uniapp.dcloud.io/platform">条件编译</a>里，<code>APP-PLUS-NVUE</code></li><li>不能在 <code>style</code> 中引入字体文件，nvue 中字体图标的使用参考：<a href="https://uniapp.dcloud.io/use-weex?id=addrule">加载自定义字体</a>。如果是本地字体，可以用<code>plus.io</code>的API转换路径。</li><li>目前不支持在 nvue 页面使用 <code>typescript/ts</code>。</li><li>nvue 页面关闭原生导航栏时，想要模拟状态栏，可以<a href="https://ask.dcloud.net.cn/article/35111">参考文章</a>。但是，仍然强烈建议在nvue页面使用原生导航栏。nvue的渲染速度再快，也没有原生导航栏快。原生排版引擎解析<code>json</code>绘制原生导航栏耗时很少，而解析nvue的js绘制整个页面的耗时要大的多，尤其在新页面进入动画期间，对于复杂页面，没有原生导航栏会在动画期间产生整个屏幕的白屏或闪屏。</li></ol><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li><p><code>uni-app</code> 完整支持 <code>Vue</code> 实例的生命周期，同时还新增 <a href="https://uniapp.dcloud.io/frame?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">应用生命周期</a> 及 <a href="https://uniapp.dcloud.io/frame?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">页面生命周期</a>。</p></li><li><p><code>uni-app</code> 完整支持 <code>Vue</code> 模板语法</p></li><li><p><code>data</code> 必须声明为返回一个初始数据对象的函数（注意函数内返回的数据对象不要直接引用函数外的对象）；否则页面关闭时，数据不会自动销毁，再次打开该页面时，会显示上次数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &#x27;Hello&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p><p><strong>写法：</strong>以 #ifdef 或 #ifndef 加 <strong>%PLATFORM%</strong> 开头，以 #endif 结尾。</p><ul><li>#ifdef：if defined 仅在某平台存在</li><li>#ifndef：if not defined 除了某平台均存在</li><li>**%PLATFORM%**：平台名称</li></ul><table><thead><tr><th>#ifdef <strong>APP-PLUS</strong> 需条件编译的代码 #endif</th><th>仅出现在 App 平台下的代码</th></tr></thead><tbody><tr><td>#ifndef <strong>H5</strong> 需条件编译的代码 #endif</td><td>除了 H5 平台，其它平台均存在的代码</td></tr><tr><td>#ifdef <strong>H5</strong> || <strong>MP-WEIXIN</strong> 需条件编译的代码 #endif</td><td>在 H5 平台或微信小程序平台存在的代码（这里只有||，不可能出现&amp;&amp;，因为没有交集）</td></tr></tbody></table><p><strong>%PLATFORM%</strong> <strong>可取值如下：</strong></p><table><thead><tr><th align="left">值</th><th align="left">平台</th></tr></thead><tbody><tr><td align="left">APP-PLUS</td><td align="left">App</td></tr><tr><td align="left">APP-PLUS-NVUE</td><td align="left">App nvue</td></tr><tr><td align="left">H5</td><td align="left">H5</td></tr><tr><td align="left">MP-WEIXIN</td><td align="left">微信小程序</td></tr><tr><td align="left">MP-ALIPAY</td><td align="left">支付宝小程序</td></tr><tr><td align="left">MP-BAIDU</td><td align="left">百度小程序</td></tr><tr><td align="left">MP-TOUTIAO</td><td align="left">字节跳动小程序</td></tr></tbody></table><h3 id="pages-json-的条件编译"><a href="#pages-json-的条件编译" class="headerlink" title="pages.json 的条件编译"></a>pages.json 的条件编译</h3><p>下面的页面，只有运行至 App 时才会编译进去。</p><p><img src="https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/img/platform-4.png" alt="img"></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="页面实例"><a href="#页面实例" class="headerlink" title="页面实例"></a>页面实例</h2><h3 id="getApp"><a href="#getApp" class="headerlink" title="getApp"></a>getApp</h3><p><code>getApp()</code> 函数用于获取当前应用实例，一般用于获取globalData 。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"><span class="built_in">console</span>.log(app.globalData)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>不要在定义于 <code>App()</code> 内的函数中，或调用 <code>App</code> 前调用 <code>getApp()</code> ，可以通过 <code>this.$scope</code> 获取对应的app实例</li><li>通过 <code>getApp()</code> 获取实例之后，不要私自调用生命周期函数。</li><li>v3模式加速了首页<code>nvue</code>的启动速度，当在首页<code>nvue</code>中使用<code>getApp()</code>不一定可以获取真正的<code>App</code>对象。对此v3版本提供了<code>const app = getApp(&#123;allowDefault: true&#125;)</code>用来获取原始的<code>App</code>对象，可以用来在首页对<code>globalData</code>等初始化</li></ul><h3 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a><a href="https://uniapp.dcloud.io/collocation/frame/window?id=getcurrentpages">getCurrentPages()</a></h3><p><code>getCurrentPages()</code> 函数用于获取当前<strong>页面栈的实例</strong>，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。</p><p><strong>注意：</strong> <code>getCurrentPages()</code>仅用于展示页面栈的情况，请勿修改页面栈，以免造成页面状态错误。</p><p>每个页面实例的方法属性列表：</p><table><thead><tr><th>方法</th><th>描述</th><th>平台说明</th></tr></thead><tbody><tr><td>page.$getAppWebview()</td><td>获取当前页面的webview对象实例</td><td>App</td></tr><tr><td>page.route</td><td>获取当前页面的路由</td><td></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pages = getCurrentPages()</span><br><span class="line"><span class="keyword">let</span> nowPage = pages[pages.length - <span class="number">1</span>]; <span class="comment">//当前页页面实例</span></span><br><span class="line"><span class="keyword">let</span> prevPage = pages[pages.length - <span class="number">2</span>]; <span class="comment">//上一页页面实例</span></span><br><span class="line"><span class="built_in">console</span>.log(prevPage)</span><br><span class="line">prevPage.$vm.cityCul = <span class="built_in">this</span>.CityCul <span class="comment">//给上一个页面实例添加一个data</span></span><br></pre></td></tr></table></figure><p>Tips：</p><ul><li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li><li><code>switchTab</code> 只能打开 <code>tabBar</code> 页面。</li><li><code>reLaunch</code> 可以打开任意页面。</li><li>页面底部的 <code>tabBar</code> 由页面决定，即只要是定义为 <code>tabBar</code> 的页面，底部都有 <code>tabBar</code>。</li><li>不能在 <code>App.vue</code> 里面进行页面跳转。</li></ul><h3 id="getAppWebview"><a href="#getAppWebview" class="headerlink" title="$getAppWebview()"></a><a href="https://uniapp.dcloud.io/collocation/frame/window?id=getappwebview">$getAppWebview()</a></h3><p><code>uni-app</code> 在 <code>getCurrentPages()</code>获得的页面里内置了一个方法 <code>$getAppWebview()</code> 可以得到当前webview的对象实例，从而实现对 webview 更强大的控制。在 html5Plus 中，plus.webview具有强大的控制能力，可参考：<a href="http://www.html5plus.org/doc/zh_cn/webview.html#plus.webview.WebviewObject">WebviewObject</a>。</p><p>但<code>uni-app</code>框架有自己的窗口管理机制，请不要自己创建和销毁webview，如有需求覆盖子窗体上去，请使用<a href="https://uniapp.dcloud.io/api/window/subNVues">原生子窗体subNvue</a>。</p><p><strong>注意：此方法仅 App 支持</strong></p><p><strong>示例：</strong></p><p>获取当前页面 webview 的对象实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// #ifdef APP-PLUS</span></span><br><span class="line">    <span class="keyword">const</span> currentWebview = <span class="built_in">this</span>.$scope.$getAppWebview(); <span class="comment">//此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效，非v3编译模式使用this.$mp.page.$getAppWebview()</span></span><br><span class="line">    currentWebview.setBounce(&#123;<span class="attr">position</span>:&#123;<span class="attr">top</span>:<span class="string">&#x27;100px&#x27;</span>&#125;,<span class="attr">changeoffset</span>:&#123;<span class="attr">top</span>:<span class="string">&#x27;0px&#x27;</span>&#125;&#125;); <span class="comment">//动态重设bounce效果</span></span><br><span class="line">    <span class="comment">// #endif</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取指定页面 webview 的对象实例</p><p><code>getCurrentPages()</code>可以得到所有页面对象，然后根据数组，可以取指定的页面webview对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = getCurrentPages();</span><br><span class="line"><span class="keyword">var</span> page = pages[pages.length - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// #ifdef APP-PLUS</span></span><br><span class="line"><span class="keyword">var</span> currentWebview = page.$getAppWebview();</span><br><span class="line"><span class="built_in">console</span>.log(currentWebview.id);<span class="comment">//获得当前webview的id</span></span><br><span class="line"><span class="built_in">console</span>.log(currentWebview.isVisible());<span class="comment">//查询当前webview是否可见</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>1、@touchstart ：触摸开始；<br>2、@touchmove：手指滑动的过程；<br>3、@touchend：触摸结束，手指离开屏幕。</p><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><p>mysql -uroot -h 127.0.0.1 -p</p><p>use ebook;</p><p>show tables;</p><p>mysql&gt; create table login(<br>    -&gt; username char(9),<br>    -&gt; password char(12)<br>    -&gt; )charset utf8;</p><p>show tables;</p><p>desc login;</p><p>insert into login values(‘liming’,’123456’);</p><p> select * from login where username = ‘liming’;</p>]]></content>
      
      
      <categories>
          
          <category> uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2020/09/25/vue/"/>
      <url>/2020/09/25/vue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h2><p>基本使用流程:</p><ol><li>npm install -g @vue/cli    </li><li>生成项目模板，可以自定义<br>vue create 本地文件夹名称</li><li>进入到生成目录里面<br>cd xxx<br>npm install</li><li>npm run dev</li></ol><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><p><img src="https://images2018.cnblogs.com/blog/1389839/201805/1389839-20180502113321132-349982802.png" alt="img"></p><ul><li>build：构建脚本目录</li></ul><p>　　　　1）build.js  ==&gt; 生产环境构建脚本；</p><p>　　　　2）check-versions.js  ==&gt; 检查npm，node.js版本；</p><p>　　　　3）utils.js  ==&gt; 构建相关工具方法；</p><p>　　　　4）vue-loader.conf.js  ==&gt; 配置了css加载器以及编译css之后自动添加前缀；</p><p>　　　　5）webpack.base.conf.js  ==&gt; webpack基本配置；</p><p>　　　　6）webpack.dev.conf.js  ==&gt; webpack开发环境配置；</p><p>　　　　7）webpack.prod.conf.js  ==&gt; webpack生产环境配置；</p><ul><li>config：项目配置</li></ul><p>　　　　1）dev.env.js  ==&gt; 开发环境变量；</p><p>　　　　2）index.js  ==&gt; 项目配置文件；</p><p>　　　　3）prod.env.js  ==&gt; 生产环境变量；</p><ul><li><p>node_modules：npm 加载的项目依赖模块</p></li><li><p>src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</p></li></ul><p>　　　　1）assets：资源目录，放置一些图片或者公共js、公共css。这里的资源会被webpack构建；</p><p>　　　　2）components：组件目录，我们写的组件就放在这个目录里面；</p><p>　　　　3）router：前端路由，我们需要配置的路由路径写在index.js里面；</p><p>　　　　4）App.vue：根组件；</p><p>　　　　5）main.js：入口js文件；</p><ul><li><p>static：静态资源目录，如图片、字体等。不会被webpack构建</p></li><li><p>index.html：首页入口文件，可以添加一些 meta 信息等</p></li><li><p>package.json：npm包配置文件，定义了项目的npm脚本，依赖包等信息``</p></li><li><p>README.md：项目的说明文档，markdown 格式</p></li><li><p>.xxxx文件：这些是一些配置文件，包括语法配置，git配置等</p></li></ul><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li><p>组件内部引入第三方的css文件只在当前组件生效的办法</p><style src="" scoped></style></li><li><p>组件内部引入第三方的js文件只在当前组件生效的办法</p><p><a href="https://www.cnblogs.com/qianxiaox/p/13826334.html">https://www.cnblogs.com/qianxiaox/p/13826334.html</a></p></li><li><p>vue样式穿透 ::v-deep   <a href="https://www.jb51.net/article/188038.htm">https://www.jb51.net/article/188038.htm</a></p><p>修改vantUI样式，直接在 <style lang="scss" scoped> …. </style> 中编写的话只会影响当前组件内的样式，但如果去掉scoped话又会影响全局样式。</p><p>如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p><style scoped> .a >>> .b { /* ... */ } </style> 上述代码将会编译成：.a[data-v-f3f3eg9] .b { /* … */ }<p>可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。</p></li><li><p>UI使用</p><p>Muse <a href="https://www.cnblogs.com/randomlee/p/10782710.html">https://www.cnblogs.com/randomlee/p/10782710.html</a></p></li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><a href="https://zhuanlan.zhihu.com/p/53217382">https://zhuanlan.zhihu.com/p/53217382</a></p><p>数据发生改变的时候，视图会重新渲染，匹配更新为最新的值</p><p><strong>Object.defineProperty</strong>可以为对象中的每一个属性，设置 get 和 set 方法</p><p>get 值是一个函数，当属性被访问时，会触发 get 函数</p><p>set 值同样是一个函数，当属性被赋值时，会触发 set 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;    </span><br><span class="line">    name:&quot;神仙朱&quot;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line">    get()&#123;        </span><br><span class="line">        console.log(&quot;get 被触发&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val)&#123;        </span><br><span class="line">        console.log(&quot;set 被触发&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我访问 obj.name 时，会打印 ‘ get 被触发 ‘</p><p>当我为 obj.name 赋值时，obj.name = 5，会打印 ‘ set 被触发 ‘</p><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            <span class="attr">el</span>:<span class="string">&#x27;#box&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123; <span class="comment">//局部组件</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>:Aaa</span><br><span class="line">&#125;，</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">data</span>:data</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​&#125;);\</span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">//设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><h2 id="标签数据"><a href="#标签数据" class="headerlink" title="标签数据"></a>标签数据</h2><ul><li><strong>绑定数据</strong></li></ul><ol><li> , msg也可以是js表达式，但只能包含**单个**表达式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个表达式会产生一个值,它可以放在任何需要一个值的地方</span><br><span class="line">语句可以理解成一个行为.循环语句和if语句就是典型的语句</span><br><span class="line">需要语句的地方,你可以使用一个表达式来代替.这样的语句称之为表达式语句</span><br></pre></td></tr></table></figure></li><li><p>v-model=”msg”建立双向绑定     </p></li><li><p>v-once指令： 执行一次性地插值，当数据改变时，插值处的内容不会更新 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>编译html元素       v-html    </li><li>v-text</li></ul><h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;&#123;&#123;url&#125;&#125;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;url&quot;  &gt;</span><br><span class="line">&lt;img v-bind:style=&quot;&#123;color:&#x27;&#x27;,fontsize:data+&#x27;px&#x27;&#125;&quot;&gt;</span><br><span class="line">//缩写</span><br><span class="line">&lt;img :src=&quot;url&quot; alt=&quot;&quot; &gt;</span><br><span class="line">//动态参数的缩写 </span><br><span class="line">// 可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 </span><br><span class="line">&lt;img v-bind:[]=&quot;url&quot;  &gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a:&#x27;red&#x27;,</span><br><span class="line">b:&#x27;blue&#x27;,</span><br><span class="line">json:&#123;</span><br><span class="line">       red:true,</span><br><span class="line">       blue:false</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;strong :class=&quot;[条件?a:b]&quot;&gt;文字。。&lt;/strong&gt;//可以用三元表达式  </span><br><span class="line">&lt;strong :class=&quot;[a,b]&quot;&gt;文字。。&lt;/strong&gt;</span><br><span class="line">&lt;strong :class=&quot;&#123;red:true,blue:false&#125;&quot;&gt;文字。。&lt;/strong&gt;</span><br><span class="line">&lt;strong :class=&quot;json&quot;&gt;文字。。&lt;/strong&gt;</span><br></pre></td></tr></table></figure><h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><ul><li><strong>watch 适用场景：一个数据影响多个数据；</strong></li><li><strong>computed适用场景：一个数据受多个数据影响；</strong></li></ul><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a><strong>计算属性computed</strong></h3><p>计算属性是为了模板中的表达式简洁，易维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;app&quot;&gt;&#123;&#123; myname.substring(0,1).toUpperCase() + myname.substring(1) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>运算过于复杂，冗长，且不好维护，因此我们对于复杂的运算应该 使用计算属性的方式去书写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; changewords &#125;&#125;</span><br><span class="line">    //通过在表达式中调用方法来达到同样的效果 //&#123;&#123; changewords() &#125;&#125;</span><br><span class="line">    //</span><br><span class="line">    不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要</span><br><span class="line">    message 还没有发生改变，多次访问 reversedMessage</span><br><span class="line">    计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  method: &#123;</span><br><span class="line">    changewords() &#123;</span><br><span class="line">      return;</span><br><span class="line">      //this.myname.substring(0, 1).toUpperCase() + this.myname.substring(1);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    changewords() &#123;</span><br><span class="line">      return 0;</span><br><span class="line">      //this.myname.substring(0, 1).toUpperCase() + this.myname.substring(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    //完整写法</span><br><span class="line">    changewords: &#123;</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return; //一定要return</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function (newVal) &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>变量不在 data中定义，而是定义在computed中</p></li><li><p>计算属性基于响应式依赖进行缓存。如其中的任意一个值未发生变化，它调用的就是上一次 计算缓存的数据，而不是从新计算。因此提高了程序的性能。而methods中每调用一次就会重新计算一次，为了进行不必要的资源消耗，选择用计算属性</p></li><li><p><strong>支持缓存</strong>，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li></ul><h3 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 <strong>watch</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    <span class="attr">question</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$watch(name,fnCb);  <span class="comment">//浅度</span></span><br><span class="line">vm.$watch(name,fnCb,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;);  <span class="comment">//深度监视 </span></span><br></pre></td></tr></table></figure><ul><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p><strong>watch支持异步</strong>；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p> 当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数</p><ul><li>immediate：组件加载立即触发回调函数执行，</li><li>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增</li></ul></li><li><p><strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</p></li></ul><h2 id="循环和判断"><a href="#循环和判断" class="headerlink" title="循环和判断"></a>循环和判断</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue1.0</span></span><br><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;value in json&quot;</span>&gt;&#123;&#123;value&#125;&#125; &lt;/li&gt;</span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(k,v) in json&quot;</span>&gt;</span>&#123;&#123;k&#125;&#125;   &#123;&#123;v&#125;&#125;  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">track-by=<span class="string">&quot;$index&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vue2.0v-for=&quot;(val,index) in array&quot;</span></span><br><span class="line"><span class="comment">//:key=&quot;index&quot;</span></span><br><span class="line"><span class="comment">//每次更改数组数据，全部的数据都会重新渲染，添加key值，从而只渲染更改的数据.这是因为每一个列表渲染的元素加上了唯一标识符，编译器通过标识符渲染指定列表，高效渲染虚拟DOM树</span></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80OTI3MDM1LTk2MGYyZDg1NmI1ZWM5YzMuanBn?x-oss-process=image/format,png" alt="img"></p><p>vue和react的虚拟DOM的Diff算法大致相同</p><img src="https://upload-images.jianshu.io/upload_images/3973616-cbe6ef9bad920f51.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp" alt="img" style="zoom:50%;" /><ul><li><p>如果dom树有三层，在没加ID的情况下。</p><p>先比较第一层。比较一次</p><p>再比较第二层。比较第一层第一个节点和第二层第一个节点，第一层第一个节点和第二层第二个节点，比较第一层第一个节点和第二层两个节点。比较了四次。</p><p>算法复杂度，2的n次方。</p></li><li><p>如果加上ID。</p><p>比较第一个节点。再比较第二个节点。再比较第三个节点。再比较第四个节点。再比较第五个节点。一直比到第n个节点。</p><p>算法复杂度为n。</p></li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="keyword">if</span> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</span><br><span class="line">&lt;h1 v-<span class="keyword">if</span>=<span class="string">&quot;awesome&quot;</span>&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">也可以用 v-<span class="keyword">else</span> 添加一个“<span class="keyword">else</span> 块”：</span><br><span class="line">&lt;h1 v-<span class="keyword">else</span>&gt;Oh no 😢&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">在 &lt;template&gt; 元素上使用 v-<span class="keyword">if</span> 条件渲染分组</span><br><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">切换按钮将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder（替换成用户已经输入的内容）。</span><br></pre></td></tr></table></figure><p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用原生的事件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//不能直接定义事件，需要从methods中引入this.handleScroll</span></span><br><span class="line">    <span class="comment">//TODO,是否是this指向的问题</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="built_in">this</span>.handleScroll, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">this</span>.boxTop = <span class="built_in">this</span>.$refs.tabList.offsetTop;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div v-show=<span class="string">&quot;a&quot;</span>&gt; </span><br><span class="line"> v-show=<span class="string">&quot;a&quot;</span><span class="comment">//a是布尔值， 切换元素的 CSS property `display`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue2.+ 中data数据对象是通过Object.defineProerty来进行数据的双向数据绑定，</span></span><br><span class="line"><span class="comment">//而数组则是监听数组的push和pop等操作数组的方法进行双向绑定的，</span></span><br><span class="line"><span class="comment">//因此当是通过下标来修改时便不能更新视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组中的值来控制展示</span></span><br><span class="line"> &lt;div v-show=<span class="string">&quot;arr[index]&quot;</span>&gt; </span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.arr,index,!<span class="built_in">this</span>.arr[index]);</span><br><span class="line"><span class="comment">//第一个参数为数组，第二个参数为数组下标，第三个参数为设置的值，</span></span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>@click.stop=”show1()”   stop防止事件冒泡  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">阻止冒泡:  </span><br><span class="line">a). ev.cancelBubble=true;</span><br><span class="line">b). @click.stop推荐</span><br><span class="line">c). event.stopPropagation();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为，提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>@keydown    $event    ev.keyCode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">常用键:</span><br><span class="line">回车</span><br><span class="line">a). @keyup.13</span><br><span class="line">b). @keyup.enter</span><br><span class="line">上、下、左、右</span><br><span class="line">@keyup/keydown.left</span><br><span class="line">@keyup/keydown.right</span><br><span class="line">@keyup/keydown.up</span><br><span class="line">@keyup/keydown.down</span><br><span class="line">自定义键盘信息:</span><br><span class="line">Vue.directive(&#x27;on&#x27;).keyCodes.ctrl=17;</span><br><span class="line">//vue2.0</span><br><span class="line">通过全局 config.keyCodes 对象自定义按键修饰符别名：</span><br><span class="line">Vue.config.keyCodes.ctrl=17;</span><br><span class="line">@keyup.ctrl=&quot;fn()&quot;</span><br></pre></td></tr></table></figure><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="number">1.</span>msg|filterA&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="string">&#x27;welcome&#x27;</span>|uppercase&#125;&#125;  </span><br><span class="line">&lt;p&gt;<span class="number">2.</span>msg|filterA&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="string">&#x27;WELCOME&#x27;</span>|lowercase|capitalize&#125;&#125;</span><br></pre></td></tr></table></figure><p> 数据配合使用过滤器:<br>        limitBy    限制几个<br>        limitBy   参数(取几个)<br>        limitBy 取几个  从哪开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filterBy过滤数据</span><br><span class="line">filterBy ‘谁’</span><br><span class="line"></span><br><span class="line">orderBy排序</span><br><span class="line">orderBy 谁 1/-1</span><br><span class="line">1  -&gt; 正序</span><br><span class="line">2  -&gt; 倒序</span><br><span class="line"></span><br><span class="line">自定义过滤器:  model -&gt;过滤 -&gt; view</span><br><span class="line">Vue.filter(name,function(msg,[a,b])&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#123;&#123;msg | name([a,b])&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><pre><code>Vue.directive(指令名称,function(参数)&#123;    this.el    -&gt; 原生DOM元素&#125;);&lt;div v-red=&quot;参数&quot;&gt;&lt;/div&gt;</code></pre><p>用户会看到花括号标记:v-cloak        防止闪烁, 比较大段落</p><p>交互：vue-resource.js</p><h2 id="单元素-组件的过渡动画"><a href="#单元素-组件的过渡动画" class="headerlink" title="单元素/组件的过渡动画"></a>单元素/组件的过渡动画</h2><p><a href="https://cn.vuejs.org/v2/guide/transitions.html">https://cn.vuejs.org/v2/guide/transitions.html</a></p><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 <code>v-if</code>)</li><li>条件展示 (使用 <code>v-show</code>)</li><li>动态组件</li><li>组件根节点</li></ul><p>在进入/离开的过渡中，会有 6 个 class 切换。</p><ol><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"></p><p><strong>实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.fade-enter-active, .fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p><a href="https://cn.vuejs.org/v2/guide/mixins.html">https://cn.vuejs.org/v2/guide/mixins.html</a></p><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><h1 id="vm实例"><a href="#vm实例" class="headerlink" title="vm实例"></a>vm实例</h1><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            <span class="comment">// el:&#x27;#box&#x27;,</span></span><br><span class="line">            <span class="attr">aa</span>:<span class="number">11</span>,<span class="comment">//自定义属性</span></span><br><span class="line">            <span class="attr">show</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="number">1</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(vm.$options.aa);<span class="comment">//获取自定义属性</span></span><br><span class="line">vm.$options.show();</span><br></pre></td></tr></table></figure><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。</p><h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><p>获取Vue实例挂载的元素节点</p><h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><p>一个对象，持有注册过 <a href="https://cn.vuejs.org/v2/api/#ref"><code>ref</code> attribute</a> 的所有 DOM 元素和组件实例。</p><h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><p>父实例，如果当前实例有的话。</p><h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p><h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><p>vm.$watch( expOrFn, callback, [options] )</p><p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。</p><h3 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h3><p>vm.$set( target, propertyName/index, value )</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h3><p>挂载,将数据转化为dom</p><h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><a href="https://www.jianshu.com/p/a7550c0e164f">https://www.jianshu.com/p/a7550c0e164f</a></p><p>在下次 DOM 更新循环结束之后执行延迟回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a><strong>组件名大小写</strong></h2><ul><li><h4 id="kebab-case-短横线分隔命名"><a href="#kebab-case-短横线分隔命名" class="headerlink" title="kebab-case(短横线分隔命名)"></a>kebab-case(短横线分隔命名)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure><p>当使用 kebab-case 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。</p></li><li><h4 id="PascalCase-首字母大写命名"><a href="#PascalCase-首字母大写命名" class="headerlink" title="PascalCase  (首字母大写命名)"></a>PascalCase  (首字母大写命名)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;MyComponentName&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure><p>当使用 PascalCase定义 一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的</p></li></ul><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><ul><li><strong>定义组件</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;Aaa&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">var</span> Aaa=Vue.extend(&#123;</span><br><span class="line">        <span class="comment">//必须以函数的形式返回</span></span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                <span class="attr">msg</span>:<span class="string">&#x27;我是&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.msg=<span class="string">&#x27;change&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">template</span>:<span class="string">&#x27;&lt;h1 @click=&quot;change&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line">        <span class="comment">//或者template:&#x27;#Aaa&#x27;;</span></span><br><span class="line">        <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="comment">//组件里面还可以嵌套一个组件</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//vue2.0组件定义</span></span><br><span class="line"><span class="keyword">var</span> Aaa=&#123;</span><br><span class="line"><span class="attr">template</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Aaa</span><br></pre></td></tr></table></figure><ul><li><strong>组件使用</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入组件</span></span><br><span class="line"><span class="keyword">import</span> Aaa <span class="keyword">from</span> <span class="string">&#x27;./Aaa&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    Aaa,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C">https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import upperFirst from &#x27;lodash/upperFirst&#x27;</span><br><span class="line">import camelCase from &#x27;lodash/camelCase&#x27;</span><br><span class="line"></span><br><span class="line">const requireComponent = require.context(</span><br><span class="line">  // 其组件目录的相对路径</span><br><span class="line">  &#x27;./components&#x27;,</span><br><span class="line">  // 是否查询其子目录</span><br><span class="line">  false,</span><br><span class="line">  // 匹配基础组件文件名的正则表达式</span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(fileName =&gt; &#123;</span><br><span class="line">  // 获取组件配置</span><br><span class="line">  const componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  // 获取组件的 PascalCase 命名</span><br><span class="line">  const componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      // 获取和目录深度无关的文件名</span><br><span class="line">      fileName</span><br><span class="line">        .split(&#x27;/&#x27;)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(/\.\w+$/, &#x27;&#x27;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  // 全局注册组件</span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    // 如果这个组件选项是通过 `export default` 导出的，</span><br><span class="line">    // 那么就会优先使用 `.default`，</span><br><span class="line">    // 否则回退到使用模块的根。</span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong>。<a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">这里</a>有一个真实项目情景下的示例。</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a><strong>动态组件</strong></h2><p><component :is="componentArr[i]"></component></p><p>componentArr=[component1,component2]</p><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="插槽：slot"><a href="#插槽：slot" class="headerlink" title="插槽：slot"></a>插槽：slot</h3><p>组件里所有标签赋值给slot标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;aaa&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">slot</span>=<span class="string">&quot;ul-slot&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">slot</span>=<span class="string">&quot;ol-slot&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">&lt;/aaa&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;ol-slot&quot;</span>&gt;</span>这是默认的情况<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>welcome vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;ul-slot&quot;</span>&gt;</span>这是默认的情况2<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Aaa和Baa组件，Aaa中有3个Tab栏（1，2，3），点击2后，点击Baa,再点击Aaa，会出现1的内容。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 <strong>currentTabComponent</strong> 实例。</p><p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。<br>用一个 <keep-alive> 元素将其动态组件包裹起来，<strong>组件将会被缓存</strong></p><h4 id="keep-alive-1"><a href="#keep-alive-1" class="headerlink" title="keep-alive"></a>keep-alive</h4><ul><li><p><strong>Props</strong>：</p><ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><code>max</code> - 数字。最多可以缓存多少组件实例。</li></ul></li><li><p><strong>用法</strong>：</p><p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p><ul><li>页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated</li><li>退出时触发deactivated</li><li>当再次进入（前进或者后退）时，只触发activated。</li></ul></li></ul><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a><a href="https://cn.vuejs.org/v2/api/#transition">transition</a></h3><h4 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a><strong>Prop</strong></h4><ul><li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为 <code>.fade-enter</code>，<code>.fade-enter-active</code> 等。默认类名为 <code>&quot;v&quot;</code></li><li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li><li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li><li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li><li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li><li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li><li><code>enter-class</code> - string</li><li><code>leave-class</code> - string</li><li><code>appear-class</code> - string</li><li><code>enter-to-class</code> - string</li><li><code>leave-to-class</code> - string</li><li><code>appear-to-class</code> - string</li><li><code>enter-active-class</code> - string</li><li><code>leave-active-class</code> - string</li><li><code>appear-active-class</code> - string</li></ul><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ul><li><code>before-enter</code></li><li><code>before-leave</code></li><li><code>before-appear</code></li><li><code>enter</code></li><li><code>leave</code></li><li><code>appear</code></li><li><code>after-enter</code></li><li><code>after-leave</code></li><li><code>after-appear</code></li><li><code>enter-cancelled</code></li><li><code>leave-cancelled</code> (<code>v-show</code> only)</li><li><code>appear-cancelled</code></li></ul><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>&lt;transition&gt;</code> 元素作为<strong>单个</strong>元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 简单元素 --&gt;</span><br><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;div v-if=&quot;ok&quot;&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态组件 --&gt;</span><br><span class="line">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 事件钩子 --&gt;</span><br><span class="line">&lt;div id=&quot;transition-demo&quot;&gt;</span><br><span class="line">  &lt;transition @after-enter=&quot;transitionComplete&quot;&gt;</span><br><span class="line">    &lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    transitionComplete: function (el) &#123;</span><br><span class="line">      // 传入 &#x27;el&#x27; 这个 DOM 元素作为参数。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;).$mount(&#x27;#transition-demo&#x27;)</span><br></pre></td></tr></table></figure><ul><li><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/transitions.html">过渡：进入，离开和列表</a></li></ul><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 HTML 中是 kebab-case(短横线分隔命名)  的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;!-- 在 HTML 中是 的 camelCase (小驼峰)--&gt;</span><br><span class="line">&lt;blog-post postTitle=&quot;hello!&quot;&gt;&lt;/blog-post&gt;、</span><br><span class="line">//都可以用postTitle来获取</span><br><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;T</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&#x27;postTitle&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>​    每个 prop 都可以指定的值类型</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object,</span><br><span class="line">  callback: Function,</span><br><span class="line">  contactsPromise: Promise <span class="comment">// or any other constructor</span></span><br><span class="line">  src: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">    &#125;,</span><br><span class="line">  style: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      <span class="comment">//使用 prop 定义中的 validator 选项，可以将一个 prop 类型限制在一组特定的值中。</span></span><br><span class="line">      validator: s =&gt; [&#x27;square&#x27;, &#x27;rounded&#x27;].includes(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。</p></li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p><a href="https://segmentfault.com/a/1190000019208626">https://segmentfault.com/a/1190000019208626</a></p><h3 id="子组件获取父组件的数据"><a href="#子组件获取父组件的数据" class="headerlink" title="子组件获取父组件的数据"></a>子组件获取父组件的数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</span><br><span class="line">子组件中使用mounted编译完成，将父组件数据赋值给子组件的数据，而直接不使用父组件数据</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">             <span class="built_in">this</span>.b=<span class="built_in">this</span>.msg;</span><br><span class="line">       <span class="comment">//   vue2.0不允许直接给父级的数据做赋值操作</span></span><br><span class="line">       <span class="comment">//若父组件每次传一个对象给子组件，则可以赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父组件获取子组件的数据"><a href="#父组件获取子组件的数据" class="headerlink" title="父组件获取子组件的数据"></a>父组件获取子组件的数据</h3><p>组件通信: 实现子组件向父组件通信</p><p>父组件监听子组件的触发的事件，从而处理事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">&lt;aaa&gt;</span><br><span class="line">&lt;/aaa&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;aaa&quot;&gt;</span><br><span class="line">&lt;span&gt;我是父级 -&gt; &#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;bbb @child-msg=&quot;get&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;bbb&quot;&gt;</span><br><span class="line">&lt;h3&gt;子组件-&gt; &#123;&#123;a&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;send&quot; @click=&quot;send&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm=new Vue(&#123;</span><br><span class="line">el:&#x27;#box&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">a:&#x27;aaa&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">&#x27;aaa&#x27;:&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&#x27;我是父组件的数据&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template:&#x27;#aaa&#x27;,</span><br><span class="line">methods:&#123;</span><br><span class="line">get(msg)&#123;</span><br><span class="line">alert(msg);</span><br><span class="line">this.msg=msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">&#x27;bbb&#x27;:&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">a:&#x27;我是子组件的数据&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template:&#x27;#bbb&#x27;,</span><br><span class="line">methods:&#123;</span><br><span class="line">send()&#123;</span><br><span class="line">//将子组件的数据传递给父组件</span><br><span class="line">this.$emit(&#x27;child-msg&#x27;,this.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h3><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Event = new Vue();　　　　　　相当于又new了一个vue实例，Event中含有vue的全部方法；</span><br><span class="line"></span><br><span class="line">Event.$emit(&#x27;msg&#x27;,this.msg);　　　   发送数据，第一个参数是发送数据的名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置；</span><br><span class="line"></span><br><span class="line">Event.$on(&#x27;msg&#x27;,function(msg)&#123;　　接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，要对数据的操作</span><br><span class="line"></span><br><span class="line">事件总线eventBus主要是在要相互通信的两个Vue页面之中，都引入一个新的vue实例，然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备一个空的实例对象</span></span><br><span class="line">        <span class="keyword">var</span> Event=<span class="keyword">new</span> Vue();</span><br><span class="line">        <span class="keyword">var</span> A=&#123;</span><br><span class="line">            <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;我是A组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125;</span></span><br><span class="line"><span class="string">                    &lt;input type=&quot;button&quot; value=&quot;把A数据给C&quot; @click=&quot;send&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">            <span class="attr">methods</span>:&#123;</span><br><span class="line">                <span class="function"><span class="title">send</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    Event.$emit(<span class="string">&#x27;a-msg&#x27;</span>,<span class="built_in">this</span>.a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">a</span>:<span class="string">&#x27;我是a数据&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> C=&#123;</span><br><span class="line">            <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;我是C组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;接收过来的A的数据为: &#123;&#123;a&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">a</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//var _this=this;</span></span><br><span class="line">                Event.$on(<span class="string">&#x27;a-msg&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.a=a;</span><br><span class="line">                &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><p><strong>允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。</p><p>一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</p><p><strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p><h3 id="parent-children与-ref"><a href="#parent-children与-ref" class="headerlink" title="$parent / $children与 ref"></a><code>$parent</code> / <code>$children</code>与 <code>ref</code></h3><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li><li><strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component-a 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="built_in">window</span>.alert(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">component-a</span> <span class="attr">ref</span>=<span class="string">&quot;comA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    mounted () &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> comA = <span class="built_in">this</span>.$refs.comA;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(comA.title);  <span class="comment">// Vue.js</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      comA.sayHello();  <span class="comment">// 弹窗</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>父子通信：</li></ul><p>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></p><ul><li>兄弟通信：</li></ul><p>Bus；Vuex</p><ul><li>跨级通信：</li></ul><p>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></p><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>Vue 实例在被创建时都要经过一系列的初始化过程 ， 编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等 。 在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。 </p><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul><li>vue1.0</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created-&gt;   实例已经创建√</span><br><span class="line">beforeCompile-&gt;   编译之前</span><br><span class="line">compiled-&gt;   编译之后</span><br><span class="line">ready-&gt;   插入到文档中√</span><br><span class="line">beforeDestroy-&gt;   销毁之前</span><br><span class="line">destroyed-&gt;   销毁之后</span><br></pre></td></tr></table></figure><ul><li><p>vue2.0</p><p><a href="https://zhuanlan.zhihu.com/p/53039906">https://zhuanlan.zhihu.com/p/53039906</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">组件实例刚刚被创建,属性都没有，组件的el（Vue实例挂载的元素节点）和data都未被创建</span><br><span class="line"></span><br><span class="line">created     </span><br><span class="line">实例已经创建完成，组件的数据data已经被创建好，但是el还处于未被创建状态。</span><br><span class="line"></span><br><span class="line">beforeMount</span><br><span class="line">模板编译之前,组件的el会被创建，render 函数首次被调用。但是值得注意的是：虽然数据data早已经被创建好，但是它还未被应用到真实的DOM元素中,而是render将data中的数据和vue声明的模板template编译成浏览器可读的HTML挂载到对应虚拟dom触发的钩子。</span><br><span class="line"></span><br><span class="line">mounted</span><br><span class="line">模板编译之后，组件的el,data都已经全部被创建好，触发虚拟dom的钩子将编译好的HTML替换掉el属性所指的dom，应用到真实DOM元素中。</span><br><span class="line"></span><br><span class="line">beforeUpdate组件更新之前</span><br><span class="line">updated组件更新完毕</span><br><span class="line">beforeDestroy组件销毁前</span><br><span class="line">destroyed组件销毁后</span><br><span class="line"></span><br><span class="line">activatedkeep-alive 组件激活时调用。</span><br><span class="line">deactivatedkeep-alive 组件停用时调用。</span><br></pre></td></tr></table></figure><p> <img src="https://segmentfault.com/img/bVEs9x?w=847&h=572" alt="f847b38a-63fe-11e6-9c29-38e58d46f036.png"> </p><p>不要在生命周期函数或者回调上使用箭头函数， 因为箭头函数并没有 <code>this</code> ,this指向调用它的VUE实例</p><p> 比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code> </p><img src="https://upload-images.jianshu.io/upload_images/7414631-6af6e3bd7fe52a94.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" /><h1 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h1><h2 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a><strong>hash和history</strong></h2><p>最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>hash</strong></p><p>window监听到哈希值的变化，触发<strong>onhashchage事件</strong>。hash虽然出现在URL中，但不会被包括在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面，只是按需加载前端的代码块。哈希模式也是当下单页面应用的标配,所谓前端路由的强大之处也就在这里：路由分发不需要服务器来做，前端自己就可以完成。</p><p><strong>history</strong></p><p>利用了HTML5 History Interface中新增的pushState()和replaceState（）方法。这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对<strong>历史记录进行修改</strong>的功能。</p><p>下面阐述几种 <code>HTML5</code> 新增的 <code>history API</code> 。<strong>具体如下表：</strong></p><table><thead><tr><th>API</th><th>定义</th></tr></thead><tbody><tr><td>history.pushState(data, title [, url])</td><td>pushState主要用于<strong>往历史记录堆栈顶部添加一条记录</strong>。各参数解析如下：<strong>①data</strong>会在onpopstate事件触发时作为参数传递过去；<strong>②title</strong>为页面标题，当前所有浏览器都会忽略此参数；③<strong>url</strong>为页面地址，可选，缺少时表示为当前页地址</td></tr><tr><td>history.replaceState(data, title [, url])</td><td>更改当前的历史记录，参数同上； 上面的pushState是添加，这个更改</td></tr><tr><td>history.state</td><td>用于存储以上方法的data数据，不同浏览器的读写权限不一样</td></tr><tr><td>window.onpopstate</td><td>响应pushState或者replaceState的调用。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在用户手动输入URL后回车，或者刷新（重启）浏览器的时候：</p><p>history.pushState() 设置新的 url 可以是与当前 url 同源的任意 url，而 hash 只可修改#后面的部分，因此只能设置与当前 url 同文档的 url</p><p>pushState()设置新的 url 可以与当前 url 一模一样，这样也会把记录添加到栈中，而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中。</p><p>pushState(state,title,url) state 参数可以添加任意类型的数据到记录中，而 hash 只可添加短字符串</p><p>hash 模式下，仅 hash 符号之前的内容被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。history 模式下，前端的 url 必须和实际向后端发起请求的 url 一致，如 <a href="https://link.juejin.cn/?target=http://www.abc.com/book/id">www.abc.com/book/id</a> 如果后端缺少对 /book/id 的路由的处理，将会返回 404 错误。所以在使用 history 模式时，如果 url 匹配不到任何静态资源，则应该返回同一个 index 页面。</p><h2 id="路由创建"><a href="#路由创建" class="headerlink" title="路由创建"></a>路由创建</h2><p>直接<code>vue add router</code>,或者</p><ol><li><p>下载vue-router模块  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></li><li><p>创建文件夹，存放路由配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">import login from &quot;../components/login.vue&quot;;</span><br><span class="line">import register from &quot;../components/register.vue&quot;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;,</span><br><span class="line">    component: login,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/register&quot;,</span><br><span class="line">    component: register,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &quot;history&quot;,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>main.js文件中引入router</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import App from &quot;./App.vue&quot;;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">import router from &quot;./router/index&quot;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router: router,</span><br><span class="line">  render: (h) =&gt; h(App),</span><br><span class="line">&#125;).$mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="自动配置路由"><a href="#自动配置路由" class="headerlink" title="自动配置路由"></a>自动配置路由</h2><p>根据文件夹自动配置路由</p><p><img src="img/vue/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1.png" alt="自动配置路由"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routes = []</span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line"><span class="keyword">const</span> routerContext = <span class="built_in">require</span>.context(<span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/index\.js$/</span>)</span><br><span class="line"></span><br><span class="line">routerContext.keys().forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// route就是路径</span></span><br><span class="line">  <span class="comment">// 如果是根目录的index不做处理</span></span><br><span class="line">  <span class="keyword">if</span> (route.startsWith(<span class="string">&#x27;./index&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> routerModule = routerContext(route)</span><br><span class="line">  routes = [...routes, ...(routerModule.default || routerModule)]</span><br><span class="line">  <span class="built_in">console</span>.log(routes)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.BASE_URL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: isProd &amp;&amp; process.env.VUE_APP_PREVIEW !== <span class="string">&#x27;true&#x27;</span> ? <span class="string">&#x27;/wechatpub/&#x27;</span> : process.env.BASE_URL,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//activity/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 活动路由配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/activity/smashedEgg/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;SmashedEgg&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;survey&quot; */</span> <span class="string">&#x27;@/views/activity/SmashedEgg.vue&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问</span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8080/wechatpub/activity/smashedEgg/1</span></span><br></pre></td></tr></table></figure><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>vuex是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong> 。它采用集中式存储管理应用的所有组件的状态 </p><p>这个状态自管理应用包含以下几个部分：</p><ul><li><strong>state</strong>，驱动应用的数据源；</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">store</span>: store,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$store.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: &#123; Counter &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="comment">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性</span></span><br><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="comment">//Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state,n) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count+=n</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">mount</span>: n,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.commit(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span>,</span><br><span class="line">  <span class="attr">amount</span>: n,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Mutation 必须是同步函数</p></blockquote><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意<strong>异步操作</strong>(请求在这里操作)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 <strong>store 实例</strong>具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实践中，我们会经常用到 ES2015 的 参数解构 (opens new window)来简化代码</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (&#123; commit &#125;) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可以在 action 内部执行<strong>异步</strong>操作</p></blockquote><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><h2 id="vuex项目"><a href="#vuex项目" class="headerlink" title="vuex项目"></a>vuex项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── getters.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── user.js       # </span><br><span class="line">        └── market.js   # </span><br></pre></td></tr></table></figure><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./modules/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> market <span class="keyword">from</span> <span class="string">&#x27;./modules/market&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user,</span><br><span class="line">    market</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getters-js"><a href="#getters-js" class="headerlink" title="getters.js"></a>getters.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">userInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.userInfo,</span><br><span class="line">  <span class="attr">fullInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.fullInfo,</span><br><span class="line">  <span class="attr">areaList</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.areaList,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> market = &#123;</span><br><span class="line">  <span class="attr">homePage</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.market.homePage,</span><br><span class="line">  <span class="attr">goodsInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.market.goodsInfo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  ...user,</span><br><span class="line">  ...market</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="user-js"><a href="#user-js" class="headerlink" title="user.js"></a>user.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable no-unused-vars */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，向后端请求用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  getUserCoreInfo,</span><br><span class="line">  getUserFullInfo,</span><br><span class="line">  getCityDropDown,</span><br><span class="line"> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">userInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">fullInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">areaList</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">SET_CORE_INFO</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.userInfo = data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">SET_FULL_INFO</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.fullInfo = data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">SET_AREA_LIST</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.areaList = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> GetUserCoreInfo (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> getUserCoreInfo()</span><br><span class="line">      commit(<span class="string">&#x27;SET_CORE_INFO&#x27;</span>, result.data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> GetUserFullInfo (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> getUserFullInfo()</span><br><span class="line">      commit(<span class="string">&#x27;SET_FULL_INFO&#x27;</span>, result.data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> EditUserFullInfo (&#123; commit &#125;, params) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> editUserFullInfo(params)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> user</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  userCoreInfo () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.userInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch &#125; = <span class="built_in">this</span>.$store</span><br><span class="line">  dispatch(<span class="string">&#x27;GetUserCoreInfo&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> router </tag>
            
            <tag> vuex </tag>
            
            <tag> vue搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目构建</title>
      <link href="/2020/09/25/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/09/25/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><a href="https://juejin.cn/post/6887135998099062792">https://juejin.cn/post/6887135998099062792</a></p><p><a href="https://blog.csdn.net/Charissa2017/article/details/105886521">https://blog.csdn.net/Charissa2017/article/details/105886521</a></p><p>nginx命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nginx <span class="comment">#打开 nginx</span></span><br><span class="line">nginx -t           <span class="comment">#测试配置文件是否有语法错误</span></span><br><span class="line">nginx -s reopen<span class="comment">#重启Nginx</span></span><br><span class="line">nginx -s reload<span class="comment">#重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span></span><br><span class="line">nginx -s stop  <span class="comment">#强制停止Nginx服务</span></span><br><span class="line">nginx -s quit  <span class="comment">#停止Nginx服务（即处理完所有请求后再停止服务）</span></span><br><span class="line"></span><br><span class="line">nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">-?,-h           : 打开帮助信息</span><br><span class="line">-v              : 显示版本信息并退出</span><br><span class="line">-V              : 显示版本和配置选项信息，然后退出</span><br><span class="line">-t              : 检测配置文件是否有语法错误，然后退出</span><br><span class="line">-q              : 在检测配置文件期间屏蔽非错误信息</span><br><span class="line">-s signal       : 给一个 nginx 主进程发送信号：stop（强制停止）, quit（优雅退出）, reopen（重启）, reload（重新加载配置文件）</span><br><span class="line">-p prefix       : 设置前缀路径（默认是：/usr/share/nginx/）</span><br><span class="line">-c filename     : 设置配置文件（默认是：/etc/nginx/nginx.conf）</span><br><span class="line">-g directives   : 设置配置文件外的全局指令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/run nginx.pid</span><br><span class="line">/etc/nginx nginx配置</span><br><span class="line">/root 页面</span><br><span class="line">/var/log/nginx/access.log 报错信息</span><br></pre></td></tr></table></figure><p>tip:</p><ul><li><p>nginx: [error] open() “/run/nginx.pid” failed (2: No such file or directory)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li></ul><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">$ npm install pm2 -g     # 命令行安装 pm2 </span><br><span class="line">$ pm2 start app.js -i 4 #后台运行pm2，启动4个app.js </span><br><span class="line">                                # 也可以把&#x27;max&#x27; 参数传递给 start</span><br><span class="line">                                # 正确的进程数目依赖于Cpu的核心数目</span><br><span class="line">$ pm2 start app.js --name my-api # 命名进程</span><br><span class="line">$ pm2 list               # 显示所有进程状态</span><br><span class="line">$ pm2 monit              # 监视所有进程</span><br><span class="line">$ pm2 logs               #  显示所有进程日志</span><br><span class="line">$ pm2 stop all           # 停止所有进程</span><br><span class="line">$ pm2 restart all        # 重启所有进程</span><br><span class="line">$ pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0             # 停止指定的进程</span><br><span class="line">$ pm2 restart 0          # 重启指定的进程</span><br><span class="line">$ pm2 startup            # 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0           # 杀死指定的进程</span><br><span class="line">$ pm2 delete all         # 杀死全部进程</span><br></pre></td></tr></table></figure><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p><a href="https://help.aliyun.com/document_detail/50775.html">https://help.aliyun.com/document_detail/50775.html</a></p><p><a href="https://www.jianshu.com/p/175558881f19">https://www.jianshu.com/p/175558881f19</a></p><h1 id="前端⼯程化"><a href="#前端⼯程化" class="headerlink" title="前端⼯程化"></a><strong>前端⼯程化</strong></h1><h2 id="JS模块规范"><a href="#JS模块规范" class="headerlink" title="JS模块规范"></a>JS模块规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。</p><p>核心思想：<br>允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p><p><strong>优点：</strong>服务器端模块重用，NPM中模块包多，有将近20万个。</p><p><strong>缺点：</strong>加载模块是<strong>同步</strong>的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p><p><strong>实现</strong>：</p><ul><li>服务器端的 <a href="http://www.nodejs.org/">Node.js</a></li><li><a href="http://browserify.org/">Browserify</a>，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大</li><li><a href="https://github.com/medikoo/modules-webmake">modules-webmake</a>，类似Browserify，还不如 Browserify 灵活</li><li><a href="https://github.com/substack/wreq">wreq</a>，Browserify 的前身</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h3><p>鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。</p><p><strong>其核心接口是</strong>：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块<strong>提前执行</strong>，<strong>依赖前置</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;module&quot;</span>, [<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module&quot;</span>, <span class="string">&quot;../file&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>在浏览器环境中异步加载模块；并行加载多个模块；</p><p><strong>缺点：</strong>开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h3><p>Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ = require(&#x27;jquery&#x27;);</span><br><span class="line">  var Spinning = require(&#x27;./spinning&#x27;);</span><br><span class="line">  exports.doSomething = ...</span><br><span class="line">  module.exports = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：依赖就近，延迟执行</strong>（对于依赖的模块延迟执行，即只在需要用到某个模块的时候再require） 可以很容易在 Node.js 中运行；<br><strong>缺点：</strong>依赖 SPM 打包，模块的加载逻辑偏重；<br><strong>实现：Sea.js</strong> ；coolie</p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><strong>ES6</strong></h3><p>ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。<a href="http://es6.ruanyifeng.com/#docs/module">ES6 模块</a>的设计思想，是尽量的静态化，使得<strong>编译</strong>时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。<strong>但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span> <span class="string">&quot;localModule&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>容易进行静态分析</li><li>面向未来的 ECMAScript 标准</li></ul><p>缺点：</p><ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令字，新版的 Node.js才支持</li></ul><h3 id="模块包的导入导出"><a href="#模块包的导入导出" class="headerlink" title="模块包的导入导出"></a>模块包的导入导出</h3><p><a href="https://mp.weixin.qq.com/s/1wUU-i3W4RlR2hf86lZqEA">https://mp.weixin.qq.com/s/1wUU-i3W4RlR2hf86lZqEA</a></p><h4 id="CommonJS-1"><a href="#CommonJS-1" class="headerlink" title="CommonJS"></a>CommonJS</h4><h4 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h4><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><p>在ES6 Module 中，导出用到了关键字 <code>export</code> ，导出的方式也大致分为两种，分别是<strong>命名导出</strong> 、<strong>默认导出</strong></p><p><strong>第一种：</strong> 命名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="comment">/*--------  单个变量或函数导出  ----------*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;show方法被调用&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------  批量导出  ----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;show方法被调用&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;show, count&#125;</span><br></pre></td></tr></table></figure><p>上述代码分了两种情况，且这两种写法是等价的</p><p>第一种是单个的变量或函数导出，只需要直接在开头使用 <code>export</code> 关键字即可；</p><p>第二种情况是批量地把多个变量或函数导出，只需要把它们储存到一个对象中即可</p><p><strong>第二种：</strong> 默认导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// B.js</span><br><span class="line">function show() &#123; console.log(&#x27;show方法被调用&#x27;) &#125;</span><br><span class="line"></span><br><span class="line">// 命名导出变量count</span><br><span class="line">export let count = 3</span><br><span class="line"></span><br><span class="line">// 默认导出函数show</span><br><span class="line">export default show</span><br></pre></td></tr></table></figure><p>默认导出是在 <code>export</code> 关键词后面再跟上一个 <code>default</code> 表示导出的该变量或函数是匿名的</p><blockquote><p><strong>注意：</strong> 一个模块只能默认导出一次，否则就会报错，具体原因会在后面讲解</p></blockquote><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>ES6 Module 的导入用到的关键字是 <code>import</code> ，具体代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;show, count&#125; <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">show()   <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>ES6 Module的导入需要用一对 <code>&#123;&#125;</code> 大括号来接收我们需要导入的方法或函数</p><blockquote><p><strong>注意：</strong> 大括号中的变量或函数名必须与导出时的名称一模一样</p></blockquote><p>那么如果我们想修改导入的变量或函数的名称，可以通过 <code>as</code> 关键词来命名，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;show <span class="keyword">as</span> print, count <span class="keyword">as</span> number&#125; <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">print()   <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果我们要想将所有的变量或函数都导入，可以通过 <code>*</code> 来整体导入，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bModule <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">bModule.show()  <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bModule.count)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>*</code> 表示全部的意思，我们将其全部导入，并赋值给 <code>bModule</code>，这样我们就可以通过 <code>bModule</code> 获取想要的变量或对象了</p><p>以上所说的都是针对命名导出的变量或函数，那么如何导入一个默认导出的变量或函数呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将通过 export default 导出的变量导入</span></span><br><span class="line"><span class="keyword">import</span> print <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">print()  <span class="comment">// show方法被调用</span></span><br></pre></td></tr></table></figure><p>命名导出的变量都是通过 <code>&#123;&#125;</code> 来接收的，那么去掉 <code>&#123;&#125;</code> ，接收的就是默认导出的变量了，因为导出的变量是匿名的，因此我们可以随意地起个变量名用于接收</p><p><strong>补充：</strong> 这里特别提一下，与CommonJS不同，ES6 Module 的导入文件路径是不支持表达式的.</p><h4 id="CommonJS-与ES6的区别"><a href="#CommonJS-与ES6的区别" class="headerlink" title="CommonJS 与ES6的区别"></a>CommonJS 与ES6的区别</h4><p>这两者的主要区别主要有以下两点：</p><ol><li>对于模块的依赖，CommonJS是<strong>动态的</strong>，ES6 Module 是<strong>静态的</strong></li><li>CommonJS导入的是值的<strong>拷贝</strong>，ES6 Module导入的是值的<strong>引用</strong></li></ol><h5 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h5><p>对于模块的依赖，何为<strong>动态</strong>？何为<strong>静态</strong>？</p><p>动态是指对于模块的依赖关系建立在代码执行阶段；静态是指对于模块的依赖关系建立在代码编译阶段；</p><p>上文提到，CommonJS导入时，<code>require</code> 的路径参数是支持表达式的，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// A.js</span><br><span class="line">let fileName = &#x27;example.js&#x27;</span><br><span class="line">const bModule = require(&#x27;./&#x27; + fileName)</span><br></pre></td></tr></table></figure><p>因为该路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS是动态的。</p><p>那么现在你也应该也知道为什么 ES6 Module 是静态的了吧</p><h5 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h5><p>为了验证这一点，我准备用实例来演示一下</p><p>首先来验证CommonJS，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// B.js</span><br><span class="line">let count = 3</span><br><span class="line"></span><br><span class="line">function change() &#123;</span><br><span class="line">    count ++    // 变量count + 1</span><br><span class="line">    console.log(&#x27;原count值为：&#x27;, count);  // 打印B.js模块中count的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    count,</span><br><span class="line">    change</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A.js</span><br><span class="line">let count = require(&#x27;./B.js&#x27;).count </span><br><span class="line">let change = require(&#x27;./B.js&#x27;).change</span><br><span class="line"></span><br><span class="line">console.log(&#x27;改变前：&#x27;, count);   </span><br><span class="line">change()     // 调用模块B.js中的change方法，将原来的count + 1</span><br><span class="line">console.log(&#x27;改变后：&#x27;, count); </span><br><span class="line"></span><br><span class="line">// 运行A.js文件的结果</span><br><span class="line">改变前：3</span><br><span class="line">原count值为：4</span><br><span class="line">改变后：3</span><br></pre></td></tr></table></figure><p>在上述代码中我们可以看到，在 <code>A.js</code> 文件中导入了 <code>B.js</code> 文件中的变量 <code>count</code> 和 函数 <code>change</code>，因为导入的 <code>count</code> 只是对原有值的一个拷贝，因此尽管我们调用了函数 <code>change</code> 改变了 <code>B.js</code> 文件中变量 <code>count</code> 的值，也不会影响到 <code>A.js</code> 文件中的变量 <code>count</code></p><p>根据这个结果得出结论：CommonJS导入的变量是对原值的拷贝</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><h3 id="构建历史"><a href="#构建历史" class="headerlink" title="构建历史"></a>构建历史</h3><p><img src="img/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.webp" alt="构建历史"></p><p>前端模块化/构建工具从最开始的基于浏览器<strong>运行时</strong>加载的 <code>RequireJs/Sea.js</code> 到将所有资源组装依赖打包 <code>webpack</code>/<code>rollup</code>/<code>parcel</code>的<code>bundle</code>类模块化构建工具，再到现在的<code>bundleless</code>基于浏览器原生 ES 模块的 <code>snowpack</code>/<code>vite</code>，前端的模块化/构建工具发展到现在已经快 10 年了。</p><ul><li><p> Grunt</p></li><li><p>browserify</p><p><code>browserify</code>致力于在浏览器端使用<code>CommonJs</code>，他使用跟 <code>NodeJs</code> 一样的模块化语法，然后将所有依赖文件编译到一个<code>bundle</code>文件，在浏览器通过<code>&lt;script&gt;</code>标签使用的，并且支持 npm 库。</p></li><li><p>Gulp</p></li><li><p>webpack</p><p><code>webpack1</code>支持<code>CommonJs</code>和<code>AMD</code>模块化系统，优化依赖关系，支持分包，支持多种类型 script、image、file、css/less/sass/stylus、mocha/eslint/jshint 的打包，丰富的插件体系。<code>webpack</code>的概念更偏向于工程化</p><p>以上的 3 个库 <code>Grunt/Gulp/browserify</code> 都是偏向于工具，而 <code>webpack</code>将以上功能都集成到一起，相比于工具它的功能大而全。</p></li><li><p>rollup</p><p><code>rollup</code>编译<code>ES6</code>模块，提出了<code>Tree-shaking</code>，根据<code>ES module</code>静态语法特性，删除未被实际使用的代码，支持导出多种规范语法，并且导出的代码非常简洁，如果看过 <code>vue</code> 的<code>dist</code> 目录代码就知道导出的 <code>vue</code> 代码完全不影响阅读。</p><p><code>rollup</code>的插件系统支持：<code>babel</code>、<code>CommonJs</code>、<code>terser</code>、<code>typescript</code>等功能。</p><p>相比于<code>browserify</code>的<code>CommonJs</code>，<code>rollup</code>专注于<code>ES module</code>。<br>相比于<code>webpack</code>大而全的前端工程化，<code>rollup</code>专注于纯<code>javascript</code>，大多被用作打包<code>tool</code>工具或<code>library</code>库。</p><p>react、vue 等库都使用<code>rollup</code>打包项目，并且下面说到的<code>vite</code>也依赖<code>rollup</code>用作生产环境打包 js。</p></li><li><p>snowpack 和 vite</p><p>因为 <code>snowpack</code> 和 <code>vite</code> 比较类似，都是<code>bundleless</code>所以一起拿来说。<code>bundleless</code>类运行时打包工具的启动速度是毫秒级的，因为不需要打包任何内容，只需要起两个<code>server</code>，一个用于页面加载，另一个用于<code>HMR</code>的<code>WebSocket</code>，当浏览器发出原生的<code>ES module</code>请求，<code>server</code>收到请求只需编译当前文件后返回给浏览器不需要管依赖。<code>bundleless</code>工具在<strong>生产环境</strong>打包的时候依然<code>bundle</code>构建所以依赖视图的方式，vite 是利用 <code>rollup</code> 打包生产环境的 js 的。</p></li></ul><h3 id="webpack和gulp的区别"><a href="#webpack和gulp的区别" class="headerlink" title="webpack和gulp的区别"></a>webpack和gulp的区别</h3><h4 id="webpack打包工具定义"><a href="#webpack打包工具定义" class="headerlink" title="webpack打包工具定义"></a>webpack打包工具定义</h4><p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。</p><p><strong>网页中常见的静态资源</strong></p><p><strong>js</strong>–js，jax，coffee，ts(TypeScript,需要编译为js)</p><p><strong>css</strong>– css,less,sass</p><p><strong>image</strong>–jpg,png,gif,bmp,svg</p><p><strong>字体文件(Fonts)</strong>–svg,ttf,eot,woff,woff2</p><p><strong>模板文件</strong>–ejs,jade,vue(这是在webpack中定义的组件的方式)</p><p><img src="https://zhaoda.net/webpack-handbook/images/what-is-webpack.png" alt="什么是webpack"></p><h4 id="gulp构建工具定义"><a href="#gulp构建工具定义" class="headerlink" title="gulp构建工具定义"></a>gulp构建工具定义</h4><p>gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。</p><h4 id="相同功能"><a href="#相同功能" class="headerlink" title="相同功能"></a>相同功能</h4><table><thead><tr><th>功能</th><th>gulp</th><th>webpack</th></tr></thead><tbody><tr><td>文件合并与压缩（css）</td><td>使用gulp-minify-css模块 gulp.task(‘sass’,function(){    gulp.src(cssFiles)    .pipe(sass().on(‘error’,sass.logError))    .pipe(require(‘gulp-minify-css’)())    .pipe(gulp.dest(distFolder)); });</td><td>样式合并一般用到extract-text-webpack-plugin插件， 压缩则使用webpack.optimize.UglifyJsPlugin。</td></tr><tr><td>文件合并与压缩（js）</td><td>使用gulp-uglify和gulp-concat两个模块</td><td>js合并在模块化开始就已经做， 压缩则使用webpack.optimize.UglifyJsPlugin</td></tr><tr><td>sass/less预编译</td><td>使用gulp-sass/gulp-less 模块</td><td>sass-loader/less-loader 进行预处理</td></tr><tr><td>启动server</td><td>使用gulp-webserver模块 var webserver =require(‘gulp-webserver’); gulp.task(‘webserver’,function(){    gulp.src(‘./‘)    .pipe(webserver({      host:’localhost’,      port:8080,      livereload:true, //自动刷新      directoryListing:{         enable: true,         path:’./‘      },    })); });</td><td>使用webpack-dev-server模块 module.exports = {    ……    devServer: {      contentBase: “build/“,      port:8080,      inline: true //实时刷新    } }</td></tr><tr><td>版本控制</td><td>使用gulp-rev和gulp-rev-collector两个模块</td><td>将生成文件加上hash值 module.exports = {    ……   output: {     ……     filename: “[name].[hash:8].js”   },    plugins:[      ……      new ExtractTextPlugin(style.[hash].css”)    ] }</td></tr></tbody></table><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。</p></li><li><p>webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。</p></li><li><p>Webpack 可以做到按需加载。像 Grunt、Gulp 这类构建工具，打包的思路是：遍历源文件→匹配规则→打包，这个过程中做不到按需加载，即对于打包起来的资源，到底页面用不用，打包过程中是不关心的。Webpack 跟其他构建工具本质上不同之处在于：Webpack 是从入口文件开始，经过模块依赖加载、分析和打包三个流程完成项目的构建。在加载、分析和打包的三个过程中，可以针对性的做一些解决方案，达到按需加载的目的，比如code split（拆分公共代码等）。</p></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>⾸先我们通过⼀个制作⼀个打包⽂件的原型。</p><p>假设有两个js模块，这⾥我们先假设这两个模块是复合commomjs标准的es5模块。</p><p>我们的⽬的是将这两个模块打包为⼀个能在浏览器端运⾏的⽂件，这个⽂件其实叫bundle.js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;add.js&#x27;</span>).default</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span> , <span class="number">2</span>))</span><br><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="built_in">exports</span>.default = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;<span class="keyword">return</span> a + b&#125;</span><br></pre></td></tr></table></figure><p>浏览器中直接执⾏这个程序肯定会有问题 最主要的问题是<strong>浏览器中没有exports对象与require⽅法</strong>所以⼀定</p><p>会报错。我们需要通过<strong>模拟</strong>exports对象和require⽅法</p><p><strong>模拟exports对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;exports.default = function(a,b) &#123;return a + b&#125;&#x27;</span>) <span class="comment">// node⽂件读取后的代码字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>.default(<span class="number">1</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p> 由于⼦模块中会声明变量，为了不污染全局我们使⽤⼀个⾃运⾏函数来封装⼀下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, code</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">eval</span>(code)</span><br><span class="line">&#125;)(<span class="built_in">exports</span>, <span class="string">&#x27;exports.default = function(a,b)&#123;return a + b&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>模拟require函数,返回export对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line"> (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, code</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">eval</span>(code)</span><br><span class="line"> &#125;)(<span class="built_in">exports</span>, <span class="string">&#x27;exports.default = function(a,b)&#123;return a + b&#125;&#x27;</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">exports</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;add.js&#x27;</span>).default</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span> , <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>将所有模块的⽂件名和代码字符串整理为⼀张key-value表就可以根据传⼊的⽂件名加载不同的模块了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">eval</span>(code);</span><br><span class="line">    &#125;)(<span class="built_in">exports</span>, list[file]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;index.js&quot;</span>);</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;index.js&quot;</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    var add = require(&#x27;add.js&#x27;).default</span></span><br><span class="line"><span class="string">    console.log(add(1 , 2))</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  <span class="string">&quot;add.js&quot;</span>: <span class="string">`exports.default = function(a,b)&#123;return a + b&#125;`</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><h6 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a><strong>webpack</strong></h6><p>一个模块打包器，根据entry指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br>每个依赖项随即被处理，最后输出到output字段指定的文件中</p><h6 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a><strong>webpack-dev-server</strong></h6><p>webpack-dev-server：一个服务器插件，相当于webpack+apache，启动一个web服务并实时更新修改<br><strong>启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。</strong></p><p><strong>区别</strong></p><ul><li>webpack不会实时更新修改，就只是一个打包工具，webpack-dev-server会实时自动更新修改</li><li>webpack打包输出路径，output字段为path，webpack-dev-server打包输出路径，output字段为publicPath(此值为空时默认是项目根目录，  contentBase:’src’,//指定托管的根目录)</li><li>webpack打包输出的文件，是真的存在于物理地址path中，而webpack-dev-server打包输出的文件，是保存在内存中的，在项目目录中是找不到的。</li></ul><h6 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h6><p>webpack-dev-server实现了自动编译刷新浏览器，让编译出来的bundle.js托关于服务器根路径（电脑内存）中去。</p><p>html-webpack-plugin会创建一个在内存中生成一个html的插件，帮我们自动引入在内存中打包好的bundle.js文件</p><h5 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h5><p><strong>webpack默认只能打包处理 JS类型的文件，无法处理其他的非JS类型的文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loader加载器模块配置</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,<span class="comment">//使用正则匹配</span></span><br><span class="line">      use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],<span class="comment">//从后往前调用的</span></span><br><span class="line">    &#125;, <span class="comment">//如果想要启用 CSS 模块化，可以为 css-loader 添加 modules 参数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;babel-loader?cacheDirectory&quot;</span>],</span><br><span class="line">      <span class="attr">include</span>: path.resolve(__dirname, <span class="string">&quot;./src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>babel-loader: 负责 es6 语法转化</li><li>babel-preset-env: 包含 es6、7 等版本的语法转化规则</li></ul><h5 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h5><p><a href="https://jelly.jd.com/article/61179aa26bea510187770aa3">https://jelly.jd.com/article/61179aa26bea510187770aa3</a></p><h6 id="编译进度和依赖包大小"><a href="#编译进度和依赖包大小" class="headerlink" title="编译进度和依赖包大小"></a>编译进度和依赖包大小</h6><p><code>webpack-bundle-analyzer</code>可以帮助我们分析打包后的依赖包大小，<code>webpackbar</code>提供了友好的编译进度提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpackbar webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p>加入配置文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line">const WebpackBar = require(&#x27;webpackbar&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new WebpackBar(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="编译速度分析"><a href="#编译速度分析" class="headerlink" title="编译速度分析"></a>编译速度分析</h6><p>优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。通过 <a href="https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin </a>插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D speed-measure-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//webpack.base.js</span><br><span class="line">const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);</span><br><span class="line">const smp = new SpeedMeasurePlugin();</span><br><span class="line">module.exports = smp.wrap(&#123;</span><br><span class="line">  // ...webpack config...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>通过配置 <a href="https://webpack.docschina.org/configuration/cache/#root">webpack 持久化缓存 </a><code>cache: filesystem</code>，来缓存生成的 webpack 模块和 chunk，改善构建速度。</p><p>简单来说，通过 <code>cache: filesystem</code> 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 <strong>90%</strong> 左右。</p><p><code>webpack.common.js</code> 配置方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    cache: &#123;</span><br><span class="line">      type: &#x27;filesystem&#x27;, // 使用文件缓存</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//css压缩</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCss = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="comment">//压缩js文件</span></span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h4><p><a href="https://juejin.cn/post/6844903968405979144">https://juejin.cn/post/6844903968405979144</a></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li><p>Sourcemap</p><p><strong><code>Sourcemap</code> 本质上是一个信息文件</strong>，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。简单说 <code>Sourcemap</code> 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 <code>bug</code> 的位置。</p></li></ul><h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h2 id="⾃动化"><a href="#⾃动化" class="headerlink" title="⾃动化"></a>⾃动化</h2><p>调试</p><p>编译</p><p>部署</p><p>测试</p><p>⽂档化</p><h2 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h2><p>项⽬⽬录结构</p><p>语法提示</p><p>编码⻛格规范 </p><h3 id="lint"><a href="#lint" class="headerlink" title="lint"></a>lint</h3><h4 id="Lint-的含义"><a href="#Lint-的含义" class="headerlink" title="Lint 的含义"></a>Lint 的含义</h4><p><a href="https://www.jianshu.com/p/ad1e46faaea2">https://www.jianshu.com/p/ad1e46faaea2</a> </p><p><a href="https://blog.csdn.net/userkang/article/details/84305689">https://blog.csdn.net/userkang/article/details/84305689</a></p><p>每个程序员都有自己的编码习惯，最常见的莫过于：</p><ul><li>有的人写代码一行代码结尾必须加分号 <code>;</code>，有的人觉得不加分号 <code>;</code> 更好看；</li><li>有的人写代码一行代码不会超过 80 个字符，认为这样看起来简洁明了，有的人喜欢把所有逻辑都写在一行代码上，觉得别人看不懂的代码很牛逼；</li><li>有的人使用变量必然会先定义 <code>var a = 10;</code>，而粗心的人写变量可能没有定义过就直接使用 <code>b = 10;</code>；</li></ul><p>如果你写自己的项目怎么折腾都没关系，但是在公司中老板希望每个人写出的代码都要符合一个统一的规则，这样别人看源码就能够看得懂，因为源码是符合统一的编码规范制定的。</p><p>那么问题来了，总不能每个人写的代码老板都要一行行代码去检查吧，这是一件很蠢的事情。凡是重复性的工作，都应该被制作成工具来节约成本。这个工具应该做两件事情：</p><ul><li>提供编码规范；</li><li>提供自动检验代码的程序，并打印检验结果：告诉你哪一个文件哪一行代码不符合哪一条编码规范，方便你去修改代码。</li></ul><p>Lint 因此而诞生。</p><p>Lint 是检验代码格式工具的一个统称，具体的工具有 <code>Jslint</code> 、 <code>Eslint</code> 等等</p><h4 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><blockquote><p>ESLint 是什么呢？<br>是一个开源的 JavaScript 的 linting 工具，使用 <a href="https://link.zhihu.com/?target=https://github.com/eslint/espree">espree</a> 将 JavaScript 代码解析成抽象语法树 (AST)，然后通过AST 来分析我们代码，从而给予我们两种提示：</p></blockquote><ol><li><strong>代码质量问题：使用方式有可能有问题(problematic patterns)</strong></li><li><strong>代码风格问题：风格不符合一定规则 (doesn’t adhere to certain style guidelines)</strong></li></ol><p>ESLint 可以让程序员在编码的过程中发现问题而不是在执行的过程中。</p><p>ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插拔的。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。所有的规则默认都是禁用的。</p><p>ESLint 使用 <strong>Node.js</strong> 编写，这样既可以有一个快速的运行环境的同时也便于安装。 (重点，<strong>使用eslint必须有package.json文件</strong>)</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p> npm 安装 ESLint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure><p>运行 <code>eslint --init</code> 之后，<code>.eslintrc</code> 文件会在你的文件夹中自动创建</p><p>生成流程：<a href="https://blog.csdn.net/shenxianhui1995/article/details/103035013">https://blog.csdn.net/shenxianhui1995/article/details/103035013</a></p><p>之后，你可以在任何文件或目录上运行ESLint如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/.bin/eslint yourfile.js</span><br></pre></td></tr></table></figure><h5 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h5><p><a href="https://www.cnblogs.com/jiaoshou/p/11218526.html">https://www.cnblogs.com/jiaoshou/p/11218526.html</a></p><ol><li>一般都采用.eslintrc.*的配置文件进行配置, 如果放在项目的根目录中，则会作用于整个项目。如果在项目的子目录中也包含着.eslintrc文件，则对于子目录中文件的检查会忽略掉根目录中的配置，而直接采用子目录中的配置，这就能够在不同的目录范围内应用不同的检查规则，显得比较灵活。ESLint采用逐级向上查找的方式查找.eslintrc.*文件，当找到带有”root”: true配置项的.eslintrc.*文件时，将会停止向上查找。</li><li>在 package.json文件里的 eslintConfig 字段进行配置。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">&quot;globals&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;es2021&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">    <span class="string">&quot;parse&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ecmaVersion&quot;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="globals"><a href="#globals" class="headerlink" title="globals"></a>globals</h4><p>ESLint会检测未声明的额外的全局变量，并发出报错，比如node环境中的process，浏览器环境下的全局变量console，以及我们通过cdn引入的jQuery定义的$等；我们可以在<code>globals</code>中进行变量声明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;globals&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// true表示该变量可读写，false表示变量是只读</span></span><br><span class="line">        <span class="attr">&quot;$&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;console&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是node或者浏览器中的全局变量很多，如果我们一个个进行声明显得繁琐，因此就需要用到我们的<code>env</code>，这是对环境定义的一组全局变量的预设。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>使用 <code>env</code> 属性来指定要启用的环境，将其设置为 <code>true</code>，以保证在进行代码检测时不会把<a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments">这些环境</a>预定义的全局变量识别成未定义的变量而报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line">    &quot;commonjs&quot;: true,</span><br><span class="line">    &quot;es6&quot;: true,</span><br><span class="line">    &quot;jquery&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件plugins"><a href="#插件plugins" class="headerlink" title="插件plugins"></a>插件plugins</h4><h5 id="eslint-plugin-html"><a href="#eslint-plugin-html" class="headerlink" title="eslint-plugin-html"></a>eslint-plugin-html</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-plugin-html</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;html&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><h5 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h5><p><a href="https://www.npmjs.com/package/babel-eslint">Babel-ESLint</a> - 一个对<a href="https://babeljs.io/">Babel</a>解析器的包装，使其能够与 ESLint 兼容</p><h5 id="parserOptions"><a href="#parserOptions" class="headerlink" title="parserOptions"></a>parserOptions</h5><p>默认情况下，ESLint 支持 ECMAScript 5 语法，如果你想启用对 ECMAScript 其它版本和 JSX 等的支持，ESLint 允许你使用 <code>parserOptions</code> 属性进行指定想要支持的 JavaScript <a href="http://eslint.cn/docs/user-guide/configuring#specifying-parser-options">语言选项</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 代码模块类型，可选script(默认)，module</span></span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">    <span class="comment">// es版本号，默认为5，可以使用年份2015（同6）</span></span><br><span class="line">    <span class="attr">&quot;ecamVersion&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// es 特性配置</span></span><br><span class="line">    <span class="attr">&quot;ecmaFeatures&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;globalReturn&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许在全局作用域下使用 return 语句</span></span><br><span class="line">        <span class="attr">&quot;impliedStrict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用全局 strict mode </span></span><br><span class="line">        <span class="attr">&quot;jsx&quot;</span>: <span class="literal">true</span> <span class="comment">// 启用 JSX</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h4><p><strong>启用的规则及其各自的错误级别</strong></p><p>在上文的配置文件中， <code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code> 选项表示启用推荐规则，在推荐规则的基础上我们还可以根据需要使用 <code>rules</code> 新增自定义规则，每个规则的第一个值都是代表该规则检测后显示的错误级别：</p><ul><li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li><li><code>&quot;warn&quot;</code> 或 <code>1</code> - 将规则视为一个警告</li><li><code>&quot;error&quot;</code> 或 <code>2</code> - 将规则视为一个错误</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;rules&quot;</span>:&#123;</span><br><span class="line">       <span class="comment">// 代码缩进，使用tab缩进，switch语句的case缩进级别，1表示2个空格</span></span><br><span class="line">       <span class="attr">&quot;indent&quot;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;tab&quot;</span>, &#123; <span class="attr">&quot;SwitchCase&quot;</span>: <span class="number">1</span> &#125;],</span><br><span class="line">       <span class="comment">// 引号，双引号</span></span><br><span class="line">       <span class="attr">&quot;quotes&quot;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;double&quot;</span>],</span><br><span class="line">       <span class="comment">// 在语句末尾使用分号</span></span><br><span class="line">       <span class="attr">&quot;semi&quot;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;always&quot;</span>]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="扩展extends"><a href="#扩展extends" class="headerlink" title="扩展extends"></a>扩展extends</h4><p>如果每条规则都需要团队协商配置还是比较繁琐的，在项目开始配置时，我们可以先使用一些业内已经成熟的、大家普遍遵循的编码规范（最佳实践）；我们可以通过<code>extends</code>字段传入一些规范，它接收String/Array：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:vue/essential&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@vue/prettier&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eslint-config-standard&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends可以使用以下几种类型的扩展：</p><ul><li>eslint：开头的ESLint官方扩展，有两个：<code>eslint:recommended</code>（推荐规范）和<code>eslint:all</code>（所有规范）。</li><li>plugin：开头的扩展是插件类型扩展</li><li>eslint-config：开头的来自npm包，使用时可以省略<code>eslint-config-</code>，比如上面的可以直接写成<code>standard</code></li><li>@：开头的扩展和eslint-config一样，是在npm包上面加了一层作用域scope</li></ul><blockquote><p>需要注意的是：多个扩展中有相同的规则，以后面引入的扩展中规则为准。</p></blockquote><p><code>eslint:recommended</code>推荐使用的规则在规则列表的右侧用<code>绿色√</code>标记。</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li><p>eslint在setting.json中配置和.eslintrc.js文件配置区别</p><p><a href="https://segmentfault.com/q/1010000023094556">https://segmentfault.com/q/1010000023094556</a></p><p>setting.json里面配的是vscode对eslint插件的一些配置，而.eslintrc里面配的是对代码规范的配置。目标不一样。vscode的所有配置都针对于插件或者vscode自身的。除了特别指定，这个 eslint 配置文件将会覆盖掉 vscode 的 setting.json 中 eslint 相关的配置。</p></li></ul><h5 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h5><p>它是<strong>代码格式化工具</strong>，用来做代码格式化，有了Prettier之后，它能去掉原始的代码风格，确保团队的代码使用统一相同的格式，修复规则可自定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  #让prettier使用eslint的代码格式进行校验 </span></span><br><span class="line"><span class="string">&quot;prettier.eslintIntegration&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure><p>联调规范</p><p>⽂件命名规范</p><p>代码样式规范</p><p>git flow</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git如何创建多个ssh"><a href="#git如何创建多个ssh" class="headerlink" title="git如何创建多个ssh"></a>git如何创建多个ssh</h2><h3 id="1-清除原有的设置"><a href="#1-清除原有的设置" class="headerlink" title="1.清除原有的设置"></a>1.清除原有的设置</h3><p><strong>初次使用git请跳过此步骤</strong></p><p>如果之前对git设置过global信息，则需要先清除这些信息，通过如下指令：</p><p>查看Git所有配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>查看当前用户（<strong>local</strong>）配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local  --list</span><br><span class="line">或者</span><br><span class="line">cat .git/config</span><br></pre></td></tr></table></figure><p>查看<code>user.name</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>查看<code>user.email</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p><strong>删除</strong>全局配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br></pre></td></tr></table></figure><h3 id="2-ssh配置"><a href="#2-ssh配置" class="headerlink" title="2.ssh配置"></a>2.ssh配置</h3><ol><li>配置用户信息    </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/workspace/gitlab</span><br><span class="line">git init</span><br><span class="line">git config --local user.name ‘gitlab‘//local局部 global</span><br><span class="line">git config --local user.email ‘gitlab@company.com‘</span><br></pre></td></tr></table></figure><ol start="2"><li>   生成ssh key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p> 当命令行出现 Enter file in which to save the key (~/.ssh/id_rsa):  </p><p> 它会提示你输入一个保存key的路径/文件名，默认创建文件名id_rsa（若有多个邮箱，则创建不同的文件名）</p><p> 在.ssh文件中找到创建的id_rsa_pub并复制里面的内容，在远程的设置的密钥（key）里面粘贴</p><ol start="3"><li>   配置config文件(id_rsa文件同级目录下)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#Host 它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。</span><br><span class="line">#HostName    真正连接的服务器地址</span><br><span class="line">#User是本地ssh-agent与github服务器建立SSH连接时采用的用户名，IdentityFile是对应的私钥文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ssh -T User@Host判断连接是否成功</span><br><span class="line"></span><br><span class="line"># gitlab</span><br><span class="line">Host git.lab</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User git</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_lab</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host git.hub</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">121.89.167.104</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>本地仓库与远程仓库关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin(设置的远程库名) User@Host:用户名/仓库名</span><br><span class="line">或者直接 git clone 链接(一般是master上的分支)</span><br><span class="line"></span><br><span class="line">clone https时，每次pull都会输入密码</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></li><li><p>测试连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T User@Host</span><br></pre></td></tr></table></figure></li></ol><h2 id="git-指令"><a href="#git-指令" class="headerlink" title="git 指令"></a>git 指令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>git init 初始化版本库（clone下来的不用初始化）</p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6737sZ1ptKUEQcY6YOcKFqqqdv3riaAEJYVibl3GUgmRTiaH5sldypibNN7Zzk3Zqv9lMCAAsvT4vVQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><p>首先<strong>工作区</strong>就是我们当前的文件目录，我们改完代码，用<code>git add</code>命令把当前文件加入<strong>暂存区</strong>，然后<code>git commit</code>把<strong>暂存区</strong>生成的快照提交到<strong>本地仓库</strong>，最后再用<code>git push</code>命令把<strong>本地仓库</strong>的提交复制到<strong>远程仓库</strong>，也就是<code>Github</code>之类的在线仓库。</p><p>git add  文件名                                              放入暂存区stage</p><p>git commit -m “提交的说明message”        放入分支里</p><p>git commit  -am                                            add和commit的合并，便捷写法</p><p>git commit –amend                                     尝试重新提交(<strong>漏掉了几个文件没有添加，或者提交信息commit message写错</strong>)，新增的<code>commit</code>会代替原来的<code>commit</code>的位置，而旧<code>commit</code>则被抛弃掉</p><h3 id="commit规范"><a href="#commit规范" class="headerlink" title="commit规范"></a><strong>commit规范</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feat:     A new feature</span><br><span class="line">fix:      A bug fix</span><br><span class="line">docs:     Documentation only changes</span><br><span class="line">style:    Changes that do not affect the meaning of the code</span><br><span class="line">refactor: A code change that neither fixes a bug nor adds a feature</span><br><span class="line">perf:     A code change that improves performance</span><br><span class="line">test:     Adding missing tests or correcting existing tests</span><br></pre></td></tr></table></figure><p>分支规范<a href="https://zhuanlan.zhihu.com/p/108385922">https://zhuanlan.zhihu.com/p/108385922</a></p><h3 id="本地分支的操作"><a href="#本地分支的操作" class="headerlink" title="本地分支的操作"></a>本地分支的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev 或者git switch -c dev    创建并切换该分支</span><br><span class="line">git branch dev 创建分支</span><br><span class="line">git checkout master切换分支</span><br><span class="line">git branch -d dev删除分支</span><br><span class="line">git branch -D dev强行删除一个没有合并的分支    </span><br><span class="line">git branch -vv                              查看关联关系                         </span><br><span class="line"></span><br><span class="line">git branch查看本地分支</span><br><span class="line">git branch -r    查看远程分支</span><br><span class="line">git branch -a    查看所有分支（包括远程分支和本地分支）</span><br><span class="line">git branch -a | grep paynicorn2-repay-notice 查询指定分支(本地和远程的)</span><br></pre></td></tr></table></figure><h3 id="远程分支的操作"><a href="#远程分支的操作" class="headerlink" title="远程分支的操作"></a>远程分支的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">远程分支的移除</span><br><span class="line">git remote rm paul</span><br><span class="line">git push origin --delete main</span><br><span class="line">远程分支重命名，pb 重命名为 paul</span><br><span class="line">git remote rename pb paul</span><br><span class="line">拉取远程分支到本地</span><br><span class="line">git checkout -b dev origin/dev         直接拉取远程的分支，创建为本地的分支</span><br><span class="line">推送到远程分支</span><br><span class="line">git push --set-upstream origin wangxiao 将本地的分支推送远程上（第一次推送）</span><br><span class="line">git push orgin dev  上传分支到远程dev</span><br><span class="line">为此分支创建跟踪信息，您可以执行：</span><br><span class="line">git branch --set-upstream-to=origin/&lt;分支&gt; master</span><br><span class="line">//https://blog.csdn.net/wangqingpei557/article/details/53147086</span><br><span class="line">删除远程分支，git branch -a,还是可以看到远程的分支</span><br><span class="line">解决：git remote prune origin </span><br><span class="line">//无法连接到仓库,尝试重新连接</span><br><span class="line"> git remote rm origin  删除远程origin</span><br><span class="line"> git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git</span><br></pre></td></tr></table></figure><h3 id="合并分支的操作"><a href="#合并分支的操作" class="headerlink" title="合并分支的操作"></a>合并分支的操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git rebase 分支合并本地分支</span><br><span class="line"></span><br><span class="line">git config --global pull.rebase true     这个配置就是告诉git在每次pull前先进行rebase操作</span><br><span class="line">git pull orgin 分支名   拉取远程分支并合并分支</span><br><span class="line">pull= fetch + merge</span><br><span class="line">git pull --rebase</span><br><span class="line">pull= fetch + rebase</span><br><span class="line"></span><br><span class="line">git fetch</span><br><span class="line">从远程获取最新版本到本地，不会自动合并分支</span><br><span class="line"></span><br><span class="line">git rebase --abort</span><br><span class="line">执行之后，本地内容会回到提交之间的状态，也就是回到以前提交但没有pull的状态，简单来说就是撤销rebase。</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><img src="https://img2018.cnblogs.com/blog/333765/202001/333765-20200111163049190-252688967.png" alt="img" style="zoom: 67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//查看文件状态（是否被add或者commit）</span><br><span class="line">git status   </span><br><span class="line">使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出</span><br><span class="line">//文件的区别</span><br><span class="line">git diff      区和的暂存区差异</span><br><span class="line">git diff HEAD显示工作区与当前分支最新commit之间的差异</span><br><span class="line">git diff --cached 显示暂存区和上一个commit的差异</span><br><span class="line">git diff branch-1 branch-2 [filename]比较两个分支(filename)的不同</span><br><span class="line">git diff commit1..commit2  查看两个 commit 的对比</span><br><span class="line">git ls-files查看暂存区的文件</span><br><span class="line">git diff origin/branchname..branchname 查看远程分支和本地分支的对比</span><br><span class="line"></span><br><span class="line">//查看提交日志，每一次提交都有对应的 commit id 和 commit message(看不出来被删除的commitid),可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息</span><br><span class="line">git log</span><br><span class="line">git log  -p  用来显示每次提交的内容差异</span><br><span class="line">//记录操作记录(包括已经被删除的 commit 记录和 reset 的操作)  </span><br><span class="line">git reflog  </span><br><span class="line"></span><br><span class="line">git remote -v查看关联的远程仓库url</span><br><span class="line">cat .git/HEAD    查看当前 HEAD 指向</span><br></pre></td></tr></table></figure><h3 id="回退系列"><a href="#回退系列" class="headerlink" title="回退系列"></a>回退系列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^    回退到上一个版本</span><br><span class="line">git reset --hard HEAD~1    回退到上一个版本</span><br><span class="line">git reset --hard id(前6位就行)         回退到指定版本</span><br><span class="line"></span><br><span class="line">git checkout .   清空工作区改动</span><br><span class="line">git checkout -- 文件名   </span><br><span class="line"></span><br><span class="line">当你开始修改一个文件后，还没有执行 git add命令前(此时还在工作区）,想撤销对这个文件的改动，可以使用git checkout -- 文件名 </span><br><span class="line">一旦你使用了 git add命令将文件添加到暂存区，此时不想改这个文件了，需要用git reset HEAD filename(git reset HEAD .)把文件移会到工作区，再使用第一步的git checkout -- 文件名 撤销工作区改动</span><br></pre></td></tr></table></figure><h3 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名删除文件，若误删，可以使用git checkout -- 文件名 </span><br><span class="line">rm -rf  `git status | grep app/code`</span><br><span class="line">cut 文件名 获取文件内容</span><br></pre></td></tr></table></figure><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）git stash save <span class="string">&quot;save message&quot;</span>  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span><br><span class="line"></span><br><span class="line">（2）git stash list  ：查看stash了哪些存储</span><br><span class="line"></span><br><span class="line">（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;<span class="variable">$num</span>&#125;，比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;<span class="variable">$num</span>&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span><br><span class="line"></span><br><span class="line">（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;<span class="variable">$num</span>&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; </span><br><span class="line"></span><br><span class="line">（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;<span class="variable">$num</span>&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">（7）git stash drop stash@&#123;<span class="variable">$num</span>&#125; ：丢弃stash@&#123;<span class="variable">$num</span>&#125;存储，从列表中删除这个存储</span><br><span class="line"></span><br><span class="line">（8）git stash clear ：删除所有缓存的stash</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><a href="https://www.cnblogs.com/tian874540961/p/12172900.html">https://www.cnblogs.com/tian874540961/p/12172900.html</a></p><p><a href="https://blog.csdn.net/hudashi/article/details/7664631/">https://blog.csdn.net/hudashi/article/details/7664631/</a></p><p><a href="https://www.cnblogs.com/hujunzheng/p/9732936.html">https://www.cnblogs.com/hujunzheng/p/9732936.html</a></p><img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/086ccdee-4f40-4a8c-99c8-886bc672f0d8.jpg" alt="img" style="zoom:50%;" /><p>当我开发完D后，准备push到远端master时，git会进行检查：<strong>远端master的最新节点是否是节点D的基点，即检查远端master的基点是否是节点C</strong>，如果是，则可以直接push，如果不是，也就是上图的情况：在你push之前远端master已经被他人提交了E和F节点，这时可以执行<code>git pull -r</code></p><img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/88729b51-5f43-42a5-bd69-9c39f863ab92.jpg" alt="img" style="zoom:50%;" /><p>git会以F节点作为新的基点，与D节点的代码进行融合，如果此时出现<strong>冲突</strong>，那么你就会被移到临时解冲突的分支，需要人工解冲突，解完后执行<code>git add -A</code>保存操作，再执行<code>git rebase --continue</code>继续后续操作，你可能会遗漏某一处冲突，这个完全不同担心，<code>git rebase --continue</code>会帮你检查是否解决完成，如果没有完成则不会让你回到正常分支。</p><img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/beb6433f-49e8-4b42-b821-32a7350f2cc7.jpg" alt="img" style="zoom:50%;" /><p>此时我再执行<code>git push</code>，就可以顺利将D节点提交到远端master上去了：</p><img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/469b4e16-c88d-4f71-9dde-c7eb432b7a78.jpg" alt="img" style="zoom:50%;" /><p>这同理本地基于master分支创建dev分支，master拉取远程代码后(其他人push了代码到远程master)，本地的master领先与dev分支，所以需要rebase，不然会污染了 commit 记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --edit-todo</span><br><span class="line">git rebase —abort 都可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。</span><br></pre></td></tr></table></figure><ul><li><p>合并多个提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">将第二行的 pick 改为 s “s” 为 “squash” 的缩写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pick：保留该commit（缩写:p）</span><br><span class="line">reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">exec：执行shell命令（缩写:x）</span><br><span class="line">drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure></li></ul><h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><ul><li><p>clone https时，每次pull都会输入密码<br>git config –global credential.helper store</p></li><li><p>git忽略文件权限的改变<br>git config core.filemode false</p></li><li><p>git 换行符LF与CRLF转换问题<a href="https://blog.csdn.net/qq_22978533/article/details/78145935">https://blog.csdn.net/qq_22978533/article/details/78145935</a></p><p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux/ Mac OS使用的是 LF，但 DOS/Windows 一直使用 CRLF作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#提交时转换为LF，检出时不转换</span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line">#提交检出均不转换</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">#提交检出均转换</span><br><span class="line">git config --global core.autocrlf true</span><br><span class="line"></span><br><span class="line">SafeCRLF</span><br><span class="line">#拒绝提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf true</span><br><span class="line">#允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false</span><br><span class="line">#提交包含混合换行符的文件时给出警告</span><br><span class="line">git config --global core.safecrlf warn</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>解决Git在添加ignore文件之前就提交了项目无法再过滤问题</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">首先为避免冲突需要先同步下远程仓库</span><br><span class="line">$ git pull</span><br><span class="line">在本地项目目录下删除缓存</span><br><span class="line">$ git rm -r --cached .</span><br><span class="line">新建.gitignore文件</span><br><span class="line">在项目的根目录下面新建.gitignore文件并添加相应的过滤规则</span><br><span class="line"></span><br><span class="line">再次add所有文件</span><br><span class="line">输入以下命令，再次将项目中所有文件添加到本地仓库缓存中</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">再次添加commit</span><br><span class="line">这次commit是为了说明添加ignore文件的。</span><br><span class="line">$ git commit -m <span class="string">&quot;add ignore&quot;</span>  </span><br><span class="line">最后提交到远程仓库即可</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure></li><li><p>fatal: 当前分支 master 没有对应的上游分支。<br>为推送当前分支并建立与远程上游的跟踪，使用</p><pre><code>git push --set-upstream origin master</code></pre></li><li><p>无法连接到仓库,尝试重新连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin  删除远程origin</span><br><span class="line">git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git</span><br></pre></td></tr></table></figure></li><li><p>```<br>git config –global core.editor vim </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># npm</span><br><span class="line"></span><br><span class="line">## 下载</span><br><span class="line"></span><br><span class="line">**解决npm下载慢的问题**</span><br><span class="line"></span><br><span class="line">方法一：使用淘宝定制的cnpm命令行工具替代默认安装npm</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法二：将npm默认的下载地址修改为淘宝镜像</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意，如果将来你需要发布自己的软件包时，需要将registry字段的值修改回来</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**npm-check**</span><br><span class="line"></span><br><span class="line">[npm-check](https://link.zhihu.com/?target=https%3A//link.jianshu.com/%3Ft%3Dhttps%3A//www.npmjs.com/package/npm-check)是用来检查npm依赖包是否有更新，错误以及不在使用的，我们也可以使用npm-check进行包的更新</span><br><span class="line"></span><br><span class="line">安装npm-check：</span><br><span class="line"></span><br><span class="line">&gt; npm install -g npm-check</span><br><span class="line"></span><br><span class="line">检查npm包的状态:</span><br><span class="line"></span><br><span class="line">&gt; npm-check -u -g</span><br><span class="line"></span><br><span class="line">**升级依赖**</span><br><span class="line"></span><br><span class="line">&gt; npm install -g npm-check-updates</span><br><span class="line">&gt;</span><br><span class="line">&gt; ncu -u</span><br><span class="line"></span><br><span class="line">**查找未使用的npm包**</span><br><span class="line"></span><br><span class="line">&gt; npm install -g depcheck</span><br><span class="line">&gt;</span><br><span class="line">&gt; depcheck</span><br><span class="line"></span><br><span class="line">## 插件</span><br><span class="line"></span><br><span class="line">- 将DOM转化成canvas对象</span><br><span class="line"></span><br><span class="line">  http://html2canvas.hertzen.com/dist/html2canvas.min.js</span><br><span class="line"></span><br><span class="line">- 将canvas生成照片</span><br><span class="line"></span><br><span class="line">  HTTP://github.com/randreucetti/canvas2image</span><br><span class="line"></span><br><span class="line">- 一个用于将文本复制到剪贴板的 JS 库</span><br><span class="line"></span><br><span class="line">  https://github.com/zenorocha/clipboard.js</span><br><span class="line">  </span><br><span class="line">- React 中保存页面状态/在react中实现vue的**keep-alive**/**React Activation**</span><br><span class="line"></span><br><span class="line">- pubsub利用JavaScript进行发布/订阅的库</span><br><span class="line"></span><br><span class="line">- moment时间处理：http://momentjs.cn/</span><br><span class="line"></span><br><span class="line">- QRCode:生成二维码https://www.npmjs.com/package/qrcode#api</span><br><span class="line"></span><br><span class="line">  https://zh.qr-code-generator.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>QRCode.toDataURL(url.basePage + “/common/share/#/homeshare”)<br>.then(url =&gt; {<br>this.qrcodeImg = url<br>})<br>.catch(err =&gt; {<br>console.error(err);<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### vue</span><br><span class="line"></span><br><span class="line">- vue-ls:用于从Vue上下文中使用本地Storage，会话Storage和内存Storage</span><br><span class="line">- register-service-worker</span><br><span class="line"></span><br><span class="line">#### 特效</span><br><span class="line"></span><br><span class="line">- vue-seamless-scroll:循环滚动列表</span><br><span class="line">- https://svga.io/index.html：展示动态图片</span><br><span class="line"></span><br><span class="line">### react</span><br><span class="line"></span><br><span class="line">- `array-move` 就一个 API，它的主要作用就是**用来交换数组中元素的位置**。我们用 node 进行调试 </span><br><span class="line"></span><br><span class="line">  ```jsx</span><br><span class="line">  // 引包</span><br><span class="line">  const arrayMove = require(&#x27;array-move&#x27;);</span><br><span class="line">  // 创建一个数组</span><br><span class="line">  const input = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">   </span><br><span class="line">  // 以下三个排序实例</span><br><span class="line">  console.log(arrayMove(input, 1, 2));</span><br><span class="line">  //=&gt; [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">   </span><br><span class="line">  console.log(arrayMove(input, -1, 0));</span><br><span class="line">  //=&gt; [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">   </span><br><span class="line">  console.log(arrayMove(input, -2, -3));</span><br><span class="line">  //=&gt; [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>拖拽react-sortable-hoc</p><p>高阶函数（Higher Order Function）=&gt; 参数或返回值为函数组件</p><p><code>react-sortable-hoc</code> 提供了两个特别重要的 API ，分别是<code>SortableContainer 和 SortableElement</code> 看英文的意思也知道，<code>SortableElement</code>用来装饰每个要拖拽的组件，相对于<code>SortableContainer</code> 要装饰的组件，<code>SortableElement</code> 装饰的组件是子组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SortableItem = SortableElement(<span class="function">(<span class="params">props: any</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"><span class="keyword">const</span> SortableList1 = SortableContainer(<span class="function">(<span class="params">&#123; items &#125;: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;items.map((item: any, index: number) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">SortableItem</span> <span class="attr">key</span>=<span class="string">&#123;</span>`<span class="attr">item-</span>$&#123;<span class="attr">item</span>&#125;<span class="attr">-</span>$&#123;<span class="attr">index</span>&#125;`&#125; <span class="attr">index</span>=<span class="string">&#123;index&#125;</span> <span class="attr">value</span>=<span class="string">&#123;item&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">RuleOne</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            &gt;</span><span class="tag">&lt;/<span class="name">RuleOne</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">SortableItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">SortableList1</span> <span class="attr">items</span>=<span class="string">&#123;submitData[</span>&#x27;<span class="attr">rule1</span>&#x27;]<span class="attr">.ruleGroup</span>&#125; <span class="attr">useDragHandle</span> <span class="attr">disableAutoscroll</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onSortEnd</span>=<span class="string">&#123;(&#123;</span> <span class="attr">oldIndex</span>, <span class="attr">newIndex</span> &#125;<span class="attr">:</span> <span class="attr">any</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">                  if (oldIndex !== newIndex) &#123;</span></span><br><span class="line"><span class="xml">                    saveRules(submitData, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">                      submitData[&#x27;rule1&#x27;].ruleGroup =  arrayMoveImmutable(submitData[&#x27;rule1&#x27;].ruleGroup, oldIndex, newIndex)</span></span><br><span class="line"><span class="xml">                    &#125;)</span></span><br><span class="line"><span class="xml">                  &#125;</span></span><br><span class="line"><span class="xml">                &#125;&#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.env.VUE_APP_API_BASE_URL, <span class="comment">// api base_url</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">6000</span> <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">service.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> handleParams(config)</span><br><span class="line">&#125;, err)</span><br><span class="line"><span class="keyword">let</span> showLoading = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleParams</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!showLoading) &#123;</span><br><span class="line">    showLoading = Toast.loading(&#123;</span><br><span class="line">      <span class="attr">duration</span>: <span class="number">0</span>, <span class="comment">// 持续展示 toast</span></span><br><span class="line">      <span class="attr">forbidClick</span>: <span class="literal">true</span>, <span class="comment">// 是否禁止点击背景</span></span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;加载中&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对请求错误做些什么</span></span><br><span class="line"><span class="keyword">const</span> err = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = error.response.data</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">403</span>) &#123;</span><br><span class="line">      failToast(<span class="string">&#x27;Forbidden&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !(data.result &amp;&amp; data.result.isLogin)) &#123;</span><br><span class="line">      failToast(<span class="string">&#x27;Unauthorized&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求超时状态</span></span><br><span class="line">    <span class="keyword">if</span> (error.message.includes(<span class="string">&#x27;timeout&#x27;</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;超时了&#x27;</span>)</span><br><span class="line">      failToast(<span class="string">&#x27;请求超时，请检查网络是否连接正常&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 可以展示断网组件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;断网了&#x27;</span>)</span><br><span class="line">      failToast(<span class="string">&#x27;请求失败，请检查网络是否已连接&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  showLoading &amp;&amp; showLoading.clear()</span><br><span class="line">  showLoading = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">service.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> handleParams(config)</span><br><span class="line">&#125;, err)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">//封装请求方式</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">url, params = &#123;&#125;, method = <span class="string">&#x27;post&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>].includes(method) ? axios(&#123;url, method, <span class="attr">data</span>: params&#125;) : axios(&#123;url, method, params&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">//发请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">respondSurvey</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(api_share.respondSurvey, params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查看当前项目安装过的依赖模块<br>npm list –depth 0</p><p>查看全局安装过的依赖模块<br>npm list -g –depth 0</p><p>清理缓存命令：</p><ul><li>局部</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><ul><li><p>全局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.npm</span><br><span class="line">du -sh * </span><br><span class="line">rm -rf _cacache   </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目构建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> git </tag>
            
            <tag> npm </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react技术栈</title>
      <link href="/2020/09/25/react/"/>
      <url>/2020/09/25/react/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="react源码"><a href="#react源码" class="headerlink" title="react源码"></a>react源码</h1><p><a href="http://t.kuick.cn/ZSM8">http://t.kuick.cn/ZSM8</a></p><p><a href="https://learn.kaikeba.com/video/405193">https://learn.kaikeba.com/video/405193</a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>前端主流框架 vue 和 react 中都使用了虚拟DOM（virtual DOM）技术，因为渲染真实DOM的开销是很大的，性能代价昂贵，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，而我们只需要更新修改过的那一小块dom而不要更新整个dom，这时使用diff算法能够帮助我们</p><p><strong>DOM</strong></p><p>DOM全称<code>文档对象模型</code>，本质也是一个JS对象。每操作一次DOM都会对页面进行重新渲染，且新生成一颗DOM树。</p><p>DOM的本质： 浏览器中的概念，用js对象来表示页面上的元素，并提供操作DOM对象的API</p><p><strong>VDOM</strong></p><p>虚拟dom，通过JS模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。</p><p>vdom的本质:是框架中的概念，是程序员用js对象来模拟页面上的DOM和DOM 的嵌套</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进⾏操作。⽽复杂或频繁的DOM操作通常是性能瓶颈产⽣的原因</p><p>React为此引⼊了虚拟DOM（Virtual DOM）的机制：在浏览器端⽤Javascript实现了⼀套DOM API。基于React进⾏开发时所有的DOM构造都是通过虚拟DOM进⾏，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上⼀次的DOM树进⾏对⽐，得到DOM结构的区别，然后仅仅将需要变化的部分进⾏实际的浏览器DOM更新。⽽且React能够批处理虚拟DOM的刷新，在⼀个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后⼜从B变成A UI不发⽣任何变化，⽽如果通过⼿动控制，这种逻辑通常是极其复杂的。尽管<strong>每⼀次都需要构造完整的虚拟DOM树</strong>，但是因为虚拟DOM是内存数据，性能是极⾼的。这样，在保证性能的同时，开发者将不<br>再需要关注某个数据的变化如何更新到⼀个或多个具体的DOM元素，⽽只需要关⼼在任意⼀个数据状态下，整个界⾯是如何Render的。</p><p><strong>diff策略</strong></p><p>React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度</p><ul><li><p>策略一（tree diff）：新旧DOM树，逐层对比的方式<br>DOM节点跨层级的移动操作特别少，可以忽略不计。</p><p><img src="https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg" alt="img"></p><p><a href="https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg">https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg</a></p><p>只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。</p><p>当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。</p><p>这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p></li><li><p>策略二（component diff）：<br>拥有相同类的两个组件生成相似的树形结构， 拥有不同类的两个组件 生成不同的树形结构。</p></li><li><p>策略三（element diff）：<br>对于同一层级的一组子节点，通过唯一id区分。</p></li></ul><h3 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h3><ol><li><p>为什么需要fiber</p><p>对于大型项目，组件树会很大，这个时候递归遍历的成本就会很高，会造成主线程被持续占用，结果就是主线程上的布局，动画等周期性任务无法立即得到处理，造成视觉上的卡顿，影响用户体验。</p><p><strong>fiber就是链表结构的虚拟Dom</strong></p></li><li><p>在react 16之后发布的⼀种react 核⼼算法，React Fiber是对核⼼算法的⼀次重新实现(官⽹说法)。之前⽤的是diff算法。在之前React中，<strong>更新过程是同步的</strong>，这可能会导致性能问题。当React决定要加载或者更新组件树时，会做很多事，⽐如调⽤各个组件的⽣命周期函数，计算和⽐对Virtual DOM，最后更新DOM树，这整个过程是同步进⾏的，也就是说只要⼀个加载或者更新过程开始，中途不会中断。<strong>因为JavaScript单线程的特点，如果组件树很⼤的时候，每个同步任务耗时太⻓，就会出现卡顿。</strong><br>React Fiber的⽅法其实很简单——分⽚。把⼀个耗时⻓的任务分成很多⼩⽚，每⼀个⼩⽚的运⾏时间很短，<strong>虽然总时间依然很⻓，但是在每个⼩⽚执⾏完之后，都给其他任务⼀个执⾏的机会，</strong>这样唯⼀的线程就不会被独占，其他任务依然有运⾏的机会。</p></li></ol><h1 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h1><ol><li>虚拟DOM<br>之前操作dom的⽅式是通过document.getElementById()的⽅式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进⾏操作<br>⽽reactjs定义了⼀套变量形式的dom模型，⼀切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的⾼，和主流MVC框架有本质的区别，并不和dom打交道</li><li>组件系统<br>react最核⼼的思想是将⻚⾯中任何⼀个区域或者元素都可以看做⼀个组件 component<br>那么什么是组件呢？<br>组件指的就是同时包含了html、css、js、image元素的聚合体<br>使⽤react开发的核⼼就是将⻚⾯拆分成若⼲个组件，并且react⼀个组件中同时耦合了css、js、<br>image，这种模式整个颠覆了过去的传统的⽅式</li><li>单向数据流<br>其实reactjs的核⼼内容就是数据绑定，所谓数据绑定指的是只要将⼀些服务端的数据和前端⻚⾯绑定<br>好，开发者只关注实现业务就⾏了</li><li>JSX 语法<br>在vue中，我们使⽤render函数来构建组件的dom结构性能较⾼，因为省去了查找和编译模板的过程，<br>但是在render中利⽤createElement创建结构的时候代码可读性较低，较为复杂，此时可以利⽤jsx语法<br>来在render中创建dom，解决这个问题，但是前提是需要使⽤⼯具来编译jsx</li></ol><h1 id="react项目搭建"><a href="#react项目搭建" class="headerlink" title="react项目搭建"></a>react项目搭建</h1><h2 id="脚⼿架create-react-app"><a href="#脚⼿架create-react-app" class="headerlink" title="脚⼿架create-react-app"></a>脚⼿架create-react-app</h2><p>全局安装create-react-app</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>创建⼀个项⽬</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app your-app 注意命名⽅式</span><br><span class="line"><span class="built_in">cd</span>  your-app</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><p> react 这个包，是专门用来创建React组件、组件生命周期等这些东西的；<br> react-dom 里面主要封装了和 DOM 操作相关的包，要把组件渲染到页面上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>要使用 JSX 语法，必须先运行 <code>cnpm i babel-preset-react -D</code>，然后再 <code>.babelrc</code> 中添加 语法配置；</p><h3 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a><strong>Mobx</strong></h3><p>作为了解的内容，在项⽬中使⽤redux的情况更多。</p><p>Mobx是⼀个功能强⼤，上⼿⾮常容易的状态管理⼯具。redux的作者也曾经向⼤家推荐过它，在不少情况下可以使⽤Mobx来替代掉redux。</p><h3 id="PropType"><a href="#PropType" class="headerlink" title="PropType"></a>PropType</h3><p>PropTypes 进行类型检查,可用于确保组件接收到的props数据类型是有效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UserDisplay.propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">    address: PropTypes.objectOf(PropTypes.string),</span><br><span class="line">    age: PropTypes.number.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS-in-JS"></a>CSS-in-JS</h3><p>CSS-in-JS就是<strong>将应用的CSS样式写在JavaScript文件里面</strong>，而不是独立为一些<code>.css</code>，<code>.scss</code>或者<code>less</code>之类的文件，这样你就可以在CSS中使用一些属于JS的诸如模块声明，变量定义，函数调用和条件判断等语言特性来提供灵活的可扩展的样式定义。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 用 npm 安装</span><br><span class="line">npm install @material-ui/styles</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; makeStyles &#125; <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/styles&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/Button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStyles = makeStyles(&#123;</span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)&#x27;</span>,</span><br><span class="line">    <span class="attr">border</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">borderRadius</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">boxShadow</span>: <span class="string">&#x27;0 3px 5px 2px rgba(255, 105, 135, .3)&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="string">&#x27;0 30px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Hook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> classes = useStyles();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span>&gt;</span>Hook<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; styled &#125; <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/styles&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/Button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyButton = styled(Button)(&#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="string">&#x27;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)&#x27;</span>,</span><br><span class="line">  <span class="attr">border</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">borderRadius</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">boxShadow</span>: <span class="string">&#x27;0 3px 5px 2px rgba(255, 105, 135, .3)&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">48</span>,</span><br><span class="line">  <span class="attr">padding</span>: <span class="string">&#x27;0 30px&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StyledComponents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>Styled Components<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useStyles = makeStyles(&#123;</span><br><span class="line">  <span class="comment">// style rule</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="params">props</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: props.backgroundColor,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">bar</span>: &#123;</span><br><span class="line">    <span class="comment">// CSS property</span></span><br><span class="line">    <span class="attr">color</span>: <span class="function"><span class="params">props</span> =&gt;</span> props.color,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了示例，我们模拟了这个属性</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123; <span class="attr">backgroundColor</span>: <span class="string">&#x27;black&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span> &#125;;</span><br><span class="line">  <span class="comment">// 将 props 作为 useStyles() 的第一个属性传入</span></span><br><span class="line">  <span class="keyword">const</span> classes = useStyles(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">classes.foo</span>&#125; $&#123;<span class="attr">classes.bar</span>&#125;`&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式动画库"><a href="#样式动画库" class="headerlink" title="样式动画库"></a>样式动画库</h3><p><a href="https://zhuanlan.zhihu.com/p/361065034">https://zhuanlan.zhihu.com/p/361065034</a></p><ul><li><a href="https://react-spring.io/basics">https://react-spring.io/basics</a></li><li><a href="https://reactcommunity.org/react-transition-group/">https://reactcommunity.org/react-transition-group/</a></li><li><a href="https://motion.ant.design/components/tween-one-cn">https://motion.ant.design/components/tween-one-cn</a></li><li><a href="http://textillate.js.org/">http://textillate.js.org/</a></li><li><a href="http://react-animations.herokuapp.com/">http://react-animations.herokuapp.com/</a></li><li><a href="https://www.framer.com/docs/">https://www.framer.com/docs/</a></li></ul><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>全局定义将组件App放置在<code>id=&#39;App&#39;</code>的容器里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDom from &#x27;react-dom&#x27;</span><br><span class="line">import App from &#x27;./app.jsx&#x27;</span><br><span class="line">// ReactDOM.render(&#x27;要渲染的虚拟DOM元素&#x27;, &#x27;要渲染到页面上的哪个位置中&#x27;)</span><br><span class="line">// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 &quot;#app&quot; 这样的字符串，而是需要传递一个 原生的 DOM 对象</span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App/&gt;,</span><br><span class="line">    document.getElementById(&#x27;App&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="APP-jsx"><a href="#APP-jsx" class="headerlink" title="APP.jsx"></a>APP.jsx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素</span><br><span class="line">// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数</span><br><span class="line">// 参数1： 是个字符串类型的参数，表示要创建的元素类型</span><br><span class="line">// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性</span><br><span class="line">// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点</span><br><span class="line"> var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;, myH1)</span><br><span class="line">//&lt;div title=&quot;this is a div&quot; id=&quot;mydiv&quot;&gt;这是一个div&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// 由于，React官方，发现，如果直接让用户手写 JS 代码创建元素，用户会疯掉的，然后，用户就开始寻找新的前端框架了，于是，React 官方，就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构；</span><br><span class="line">// 问题： JSX（符合 XML 规范的 JS 语法）的原理是什么？</span><br><span class="line">// JSX内部在运行的时候，也是先把 类似于HTML 这样的标签代码，转换为了 React.createElement 的形式；（JSX是一个对程序员友好的语法糖）</span><br><span class="line">//在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // 在React中，构造函数，就是一个最基本的组件</span><br><span class="line">// 如果想要把组件放到页面中，可以把 构造函数的名称，当作 组件的名称，以 HTML标签形式引入页面中即可</span><br><span class="line">// 注意：React在解析所有的标签的时候，是以标签的首字母来区分的，如果标签的首字母是小写，那么就按照 普通的 HTML 标签来解析，如果 首字母是大写，则按照 组件的形式去解析渲染</span><br><span class="line">// 结论：组件的首字母必须是大写</span><br><span class="line">export default function Hello(props) &#123;</span><br><span class="line">  // 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span><br><span class="line">  // 通过 props 得到的任何数据都是只读的，不能从新赋值</span><br><span class="line">  return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是在Hello组件中定义的元素 --- &#123;props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><ul><li><h5 id="组件生命周期分为三部分："><a href="#组件生命周期分为三部分：" class="headerlink" title="组件生命周期分为三部分："></a>组件生命周期分为三部分：</h5><ul><li><strong>组件初始化阶段</strong>：组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次；<ul><li>constructor(props)<br>React组件的构造函数在挂载之前被调⽤。在实现 React.Component 构造函数时，需要先在添加其他内容前，调⽤ super(props) ，⽤来将⽗组件传来的 props 绑定到这个类中，使⽤ this.props 将会得到。</li><li>componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOM。无法获取到页面上的 任何元素，因为虚拟DOM 和 页面 都还没有开始渲染呢。<strong>通常在这⾥进⾏ajax请求</strong></li><li>render：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了，但是，页面上尚未真正显示DOM元素</li><li>componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入都了 运行中 的状态</li></ul></li></ul><ul><li><strong>组件更新阶段</strong>：也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次；<ul><li>componentWillReceiveProps:<br>组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；<br>如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值<br>// 如果想要获取最新的属性值，需要通过 componentWillReceiveProps 的参数列表来获取<br>componentWillReceiveProps(nextProps){    console.log(this.props.pmsg + ‘ —- ‘ + nextProps.pmsg);}</li><li>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的</li><li>componentWillUpdate: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的，页面上的 DOM 元素 也是旧的</li><li>render: 此时，又要重新根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的</li><li>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</li></ul></li><li><strong>组件销毁阶段</strong>：也有一个显著的特点，一辈子只执行一次</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</span><br></pre></td></tr></table></figure> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb3cd2923f04e4c8dc58243522ff666~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></li></ul><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="状态组件"><a href="#状态组件" class="headerlink" title="状态组件"></a>状态组件</h3><h4 id="状态组件对比"><a href="#状态组件对比" class="headerlink" title="状态组件对比"></a>状态组件对比</h4><p>使用 function 构造函数创建的组件，内部没有 state 私有数据，只有一个props来接收外界传递过来的数据；<br>使用 class 关键字 创建的组件，内部，除了有 this.props 这个只读属性之外，还有一个 专门用于 存放自己私有数据的 this.state 属性，这个 state 是可读可写的！<br>基于上面的区别：我们可以为这两种创建组件的方式，下定义了： 使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】<br>有状态组件和无状态组件，最本质的区别，就是有无 state 属性；同时， class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数；<br>问题来了：什么时候使用 有状态组件，什么时候使用无状态组件呢？？？</p><ol><li>如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件；</li><li>如果一个组件，只需要根据外界传递过来的 props，渲染固定的 页面结构就完事儿了，此时，非常适合使用 function 创建出来的 无状态组件；（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一丢丢）</li></ol><h4 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h4><p><strong>用class关键字创建出来的组件：“有状态组件”</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 class 创建的类，通过 extends 关键字，继承了 React.Component 之后，这个类，就是一个组件的模板了</span></span><br><span class="line"><span class="comment">// 如果想要引用这个组件，可以把 类的名称， 以标签形式，导入到 JSX 中使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意： 如果使用 extends 实现了继承，那么在 constructor 的第一行，一定要显示调用一下 super()</span></span><br><span class="line">    <span class="comment">//  super() 表示父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="comment">// 在 constructor 中，如果想要访问 props 属性，不能直接使用 this.props， 而是需要在 constructor 的构造器参数列表中，显示的定义 props 参数来接收，才能正常使用；</span></span><br><span class="line">    <span class="comment">// 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data()&#123; return &#123;&#125; &#125; 函数  </span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;这是 Hello2 组件的私有msg数据&#x27;</span>,</span><br><span class="line">      <span class="attr">info</span>: <span class="string">&#x27;瓦塔西***&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存信息1： No `render` method found on the returned component instance: you may have forgotten to define `render`.</span></span><br><span class="line">  <span class="comment">// 通过分析以上报错，发现，提示我们说，在 class 实现的组件内部，必须定义一个 render 函数</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 报错信息2： Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.</span></span><br><span class="line">    <span class="comment">// 通过分析以上报错，发现，在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然在 React dev tools 中，并没有显示说 class 组件中的 props 是只读的，但是，经过测试得知，其实 只要是 组件的 props，都是只读的；</span></span><br><span class="line">    <span class="comment">// this.props.address = &#x27;123&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是 使用 class 类创建的组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>外界传递过来的数据是： &#123;this.props.address&#125; --- &#123;this.props.info&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      //React中，提供的事件绑定机制，使用的 都是驼峰命名</span></span><br><span class="line"><span class="xml">      //     在为 React 事件绑定 处理函数的时候，需要通过 this.函数名， 来把 函数的引用交给 事件 </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改 msg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnChangeMsg&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeMsg = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意： 这里不是传统网页，所以 React 已经帮我们规定死了，在 方法中，默认this 指向 undefined，并不是指向方法的调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 this.state.msg = &#x27;123&#x27; 为 state 上的数据重新赋值，可以修改 state 中的数据值，但是，页面不会被更新；</span></span><br><span class="line">    <span class="comment">// 所以这种方式，React 不推荐，以后尽量少用；</span></span><br><span class="line">    <span class="comment">// 如果要为 this.state 上的数据重新赋值，那么，React 推荐使用 this.setState(&#123;配置对象&#125;) 来重新为 state 赋值</span></span><br><span class="line">    <span class="comment">// 注意： this.setState 方法，只会重新覆盖那些 显示定义的属性值，如果没有提供最全的属性，则没有提供的属性值，不会被覆盖；</span></span><br><span class="line">    <span class="comment">/* this.setState(&#123;</span></span><br><span class="line"><span class="comment">      msg: &#x27;123&#x27;</span></span><br><span class="line"><span class="comment">    &#125;) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.setState 方法，也支持传递一个 function，如果传递的是 function，则在 function 内部，必须return 一个 对象；</span></span><br><span class="line">    <span class="comment">// 在 function 的参数中，支持传递两个参数，其中，第一个参数是 prevState，表示为修改之前的 老的 state 数据</span></span><br><span class="line">    <span class="comment">// 第二个参数，是 外界传递给当前组件的 props 数据</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span> (<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 由于 this.setState 是异步执行的，所以，如果想要立即拿到最新的修改结果，最保险的方式， 在回调函数中去操作最新的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.msg)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数或无状态组件是一个纯函数，它可接受接受参数，并返回react元素。这些都是没有任何副作用的纯函数。这些组件没有状态或生命周期方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件的首字母必须是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span></span><br><span class="line">  <span class="comment">// 通过 props 得到的任何数据都是只读的，不能从新赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是在Hello组件中定义的元素 --- &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p><a href="https://blog.csdn.net/deng1456694385/article/details/88746797">https://blog.csdn.net/deng1456694385/article/details/88746797</a></p><p><code>Component</code>在 <code>state</code>改变,<code>props</code>改变,调用<code>this.setState(&#123;...&#125;)</code>的时候都会进行渲染</p><pre><code>class demo extent Component &#123;    state = &#123;        name: &#39;&#39;    &#125;componentDidMount() &#123;    this.setState(&#123;name: &#39;&#39;&#125;)&#125;render() &#123;    console.log(&#39;render&#39;)    return &lt;div&gt;haha&lt;/div&gt;&#125;&#125;</code></pre><p>上面的组件会在<code>this.setState</code>调用后就会重新传染一次,但是我们可以看出<code>name</code>状态并没有没被我们用到,也没有改变,这种渲染就是无效渲染,所以为了优化我们通常会使用钩子函数<code>shouldComponentUpdate</code>来做一些逻辑判断,来确定是否要重新<code>render</code>一次</p><pre><code>class demo extent Component &#123;    state = &#123;        name: &#39;&#39;    &#125;componentDidMount() &#123;    this.setState(&#123;name: &#39;&#39;&#125;)&#125;shouldComponentUpdate(nextProps,nextState) &#123;    if(this.state.name === nextState.name) &#123;        return false    &#125;else &#123;        return true    &#125;&#125;render() &#123;    console.log(&#39;render&#39;)    return &lt;div&gt;haha&lt;/div&gt;&#125;</code></pre><p>这样就可以避免无效渲染,优化性能,但是如果这种判断逻辑多到一定程度,光判断逻辑就很复杂,而且每次都要判断也会影响性能,所以才有了 <code>PureComponent</code></p><p><strong><code>PureComponent</code>的区别在于相当于自己写了一个<code>shouldComponentUpdate</code>钩子函数处理, 对<code>props</code>和<code>state</code>进行浅比较,所谓浅比较就是之比较内部第一层的各个属性的值是否相同,像对象和数组这种数据类型,如果只改变内部的元素,就不会造成渲染</strong></p><p><strong>Component vs PureComponent 总结</strong><br>PureComponent相较于Component区别就是,对props和state默认进行判断来确定是否渲染,从而减少无效渲染次数. 大部分情况下直接用PureComponent比较好可以提高性能,但是如果遇到需要频繁修改值重新渲染的组件,用Component比较好,因为PureComponent频繁的判断也会影响性能.</p><h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p>其实这个和PureComponent功能是一样的，只不过memo是提供给函数组件使用的，而PureComponent是提供给class组件使用的，还有一点就是memo提供一个参数可以让我们自行配置可以对引用数据做比较然后触发render</p><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>无论是函数组件还是类组件，return 的 React 元素的语法必须是由一个标签包裹起来的所有虚拟 DOM 内容</p><p>一种是使用一个 div 标签将其包裹起来，另外一种方式就是使用 React 提供的 <code>&lt;React.Fragment&gt;</code> 将其包裹起来。但是我们不期望，增加额外的<code>dom</code>节点，所以<code>react</code>提供<code>Fragment</code>碎片概念，能够让一个组件返回多个元素。</p><ul><li><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p></li><li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 HTML：</span><br><span class="line">&lt;button onclick=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">React 中略微不同：</span><br><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p><p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p><p>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick=&#123;this.handleClick&#125;</code>，你应该为这个方法绑定 <code>this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1.</span>bind</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的   </span></span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>箭头函数</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在 JSX 中嵌入表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;unreadMessages.length &gt; 0 &amp;&amp;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        You have &#123;unreadMessages.length&#125; unread messages.</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>阻止组件渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return null;</span><br></pre></td></tr></table></figure></li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>适用于父子组件通信</p><h4 id="父组件-gt-子组件"><a href="#父组件-gt-子组件" class="headerlink" title="父组件-&gt;子组件"></a>父组件-&gt;子组件</h4><p>父组件将需要传递的参数通过<code>key=&#123;xxx&#125;</code>方式传递至子组件，子组件通过<code>this.props.key</code>获取参数.</p><h4 id="子组件-gt-父组件"><a href="#子组件-gt-父组件" class="headerlink" title="子组件-&gt;父组件"></a>子组件-&gt;父组件</h4><p>利用 props callback 通信，父组件传递一个 callback 到子组件，当事件触发时将参数放置到 callback 带回给父组件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import Son from &#x27;./son&#x27;</span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: &#x27;&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  callback = (value) =&gt; &#123;</span><br><span class="line">    // 此处的value便是子组件带回</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      info: value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.info&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Son callback=&#123;this.callback&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Father</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  callback: (string) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line">class Son extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleChange = this.handleChange.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    // 在此处将参数带回</span><br><span class="line">    this.props.callback(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&#x27;text&#x27; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Son</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="在类组件中传递"><a href="#在类组件中传递" class="headerlink" title="在类组件中传递"></a>在类组件中传递</h4><p>适用于跨层级组件之间通信</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; Consumer, Provider &#125; = React.createContext(<span class="literal">null</span>) <span class="comment">//创建 context 并暴露Consumer和Provide</span></span><br><span class="line"><span class="keyword">export</span> &#123; Consumer, Provider &#125;</span><br><span class="line"><span class="comment">//Father</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./son&#x27;</span></span><br><span class="line">&lt;Provider value=&#123;<span class="built_in">this</span>.state.info&#125;&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line"><span class="comment">//Son</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> GrandSon <span class="keyword">from</span> <span class="string">&#x27;./grandson&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">&#123;<span class="function">(<span class="params">info</span>) =&gt;</span> (</span><br><span class="line"><span class="comment">// 通过Consumer直接获取父组件的值</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件的值:&#123;info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">GrandSon</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure><h4 id="在函数组件中传递"><a href="#在函数组件中传递" class="headerlink" title="在函数组件中传递"></a>在函数组件中传递</h4><p>使用useContext</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>react的核心思想是虚拟DOM。react包含了生成虚拟DOM的函数react.createElement，及Component类。而react-dom包的核心功能就是把这些虚拟DOM渲染到文档中变成实际DOM。</p><h3 id="通过原生JS获取Dom去操作"><a href="#通过原生JS获取Dom去操作" class="headerlink" title="通过原生JS获取Dom去操作"></a>通过原生JS获取Dom去操作</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义获取Dom的函数</span></span><br><span class="line">    <span class="function"><span class="title">handleGetDom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#title&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(title);</span><br><span class="line">        title.style.background = <span class="string">&#x27;skyblue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>测试节点<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleGetDom&#125;</span>&gt;</span>点击操作Dom<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a><strong>Refs</strong></h3><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><p><strong>支持在函数组件和类组件内部使用</strong></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h5><p>1.管理焦点，文本选择或媒体播放。<br>2.触发强制动画。<br>3.集成第三方 DOM 库。</p><h5 id="Refs-API使用"><a href="#Refs-API使用" class="headerlink" title="Refs API使用"></a>Refs API使用</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="comment">//分配给实例属性</span></span><br><span class="line">        <span class="built_in">this</span>.inputRef = React.createRef(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//通过 this.inputRef.current 获取对该节点的引用</span></span><br><span class="line">        <span class="built_in">this</span>.inputRef &amp;&amp; <span class="built_in">this</span>.inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//把 &lt;input&gt; ref 关联到构造函数中创建的 `inputRef` 上</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ref 的值根据节点的类型而有所不同：</strong></p><p>一、当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收<strong>底层 DOM 元素</strong>作为其 current 属性。</p><p>二、当 ref 属性用于自定义 class 组件时，ref 对象接收组件的<strong>挂载实例</strong>作为其 current 属性。</p><p>三、<strong>你不能将ref属性用于函数式组件上，因为他们并没有实例（instance）！</strong></p><p>但是，你可以在函数式组件中使用ref属性，就像你引用DOM元素和类组件一样。</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p><strong>只能在函数组件中使用</strong></p><blockquote><p>区别：<a href="https://zhuanlan.zhihu.com/p/105276393">https://zhuanlan.zhihu.com/p/105276393</a></p><p>useRef 用法类似于React.createRef()，区别：</p><p><strong>createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</strong><code>useRef</code> 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>。useRef 不仅仅是用来管理 DOM ref 的，它还相当于 this , 可以存放任何变量。useRef 可以很好的解决闭包带来的不方便性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &quot;react&quot;;</span><br><span class="line">export default function UseRefHookExample() &#123;</span><br><span class="line">  let inputRef = useRef(null);</span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      使用 useRef() hook:</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Click</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h4><blockquote><p>支持在函数组件和类组件内部使用</p></blockquote><p><code>React</code> 支持 <code>回调 refs</code> 的方式设置 Refs。这种方式可以帮助我们更精细的控制何时 Refs 被设置和解除。</p><p>使用 <code>回调 refs</code> 需要将回调函数传递给 <code>React元素</code> 的 <code>ref</code> 属性。这个函数接受 React 组件实例 或 HTML DOM 元素作为参数，将其挂载到实例属性上，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.inputRef = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.setTextInputRef = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.inputRef = ele;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inputRef &amp;&amp; <span class="built_in">this</span>.inputRef.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>React 会在组件挂载时，调用 <code>ref</code> 回调函数并传入 DOM元素(或React实例)，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 Refs 一定是最新的。</p><blockquote><p>可以在组件间传递回调形式的 refs.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//ref 即是 MyInput 中的 input 节点</span></span><br><span class="line">    ref.focus();</span><br><span class="line">  &#125;, [ref]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">inputRef</span>=<span class="string">&#123;(ele)</span> =&gt;</span> (ref = ele)&#125; /&gt;</span></span><br><span class="line"><span class="xml">      &#123;/** other code */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ref-转发-传递"><a href="#Ref-转发-传递" class="headerlink" title="Ref 转发/传递"></a>Ref 转发/传递</h4><p>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧，其允许某些组件接收 ref，并将其向下传递给子组件。</p><p>转发 ref 到DOM中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = React.useRef(<span class="literal">null</span>);</span><br><span class="line">    React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(inputRef.current);<span class="comment">//input节点</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>调用 <code>React.useRef</code> 创建了一个 <code>React ref</code> 并将其赋值给 <code>ref</code> 变量。</li><li>指定 <code>ref</code> 为JSX属性，并向下传递 <code>&lt;MyInput ref=&#123;inputRef&#125;&gt;</code></li><li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code> 作为其第二个参数。</li><li>向下转发该 <code>ref</code> 参数到 <code>&lt;button ref=&#123;ref&#125;&gt;</code>，将其指定为JSX属性</li><li>当 <code>ref</code> 挂载完成，<code>inputRef.current</code> 指向 <code>input</code> DOM节点</li></ol><h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><p>当组件加载到页面上之后（mounted），你都可以通过 <code>react-dom</code> 提供的 <code>findDOMNode()</code> 方法拿到组件对应的 DOM 元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside Component class</span></span><br><span class="line"><span class="function"><span class="title">componentDidMound</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = findDOMNode(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findDOMNode()</code> 不能用在无状态组件上。</p><h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &#123;isLoggedIn?<span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;number&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <strong>在 JSX 中嵌入 map()</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;numbers.map((number) =&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key;当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key </p><p><strong>key 只是在兄弟节点之间必须唯一</strong></p><p> 数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;number&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="添加样式的方式"><a href="#添加样式的方式" class="headerlink" title="添加样式的方式"></a>添加样式的方式</h3><p><strong>第一种：行内样式</strong></p><p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号</span></span><br><span class="line"> &lt;p style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;14px&#x27;</span>&#125;&#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种：className（外部引用）</strong></p><p>class需要写成className（因为毕竟是在写类js代码，会收到js规则的限制，而class是关键字）</p><p><strong>第三种：样式组件（styled-components）</strong></p><p>styled-components是针对React写的一套css-in-js框架，简单来讲就是在js中写css。<br>styled-components是一个第三方包，要安装。<strong>Material框架</strong>中的样式也是如此</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">    width: 100px;</span></span><br><span class="line"><span class="string">    height: 100px;</span></span><br><span class="line"><span class="string">    background: pink;</span></span><br><span class="line"><span class="string">    color: white;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><strong>第四种：内嵌样式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;&#123;`.operafor4&#123;margin-top:42px !important&#125;`&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="动态添加样式"><a href="#动态添加样式" class="headerlink" title="动态添加样式"></a>动态添加样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;display: (index===this.state.currentIndex) ? &quot;block&quot; : &quot;none&quot;&#125;&#125;&gt;此标签是否隐藏&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;index===this.state.currentIndex?&quot;active&quot;:null&#125;&gt;此标签是否选中&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="表单和受控组件"><a href="#表单和受控组件" class="headerlink" title="表单和受控组件"></a>表单和受控组件</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a>来更新。</p><p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“<strong>受控组件</strong>”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &#x27;&#x27;&#125;;</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;    this.setState(&#123;value: event.target.value&#125;);  &#125;</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#x27;提交的名字: &#x27; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p><strong>对于受控组件来说，输入的值始终由 React 的 state 驱动</strong></p><h2 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p>无论是函数组件还是 class 组件，都拥有 <code>defaultProps</code> 属性。可以通过配置特定的 <code>defaultProps</code> 属性来定义 <code>props</code> 的默认值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 props 的默认值：</span></span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染出 &quot;Hello, Stranger&quot;：</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="PropTypes类型检查"><a href="#PropTypes类型检查" class="headerlink" title="PropTypes类型检查"></a>PropTypes类型检查</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Greeting.propTypes = &#123;</span><br><span class="line">  <span class="attr">name</span>: PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class="line">  <span class="comment">// 这些属性都是可选的。</span></span><br><span class="line">  <span class="attr">optionalArray</span>: PropTypes.array,</span><br><span class="line">  <span class="attr">optionalBool</span>: PropTypes.bool,</span><br><span class="line">  <span class="attr">optionalFunc</span>: PropTypes.func,</span><br><span class="line">  <span class="attr">optionalNumber</span>: PropTypes.number,</span><br><span class="line">  <span class="attr">optionalObject</span>: PropTypes.object,</span><br><span class="line">  <span class="attr">optionalString</span>: PropTypes.string,</span><br><span class="line">  <span class="attr">optionalSymbol</span>: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class="line">  <span class="comment">// (或 Fragment) 也包含这些类型。</span></span><br><span class="line">  <span class="attr">optionalNode</span>: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  <span class="attr">optionalElement</span>: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class="line">  <span class="attr">optionalElementType</span>: PropTypes.elementType,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class="line">  <span class="comment">// JS 的 instanceof 操作符。</span></span><br><span class="line">  <span class="attr">optionalMessage</span>: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class="line">  <span class="comment">// 枚举类型。</span></span><br><span class="line">  <span class="attr">optionalEnum</span>: PropTypes.oneOf([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class="line">  <span class="attr">optionalUnion</span>: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class="line">  <span class="attr">optionalArrayOf</span>: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由某一类型的值组成</span></span><br><span class="line">  <span class="attr">optionalObjectOf</span>: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由特定的类型值组成</span></span><br><span class="line">  <span class="attr">optionalObjectWithShape</span>: PropTypes.shape(&#123;</span><br><span class="line">    <span class="attr">color</span>: PropTypes.string,</span><br><span class="line">    <span class="attr">fontSize</span>: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// An object with warnings on extra properties</span></span><br><span class="line">  <span class="attr">optionalObjectWithStrictShape</span>: PropTypes.exact(&#123;</span><br><span class="line">    <span class="attr">name</span>: PropTypes.string,</span><br><span class="line">    <span class="attr">quantity</span>: PropTypes.number</span><br><span class="line">  &#125;),   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class="line">  <span class="comment">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class="line">  <span class="attr">requiredFunc</span>: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意类型的数据</span></span><br><span class="line">  <span class="attr">requiredAny</span>: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class="line">  <span class="attr">customProp</span>: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class="line">  <span class="comment">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class="line">  <span class="comment">// 第一个是数组或对象本身</span></span><br><span class="line">  <span class="comment">// 第二个是他们当前的键。</span></span><br><span class="line">  <span class="attr">customArrayProp</span>: PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a><strong>this.props.children</strong></h3><p>将一个组件写在另一个组件的内容中，然后在外层组件中通过 this.props.children来接收内容中的组件</p><p>如果当前组件没有子节点，它就是 undefined ;<br>如果有一个子节点，数据类型是 Object；<br>如果有多个子节点，数据类型就是 Array。</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p><a href="https://juejin.cn/post/6850418109636050958">https://juejin.cn/post/6850418109636050958</a></p><p><a href="https://juejin.cn/post/6959885030063603743#heading-0">https://juejin.cn/post/6959885030063603743#heading-0</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;)</span><br><span class="line">    console.log(this.state.number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdf9d950d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>看完这个例子，也许很多小伙伴会下意识的以为setState是一个异步方法，但是其实<strong>setState并没有异步的说法，之所以会有一种异步方法的表现形式，归根结底还是因为react框架本身的性能机制所导致的</strong>。因为每次调用setState都会触发更新，异步操作是为了提高性能，将多个状态合并一起更新，减少re-render调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( let i = 0; i &lt; 100; i++ ) &#123;</span><br><span class="line">    this.setState( &#123; num: this.state.num + 1 &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果setState是一个同步执行的机制，那么这个状态会被重新渲染100次，这对性能是一个相当大的消耗。</p><blockquote><p>React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新</p></blockquote><p><strong>回调函数</strong></p><p>setState提供了一个回调函数供开发者使用，在回调函数中，我们可以实时的获取到更新之后的数据。还是以刚才的例子做示范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;,()=&gt;&#123;</span><br><span class="line">        console.log(this.state.number)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdfc5be38~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><strong>总结：</strong></p><ul><li><p>setState本身并不是异步（不会立即更新state的结果），只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。</p></li><li><p>由于 react 的事件委托机制，调用 onClick 执行的事件，是处于 react 的控制范围的。</p><p>而 setTimeout 已经超出了 react 的控制范围，react 无法对 setTimeout 的代码前后加上事务逻辑（除非 react 重写 setTimeout）。</p><p>所以当遇到 <code>setTimeout/setInterval/Promise.then(fn)/fetch 回调/xhr 网络回调</code>时，react 都是无法控制的。</p><ul><li>在setTimeout，Promise.then等异步事件中。setState和useState是同步执行的（立即更新state的结果）</li></ul></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li><p>react 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p></li><li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p></li><li><p>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p><p><strong>绑定this：</strong></p><ul><li><p>在constructor中用bind绑定</p></li><li><p>箭头函数</p></li><li><p>回调中使用箭头函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&#x27;this is:&#x27;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">blogPost</span>: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">blogPost</span>: DataSource.getBlogPost(<span class="built_in">this</span>.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">text</span>=<span class="string">&#123;this.state.blogPost&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在挂载时，向 <code>DataSource</code> 添加一个更改侦听器。</li><li>在侦听器内部，当数据源发生变化时，调用 <code>setState</code>。</li><li>在卸载时，删除侦听器。</li></ul><p>你可以想象，在一个大型应用程序中，这种订阅 <code>DataSource</code> 和调用 <code>setState</code> 的模式将一次又一次地发生。我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ul><li><p>列表渲染为什么需要key:</p><p>为每个元素加上唯一的标识，这样在执行diff的时候会加快位置的确定</p></li></ul><h1 id="Hooks函数"><a href="#Hooks函数" class="headerlink" title="Hooks函数"></a>Hooks函数</h1><p><a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html">http://www.ruanyifeng.com/blog/2019/09/react-hooks.html</a></p><ul><li>纯函数组件<strong>没有状态</strong></li><li>纯函数组件<strong>没有生命周期</strong></li><li>纯函数组件没有<code>this</code></li></ul><p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，我们不得不用类组件或者redux，但我们知道类组件的也是有缺点的，比如，遇到简单的页面，你的代码会显得很重，并且每创建一个类组件，都要去继承一个React实例，至于Redux,更不用多说，很久之前Redux的作者就说过，“能用React解决的问题就不用Redux”,等等一系列的话。关于<strong>React类组件r</strong>edux的作者又有话说</p><blockquote><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul></blockquote><p><strong>Hooks 优势</strong></p><ol><li>能优化类组件的三大问题</li><li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li><li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li></ol><p><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。</strong>而React Hooks 就是我们所说的“钩子”。</p><h2 id="userState-状态钩子"><a href="#userState-状态钩子" class="headerlink" title="userState():状态钩子"></a>userState():状态钩子</h2><p>用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [buttonText, setButtonText] = useState(<span class="string">&quot;Click me,      please&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> setButtonText(<span class="string">&quot;Thanks, been clicked!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点击了第一个button后，文字改变。而第二个则不会改变（不会重新渲染数据）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>惰性初始化 state：</strong></p><p>initialState 参数只会在组件的初始化渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter5</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Counter5 render&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个函数只在初始渲染时执行一次，后续更新状态重新渲染组件时，该函数就不会再被调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getInitState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">number</span>: props.number &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> [counter, setCounter] = useState(getInitState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;counter.number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCounter(&#123; number: counter.number + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="xml">        +</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCounter(counter)&#125;&gt;setCounter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="useContext-共享状态钩子"><a href="#useContext-共享状态钩子" class="headerlink" title="useContext():共享状态钩子"></a>useContext():共享状态钩子</h2><p>如果需要在层层组件之间共享状态，可以使用<code>useContext()</code>。</p><p>第一步就是使用 React Context API，在组件外部建立一个 Context。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AppContext = React.createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>组件封装代码如下。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line"><span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">&lt;AppContext.Provider value=&#123;&#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&#x27;superawesome&#x27;</span></span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">Messages</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/AppContext.Provider&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>AppContext.Provider</code>提供了一个 Context 对象，这个对象可以被子组件共享。</p><p>Navbar 组件的代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Navbar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>AwesomeSite<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="useReducer-action-钩子"><a href="#useReducer-action-钩子" class="headerlink" title="useReducer():action 钩子"></a>useReducer():action 钩子</h2><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是<code>(state, action) =&gt; newState</code>。</p><p><code>useReducers()</code>钩子用来引入 Reducer 功能。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure></blockquote><p>上面是<code>useReducer()</code>的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的<code>dispatch</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>纯函数只能进行数据计算，那些不涉及计算的操作（比如ajax 请求、访问原生dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志）应该写在哪里呢？</p><p>函数式编程将那些跟数据计算无关的操作，都称为 “<strong>副效应</strong>“ <strong>（side effect）</strong> 。</p><p><code>useEffect()</code>用来引入具有副作用的操作，最常见的就是向服务器请求数据。可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p><p><strong><code>useEffect()</code>的用法如下：</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()  =&gt;</span>  &#123;</span><br><span class="line">    <span class="comment">// Async Action</span></span><br><span class="line">    <span class="comment">//return 则是在页面被卸载时调用.</span></span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure></blockquote><p>上面用法中，<code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p><p><strong>它的常见用途有下面几种：</strong></p><ul><li>获取数据（data fetching）</li><li>事件监听或订阅（setting up a subscription）</li><li>改变 DOM（changing the DOM）</li><li>输出日志（logging）</li></ul><p><strong>tips</strong></p><ul><li><p><strong>它在第一次渲染之后<em>和</em>每次更新之后都会执行</strong></p></li><li><p>使用<code>useEffect()</code>时，有一点需要注意。如果有多个副效应，应该调用多个<code>useEffect()</code>，而不应该合并写在一起。</p></li><li><p>在useEffect中，不仅会请求后端的数据，还会通过调用setData来更新本地的状态，这样会触发view的更新。</p><p>但是，运行这个程序的时候，会出现无限循环的情况。useEffect在组件<strong>mount</strong>时执行，但也会在组件<strong>更新</strong>时执行。因为我们在每次请求数据之后都会设置本地的状态，所以组件会更新，因此useEffect会再次执行，因此出现了无限循环的情况。<strong>我们只想在组件mount时请求数据。</strong>我们可以传递一个空数组作为useEffect的第二个参数，这样就能避免在组件更新执行useEffect，只会在组件mount时执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">&#x27;http://localhost/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ))&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>升级加载loading </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">&#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;query&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> setQuery(event.target.value)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="xml">          setUrl(`http://localhost/api/v1/search?query=$&#123;query&#125;`)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        Search</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      &#123;isLoading ? (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ) : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ul><h2 id="useCallback和useMemo"><a href="#useCallback和useMemo" class="headerlink" title="useCallback和useMemo"></a>useCallback和useMemo</h2><p><a href="https://www.xiaye0.com/?p=113">https://www.xiaye0.com/?p=113</a></p><p><a href="https://www.jianshu.com/p/014ee0ebe959">https://www.jianshu.com/p/014ee0ebe959</a></p><p>都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</p><p><strong>React 中当组件的 props 或 state 变化时，会重新渲染视图</strong></p><h3 id="memo-1"><a href="#memo-1" class="headerlink" title="memo"></a>memo</h3><p>这个hook是针对组件的,减少组件的不必要更新.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextCell = memo(<span class="function"><span class="keyword">function</span>(<span class="params">props:any</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line"><span class="keyword">const</span> fatherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">TextCell</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里如果没有用到memo 每次父组件重新setNumber,<strong>子组件都会重新渲染一次</strong>,加上了后<strong>只会在初始化的时候渲染(useMemo会在页面初始化的时候执行一次,并把执行的结果缓存一份)</strong>,减少了子组件渲染的次数,这个在之前老的class方法,要减少子组件的渲染,可以使用pureComponent,或者在生命周期 componentWillReciveProps方法里返回false即可.</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>父组件给子组件传递属性（<strong>函数</strong>），父组件重新渲染，会重新创建函数，对应函数地址改变，即传给子组件的属性发生了变化，导致子组件渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextCell = memo(<span class="function"><span class="keyword">function</span>(<span class="params">props:any</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line"><span class="keyword">const</span> fatherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">33</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">click</span>=<span class="string">&#123;handleClick&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果不使用useCallback,哪怕子组件用memo包裹了 也还是会更新子组件,因为子组件的绑定的函数click在父组件更新的时候也会更新<strong>引用地址</strong>,导致子组件的更新,但是这个其实是没必要的更新,绑定的函数并不需要子组件更新,useCallback就是阻止这类没必要的更新而存在的. 如果是用class的方法的话,需要在constructor里绑定函数,会比较麻烦,不易阅读.</p><p>这里需要注意的是 如果是有参数需要传递,则需要这样写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextCell click=&#123;useCallback(<span class="function">()=&gt;</span>handleClick(‘传递的参数’),[])&#125;/&gt;</span><br></pre></td></tr></table></figure><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><strong>父组件调用子组件时传递对象属性</strong>，useMemo会在页面初始化的时候执行一次,并把执行的结果缓存一份。即使页面刷新了也不会再执行info的赋值操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentComp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [ name, setName ] = useState(<span class="string">&#x27;hi~&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [ age, setAge ] = useState(<span class="number">20</span>)</span><br><span class="line">  <span class="keyword">const</span> changeName = useCallback(<span class="function">(<span class="params">newName</span>) =&gt;</span> setName(newName), [])</span><br><span class="line">  <span class="keyword">const</span> info = &#123; name, age &#125;    <span class="comment">// 复杂数据类型属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">info</span>=<span class="string">&#123;info&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点击父组件按钮，触发父组件重新渲染；</li><li>父组件渲染，<code>const info = &#123; name, age &#125;</code> 一行会重新生成一个新对象，导致传递给子组件的 info 属性值变化，进而导致子组件重新渲染。</li></ul><p>使用 useMemo 对对象属性包一层。</p><p>useMemo 有两个参数：</p><ul><li>第一个参数是个函数，返回的对象指向同一个引用，不会创建新对象；</li><li>第二个参数是个数组，只有数组中的变量改变时，第一个参数的函数才会返回一个新的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentComp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">const</span> [ name, setName ] = useState(<span class="string">&#x27;hi~&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [ age, setAge ] = useState(<span class="number">20</span>)</span><br><span class="line">  <span class="keyword">const</span> changeName = useCallback(<span class="function">(<span class="params">newName</span>) =&gt;</span> setName(newName), [])</span><br><span class="line">  <span class="keyword">const</span> info = useMemo(<span class="function">() =&gt;</span> (&#123; name, age &#125;), [name, age])   <span class="comment">// 包一层</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">info</span>=<span class="string">&#123;info&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由是一种向用户显示不同页面的能力。 这意味着用户可以通过输入 URL 或单击页面元素在 WEB 应用的不同部分之间切换。</p><p>安装<code>react-router-dom</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><p>这里需要说明一下 React Router 库中几个不同的 npm 依赖包，每个包都有不同的用途</p><ul><li><code>react-router</code>: 实现了路由的核心功能，用作下面几个包的运行时依赖项(peer dependency)。</li><li><code>react-router-dom</code>: 用于 React WEB 应用的路由依赖. 基于 react-router，加入了在浏览器运行环境下的一些功能，例如：**<code>BrowserRouter</code> 和 <code>HashRouter</code> 组件，前者使用 <code>pushState</code> 和 <code>popState</code> 事件构建路由;后者使用 <code>window.location.hash</code> 和 <code>hashchange</code> 事件构建路由**</li><li><code>react-router-native</code>: 用于 React Native 应用的路由依赖。基于 react-router，加入了 react-native 运行环境下的一些功能</li><li><code>react-router-config</code>: 用于配置静态路由的工具库</li></ul><h2 id="React-Routers三类组件"><a href="#React-Routers三类组件" class="headerlink" title="React Routers三类组件"></a>React Routers三类组件</h2><h3 id="路由器Router"><a href="#路由器Router" class="headerlink" title="路由器Router"></a>路由器Router</h3><p><code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code></p><p>两者之间的主要区别是它们存储URL和与Web服务器通信的方式。</p><h4 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h4><p><code>&lt;BrowserRouter&gt;</code>使用常规的URL路径。这些通常是外观最好的URL，但是它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。Create React App在开发中即开即用地支持此功能，并<a href="https://create-react-app.dev/docs/deployment#serving-apps-with-client-side-routing">附带</a>有关如何配置生产服务器的说明。</p><ul><li>BrowserRouter提供了如下属性<ul><li><code>basename (string)</code> 当前位置的基准 URL</li><li><code>forceRefresh (boolean)</code>，在导航的过程中整个页面是否刷新</li><li><code>getUserConfirmation (func)</code>，当导航需要确认时执行的函数。默认是：window.confirm</li><li><code>keyLength (number)</code>  location.key 的长度。默认是 6</li><li><code>children (node)</code> 要渲染的子节点</li></ul></li></ul><h4 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h4><p><code>&lt;HashRouter&gt;</code>将当前位置存储在<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">URL</a><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">的<code>hash</code>一部分中</a>，因此URL看起来像<code>http://example.com/#/your/page</code>。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置(<strong>在任意的路由进行页面的刷新都不会是 404</strong>)。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;inbox&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Inbox&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;messages/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Message&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他还有 <code>&lt;MemoryRouter&gt;  内存路由组件</code>、<code>&lt;NativeRouter&gt;  Native的路由组件</code>、<code>&lt;StaticRouter&gt; 静态路由组件</code>这些路由组件，其中 MemoryRouter 主要用在 ReactNative 这种非浏览器的环境中，因此直接将 URL 的 history 保存在了内容中。StaticRouter 主要用于服务器端渲染</p><h4 id="History-的小知识"><a href="#History-的小知识" class="headerlink" title="History 的小知识"></a>History 的小知识</h4><p>每个 <code>&lt;Router&gt;</code> 组件都会创建一个 <code>history</code> 对象，它记录了当前的位置（<code>history.location</code>），还记录了堆栈中以前的位置。在当前位置发生变化时，页面会被重新渲染，于是你就有一种导航跳转的感觉。</p><p>那么如何改变当前的位置呢？也就是说如何做到<strong>导航跳转</strong>呢？这时候 <code>history</code> 的作用就来了，这个对象暴露了一些方法，比如 <code>history.push</code> 和 <code>history.replace</code> ，它们就可以拿来处理上面的问题。</p><p>当你点击一个 <code>&lt;Link&gt;</code> 组件时，<code>history.push</code> 就会被调用，而当你使用一个 <code>&lt;Redirect&gt;</code> 组件时，<code>history.replace</code> 就会被调用。其它的方法比如 <code>history.goBack</code> 和 <code>history.goForward</code> 可以用来在历史堆栈中回溯或前进。</p><h3 id="路线匹配器Route"><a href="#路线匹配器Route" class="headerlink" title="路线匹配器Route"></a>路线匹配器Route</h3><p><code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">About</span> /&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">   <span class="comment">//  会把没有匹配的路径直接重定向到 /login</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> /&gt;</span></span></span><br><span class="line">   &#123;<span class="comment">/* 从 /inbox/messages/:id 跳转到 /messages/:id */</span>&#125;</span><br><span class="line">   &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;messages/:id&quot;</span> to=<span class="string">&quot;/messages/:id&quot;</span> /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>当 location 与 Route 的 path 匹配时渲染 Route 中的 Component</p><ul><li><p><strong>Route 接受三种渲染方式</strong></p><ul><li><p><code>&lt;Route component&gt;</code></p></li><li><p><code>&lt;Route render&gt;</code></p><p><code>render</code> function 类型，Route 会渲染这个 function 的返回值，可以在函数中附加一些额外的逻辑，所以你可以在render中添加一些逻辑判断，再返回一个要渲染的 component</p></li><li><p><code>&lt;Route children&gt;</code></p><p><code>children</code> function 类型，比 <code>render</code> 多了 <code>match参数</code>，可以根据 match参数来决定匹配的时候渲染什么，不匹配的时候渲染什么</p></li><li><p>```</p> <Route exact path="/">            <Home />          </Route><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- **route属性**</span><br><span class="line"></span><br><span class="line">  - `exact` 是否进行精确匹配，路由 `/a` 可以和 `/a/、/a` 匹配</span><br><span class="line"></span><br><span class="line">  - `strict` 是否进行严格匹配，指明路径只匹配以斜线结尾的路径，路由`/a`可以和`/a`匹配，不能和`/a/`匹配，相比 `exact` 会更严格些</span><br><span class="line"></span><br><span class="line">  - `path (string)` 标识路由的路径,`path`属性可以使用通配符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><Route path="/hello/:name"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      通配符的规则如下:</span><br><span class="line"></span><br><span class="line">  &gt; **（1）`:paramName`**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; `:paramName`匹配URL的一个部分，直到遇到下一个`/`、`?`、`#`为止。这个路径参数可以通过`this.props.params.paramName`取出。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; **（2）`()`**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; `()`表示URL的这个部分是可选的。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; **（3）`\*`**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; `*`匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; **（4） `\**`**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; `**` 匹配任意字符，直到下一个`/`、`?`、`#`为止。匹配方式是贪婪模式。</span><br><span class="line"></span><br><span class="line">  - `component` 表示路径对应显示的组件</span><br><span class="line">  - `location (object)` 除了通过 path 传递路由路径，也可以通过传递 location 对象可以匹配</span><br><span class="line">  - `sensitive (boolean)` 匹配路径时，是否区分大小写</span><br><span class="line"></span><br><span class="line">- **属性的隐式传递**</span><br><span class="line"></span><br></pre></td></tr></table></figure>location、history、match<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 三个 props 比较常用的是 match，通过 match.params 可以取到动态参数的值</span><br><span class="line"></span><br><span class="line">  | 所属     | 属性                   | 类型     | 含义                                              |</span><br><span class="line">  | -------- | ---------------------- | -------- | ------------------------------------------------- |</span><br><span class="line">  | history  | length                 | number   | 表示history堆栈的数量                             |</span><br><span class="line">  |          | action                 | string   | 表示当前的动作。比如pop、replace或push            |</span><br><span class="line">  |          | location               | object   | 表示当前的位置                                    |</span><br><span class="line">  |          | push(path, [state])    | function | 在history堆栈顶加入一个新的条目                   |</span><br><span class="line">  |          | replace(path, [state]) | function | 替换在history堆栈中的当前条目                     |</span><br><span class="line">  |          | go(n)                  | function | 将history堆栈中的指针向前移动                     |</span><br><span class="line">  |          | goBack()               | function | 等同于go(-1)                                      |</span><br><span class="line">  |          | goForward()            | function | 等同于go(1)                                       |</span><br><span class="line">  |          | block(promt)           | function | 阻止跳转                                          |</span><br><span class="line">  |          |                        |          |                                                   |</span><br><span class="line">  | match    | params                 | object   | 表示路径参数，通过解析URL中动态的部分获得的键值对 |</span><br><span class="line">  |          | isExact                | boolean  | 为true时，表示精确匹配                            |</span><br><span class="line">  |          | path                   | string   | 用来做匹配的路径格式                              |</span><br><span class="line">  |          | url                    | string   | URL匹配的部分                                     |</span><br><span class="line">  |          |                        |          |                                                   |</span><br><span class="line">  | location | pathname               | string   | URL路径                                           |</span><br><span class="line">  |          | search                 | string   | URl中查询字符串                                   |</span><br><span class="line">  |          | hash                   | string   | URL的hash分段                                     |</span><br><span class="line">  |          | state                  | string   | 表示location中的状态                              |</span><br><span class="line"></span><br><span class="line">#### Swtich</span><br><span class="line"></span><br><span class="line">`Swtich` 就近匹配路由，仅渲染一个路由，路由的默认行为是匹配了就直接渲染</span><br><span class="line"></span><br><span class="line">```jsx</span><br><span class="line">/// 假设你访问的URL为 /dog</span><br><span class="line">&lt;Route path=&#x27;/dog&#x27; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // 虽然这里匹配了，但不会停止查找</span><br><span class="line">&lt;Route path=&quot;/:dog&quot; component=&#123;Husky&#125;&gt;&lt;/Route&gt; // 这个路由依然会被匹配，这样两个组件都会被渲染</span><br><span class="line">...</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=&#x27;/dog&#x27; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // Switch 匹配一个路由后就不会再去查找下一个路由，那么下面的路由就不会被匹配</span><br><span class="line">  &lt;Route path=&quot;/:dog&quot; component=&#123;Husky&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h4><p>重定向，新位置将覆盖历史堆栈中的当前位置</p><ul><li><p><code>from (string)</code> 需要重定向的路径，可以包括动态参数</p><p><code>push (boolean)</code> 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目</p><p><code>to (string | object)</code> 重定向到的路径</p><p><code>exact (boolean)</code> 是否要对 from 进行精确匹配</p><p><code>strict (boolean)</code> 是否要对 from 进行严格匹配</p><p><code>sensitive (boolean)</code> 匹配 from 时是否区分大小写</p></li></ul><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><h4 id="导航Link"><a href="#导航Link" class="headerlink" title="导航Link"></a>导航Link</h4><p><code>&lt;Link&gt;</code> 组件被用来在<strong>页面之间</strong>进行导航，它其实就是 HTML 中的 <code>&lt;a&gt;</code> 标签的上层封装，不过在其源码中使用 <code>event.preventDefault</code> 禁止了其默认行为，然后使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">history API</a> 自己实现了跳转。我们都知道，如果使用 <code>&lt;a&gt;</code> 标签去进行导航的话，整个页面都会被刷新，这是我们不希望看到的，当然，跳转到首页这种行为我倒是蛮喜欢用 <code>&lt;a&gt;</code> 标签的</p><p>所以我们使用 <code>&lt;Link&gt;</code> 组件来导航到一个目标 URL，可以在不刷新页面的情况下重新渲染页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论您在何处呈现&lt;Link&gt;，&lt;a&gt;都会在HTML文档中呈现锚点。</span></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span>&gt;Home&lt;/Link&gt;</span><br><span class="line"><span class="comment">// &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p><code>Link</code> 声明路由要跳转的地方</p><ul><li>```<br>to（string | object | function）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   需要跳转到的路径(pathname) 或地址（location）</span><br><span class="line"></span><br><span class="line">  - 为 string 时 就是一个明确的路径地址</span><br><span class="line">  - 为 object 时有如下属性（就是一个location对象）</span><br><span class="line">    - pathname：URL路径。</span><br><span class="line">    - search：URl中查询字符串。</span><br><span class="line">    - hash：URL的hash分段，例如#a-hash。</span><br><span class="line">    - state：表示location中的状态</span><br><span class="line">  - 为 function 时，就是一个函数接收当前 location 为参数，然后以字符串或对象的形式返回位置形式</span><br><span class="line"></span><br><span class="line">- `replace (boolean)` 为 true 是替换历史记录，false 是新增历史记录</span><br><span class="line"></span><br><span class="line">```jsx</span><br><span class="line">  &lt;Link to=&quot;/course&quot; /&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;Link to=&#123;&#123;</span><br><span class="line">    pathname: &#x27;/course&#x27;,</span><br><span class="line">    search: &#x27;?sort=name&#x27;,</span><br><span class="line">    hash: &#x27;#the-hash&#x27;,</span><br><span class="line">    state: &#123; fromDashboard: true &#125;</span><br><span class="line">  &#125;&#125; /&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;Link to=&#123;location =&gt; (&#123; ...location, pathname: &quot;/courses&quot; &#125;)&#125; /&gt;</span><br><span class="line">  </span><br><span class="line">&lt;Link to=&#123;location =&gt; `$&#123;location.pathname&#125;?sort=name`&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a><code>NavLink</code></h4><p><code>NavLink</code> 功能与 <code>Link</code> 类似不过参数更多，并且可以设置被选中时的样式或者类</p><ul><li><code>exact (boolean)</code> 是否进行精确匹配</li><li><code>strict (boolean)</code> 是否进行严格匹配</li><li><code>to（string | object）</code> 需要跳转到的路径(pathname)或地址（location）</li><li><code>activeClassName (string)</code> 是选中状态的类名，我们可以为其添加样式</li><li><code>activeStyle (Object)</code> 元素处于选中状态时，应用于元素的样式</li><li><code>isActive(function)</code> 添加额外逻辑以确定链接是否处于活动状态</li></ul><h3 id="IndexRoute和IndexRedirect"><a href="#IndexRoute和IndexRedirect" class="headerlink" title="IndexRoute和IndexRedirect"></a>IndexRoute和IndexRedirect</h3><h4 id="Index-Routes"><a href="#Index-Routes" class="headerlink" title="Index Routes"></a>Index Routes</h4><p>通常情况下，我们会建立如下情况的路由：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>其中 App 组件一般情况下是一个 layout，比如包含了 header、footer 或者其他内容，其下面的 route 会被嵌入到这个 App 中（它们将成为 App 的<br>children），但这样配置路由有一个问题，就是我们访问 <code>http://localhost:3000/</code> 这个地址时，你会发现仅渲染了一个 App 的 layout 内容，Accounts 和 Statements 都没有被渲染，这种情况下我们一般会设置一个默认页，当访问 <code>/</code> 这个路由时显示这个默认页。由此就需要用到 <code>IndexRoute</code> 功能，修改一下路由如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">IndexRoute</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>如此配置后，我们再次访问 <code>/</code> 路由，你会发现页面渲染了 Home 组件的内容。这就是 IndexRoute 的功能，指定一个路由的默认页。</p><h4 id="Index-Redirects"><a href="#Index-Redirects" class="headerlink" title="Index Redirects"></a>Index Redirects</h4><p>上面这种情况比较常见，还有一种非常常见的方式就是当我们尝试访问 <code>/</code> 这个路由时，我们想让其直接跳转到 ‘/Accounts’，直接免去了默认页 Home，这样来的更加直接。由此我们就需要 <code>IndexRedirect</code> 功能。考虑如下路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRedirect to=&quot;/accounts&quot;/&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>这样设计路由后，我们再次访问 <code>/</code> 时，系统默认会跳转到 <code>/accounts</code> 路由。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上就是 IndexRoute 和 IndexRedirect 的功能介绍，让我们来总结一下他们两个的区别。</p><ul><li>IndexRoute 一般情况下用于设计一个默认页且不改变 URL 地址，而 IndexRedirect 则是跳转默认地址且地址会发生改变。</li><li>IndexRoute 指定一个组件作为默认页，而 IndexRedirect 指定一个路由地址作为跳转地址。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><ul><li>useHistory</li><li>用以获取history对象，进行编程式的导航</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useHistory()); // 与 props.history 结果一致</span><br><span class="line">  console.log(props.history);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">/// 使用 useHistory 的好处是，引入组件会更自由些</span><br><span class="line">&lt;Route path=&quot;/dog&quot; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // 必须这么写，props 才能拿到相关值</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/husky&quot;&gt;</span><br><span class="line">&lt;Husky /&gt;</span><br><span class="line">&lt;/Route&gt; // 这样写的话 useHistory 可以正常取值，但是 props 不行</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>useLocation<ul><li>用以获取location对象，可以查看当前路由信息</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useLocation()); // 与 props.location 结果一致</span><br><span class="line">  console.log(props.location);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>useParams<ul><li>可以用来获取 match.params</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">    console.log(useParams()) // 与 props.match.params 结果一致，但明显更简洁</span><br><span class="line">    console.log(props.match.params)</span><br><span class="line">    const &#123;eat&#125; = props.match.params;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;哈士奇 吃 &#123;eat&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>useRouteMatch<ul><li>可以接受一个 path 字符串作为参数。当参数的path与当前的路径相匹配时，useRouteMatch会返回 match 对象，否则返回 null。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 接收一个字符串作为参数</span><br><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">const match = useParams(&#x27;/husky&#x27;); // 假定当前匹配路由就是 /husky，如果访问的路径不是 /husky ，那么 match 就为 null</span><br><span class="line">    const &#123;eat&#125; = match ? match.params : &#x27;&#x27;;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;哈士奇 吃 &#123;eat&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><a href="https://juejin.cn/post/6844903602926927880">https://juejin.cn/post/6844903602926927880</a></p><p>Redux是将整个应用状态存储到一个地方，称为store。里面保存一棵状态树(state tree)。组件可以派发(dispatch)行为(action)给store,action发出命令后将state放入reucer加工函数中，返回新的state。其它组件可以通过订阅store中的状态(state)来刷新自己的视图</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f09a0b5196a2dd~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" /><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p><strong>整个应用的state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个store 中。</strong></p><h3 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h3><p><strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></p><p>这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。<strong>action就是改变state的指令，有多少操作state的动作就会有多少action。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加todo任务的 action 是这样的：</span></span><br><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;ADD_TODO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//action创建函数，返回一个action对象 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">  <span class="attr">type</span>: ADD_TODO,<span class="comment">//执行的动作</span></span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Build my first Redux app&#x27;</span>，</span><br><span class="line">  index：<span class="number">5</span>，<span class="comment">//用户完成任务的动作序列号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次dispatch 过程。</span></span><br><span class="line">dispatch(addTodo(text))</span><br><span class="line"><span class="comment">//或者创建一个被绑定的 action 创建函数来自动 dispatch：</span></span><br><span class="line"><span class="keyword">const</span> boundAddTodo = <span class="function"><span class="params">text</span> =&gt;</span> dispatch(addTodo(text))</span><br><span class="line">boundAddTodo(text);</span><br><span class="line"><span class="comment">//store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用。</span></span><br></pre></td></tr></table></figure><h3 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h3><p><strong>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure><p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p><ul><li>修改传入参数；</li><li>执行有副作用的操作，如 API 请求和路由跳转；</li><li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li></ul><p><strong>这是一个redux的经典案例</strong></p><ul><li>定义reducer函数根据action的类型改变state</li><li>actions 定义指令</li><li>通过createStore创建store</li><li>调用store.dispatch()发出修改state的命令</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="comment">//这里一个技巧是使用 ES6 参数默认值语法 来精简代码。</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123;count: <span class="number">0</span>&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="attr">increase</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;INCREASE&#x27;</span>&#125;),</span><br><span class="line">  <span class="attr">decrease</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;DECREASE&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 Redux store 来存放应用的状态。</span></span><br><span class="line"><span class="comment">// API 是 &#123; subscribe, dispatch, getState &#125;。</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动订阅更新，也可以事件绑定到视图层。</span></span><br><span class="line">store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变内部 state 惟一方法是 dispatch 一个 action。</span></span><br><span class="line"><span class="comment">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p><strong>目录结构</strong></p><p><a href="https://imgchr.com/i/sgpjbR"><img src="https://z3.ax1x.com/2021/01/19/sgpjbR.png" alt="屏幕截图"></a></p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p><strong>存放描述行为的数据结构(本质上是 JavaScript 普通对象),一般来说你会通过 store.dispatch() 将 action 传到 store。</strong></p><p>我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./actions/counter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:INCREMENT&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:DECREMENT&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们表示用户完成任务的动作序列号时，我们还需要再添加一个 action index 来，所以我们通过下标 <code>index</code> 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。</p><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><strong>Reducer</strong></h3><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a href="https://www.redux.org.cn/docs/basics/Actions.html">actions</a> 并发送到 store 的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./reducers/counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT, DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">state = <span class="number">0</span>, action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">          <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> DECREMENT:</span><br><span class="line">          <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">counter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><strong>注意：Redux 应用只有一个单一的 store</strong></p><p>我们学会了使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。</p><p><strong>Store</strong> 就是把它们联系到一起的对象。Store 有以下职责：</p><ul><li>维持应用的 state；</li><li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#getState"><code>getState()</code></a> 方法获取 state；</li><li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>dispatch(action)</code></a> 方法更新 state；</li><li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 注册监听器;</li><li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/258017257">https://zhuanlan.zhihu.com/p/258017257</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> logger = createLogger(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middlewares = [thunk]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    middlewares.push(logger)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> composeEnhancers =</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span><br><span class="line">      ? <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;)</span><br><span class="line">      : compose</span><br><span class="line">  <span class="keyword">const</span> enhancer = composeEnhancers(applyMiddleware(...middlewares))</span><br><span class="line"><span class="comment">//createStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</span></span><br><span class="line">  <span class="keyword">return</span> createStore(reducers, enhancer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="redux-异步请求"><a href="#redux-异步请求" class="headerlink" title="redux 异步请求"></a>redux 异步请求</h3><p><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p><p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。<br>在实际的开发中，redux中管理的很多数据可能来自服务器，我们需要进行异步的请求，再将数据保存到redux中。就是说在异步的网络请求中通过dispatch action来更新state中的数据。这时候就需要用到Redux中间件**(指这个框架允许我们在某个流程的执行中间插入我们自定义的一段代码)**。</p><p><a href="https://github.com/gaearon/redux-thunk">Thunk middleware</a> 并不是 Redux 处理异步 action 的唯一方式：</p><ul><li>你可以使用 <a href="https://github.com/acdlite/redux-promise">redux-promise</a> 或者 <a href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> 来 dispatch Promise 来替代函数。</li><li>你可以使用 <a href="https://github.com/redux-observable/redux-observable">redux-observable</a> 来 dispatch Observable。</li><li>你可以使用 <a href="https://github.com/yelouafi/redux-saga/">redux-saga</a> 中间件来创建更加复杂的异步 action。</li><li>你可以使用 <a href="https://github.com/lelandrichardson/redux-pack">redux-pack</a> 中间件 dispatch 基于 Promise 的异步 Action。</li></ul><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p><p>UI 组件有以下几个特征。</p><blockquote><ul><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>没有状态（即不使用<code>this.state</code>这个变量）</li><li>所有数据都由参数（<code>this.props</code>）提供</li><li>不使用任何 Redux 的 API</li></ul></blockquote><p>容器组件的特征恰恰相反。</p><blockquote><ul><li>负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>带有内部状态</li><li>使用 Redux 的 API</li></ul></blockquote><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p><p>如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>React-Redux 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect()(TodoList);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>TodoList</code>是 UI 组件，<code>VisibleTodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p><p>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。</p><blockquote><p>（1）输入逻辑：外部的数据（即<code>state</code>对象）如何转换为 UI 组件的参数</p><p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p></blockquote><p>因此，<code>connect</code>方法的完整 API 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h3><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。</p><p>作为函数，<code>mapStateToProps</code>执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">todos</span>: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。这个对象有一个<code>todos</code>属性，代表 UI 组件的同名参数，后面的<code>getVisibleTodos</code>也是一个函数，可以从<code>state</code>算出 <code>todos</code> 的值。</p><p>下面就是<code>getVisibleTodos</code>的一个例子，用来算出<code>todos</code>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SHOW_ALL&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> todos</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SHOW_COMPLETED&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SHOW_ACTIVE&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown filter: &#x27;</span> + filter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器组件的代码</span></span><br><span class="line"><span class="comment">//    &lt;FilterLink filter=&quot;SHOW_ALL&quot;&gt;</span></span><br><span class="line"><span class="comment">//      All</span></span><br><span class="line"><span class="comment">//    &lt;/FilterLink&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">active</span>: ownProps.filter === state.visibilityFilter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p><p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h3><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，用来建立 UI 组件的参数到<code>store.dispatch</code>方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p><p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code>（容器组件的<code>props</code>对象）两个参数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  dispatch,</span></span></span><br><span class="line"><span class="params"><span class="function">  ownProps</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">        <span class="attr">filter</span>: ownProps.filter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>从上面代码可以看到，<code>mapDispatchToProps</code>作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p><p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的<code>mapDispatchToProps</code>写成对象就是下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">    <span class="attr">filter</span>: filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h3><p><code>&lt;Provider store&gt;</code> 使组件层级中的 <code>connect()</code> 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 <code>connect()</code> 方法。</p><p>React-Redux 提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p><p>它的原理是<code>React</code>组件的<a href="https://facebook.github.io/react/docs/context.html"><code>context</code></a>属性，请看源码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">store</span>: <span class="built_in">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  <span class="attr">store</span>: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>store</code>放在了上下文对象<code>context</code>上面。然后，子组件就可以从<code>context</code>拿到<code>store</code>，代码大致如下。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisibleTodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="built_in">this</span>.unsubscribe = store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">      <span class="built_in">this</span>.forceUpdate()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="keyword">const</span> state = store.getState();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VisibleTodoList.contextTypes = &#123;</span><br><span class="line">  <span class="attr">store</span>: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>React-Redux</code>自动生成的容器组件的代码，就类似上面这样，从而拿到<code>store</code>。</p><h3 id="实例：计数器"><a href="#实例：计数器" class="headerlink" title="实例：计数器"></a>实例：计数器</h3><p>我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/actions/counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成props</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, onincrement, ondecrement&#125; = props;</span><br><span class="line">  <span class="comment">// console.log(props);</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;onincrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        &gt;</span></span></span><br><span class="line"><span class="xml">          increment</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;ondecrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;marginLeft:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        &gt;</span></span></span><br><span class="line"><span class="xml">          decrement</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，这个 UI 组件有三个参数：count和 onincrement, ondecrement。前者需要从<code>state</code>计算得到，后者需要向外发出 Action。</p><p>接着，定义<code>count</code>到<code>state</code>的映射，以及<code>onincrement, ondecrement</code>到<code>dispatch</code>的映射。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(state)</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: state.counter.count,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">onincrement</span>: <span class="function">() =&gt;</span> dispatch(increment()),</span><br><span class="line">      <span class="attr">ondecrement</span>: <span class="function">() =&gt;</span> dispatch(decrement())</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>然后，使用<code>connect</code>方法生成容器组件。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Home);</span><br></pre></td></tr></table></figure></blockquote><p>然后，定义这个组件的 Reducer。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT, DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">state = &#123; count: <span class="number">0</span>&#125;, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = state.count</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> DECREMENT:</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">count</span>:count - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">count</span>:count&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>最后，生成<code>store</code>对象，并使用<code>Provider</code>在根组件外面包一层。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> route <span class="keyword">from</span> <span class="string">&quot;../route/index.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../store&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Menu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> classes = useStyles();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p><code>createStore(reducer, [preloadedState], enhancer)</code></p><p>创建一个 Redux <a href="https://www.redux.org.cn/docs/api/Store.html">store</a> 来以存放应用中所有的 state。<br>应用中应有且仅有一个 store。</p><p><strong>参数</strong></p><ol><li><code>reducer</code> <em>(Function)</em>: 接收两个参数，分别是当前的 state 树和要处理的 <a href="https://www.redux.org.cn/docs/Glossary.html#action">action</a>，返回新的 <a href="https://www.redux.org.cn/docs/Glossary.html#state">state 树</a>。</li><li>[<code>preloadedState</code>] <em>(any)</em>: 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 <a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 创建 <code>reducer</code>，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 <code>reducer</code> 可理解的内容。</li><li><code>enhancer</code> <em>(Function)</em>: Store enhancer 是一个组合 store creator 的<strong>高阶函数</strong>，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</li></ol><p><strong>返回值</strong></p><p>(<a href="https://www.redux.org.cn/docs/api/Store.html"><em><code>Store</code></em></a>): 保存了应用所有 state 的对象。改变 state 的惟一方法是 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch">dispatch</a> action。你也可以 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe">subscribe 监听</a> state 的变化，然后更新 UI。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.concat([action.text])</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todos, [<span class="string">&#x27;Use Redux&#x27;</span>])</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Read the docs&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.getState())</span><br><span class="line"><span class="comment">// [ &#x27;Use Redux&#x27;, &#x27;Read the docs&#x27; ]</span></span><br></pre></td></tr></table></figure><ul><li>应用中不要创建多个 store！相反，使用 <a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 来把多个 reducer 创建成一个根 reducer。</li><li>要使用多个 store 增强器的时候，你可能需要使用 <a href="https://www.redux.org.cn/docs/api/compose.html">compose</a></li></ul><h3 id="Store-方法"><a href="#Store-方法" class="headerlink" title="Store 方法"></a>Store 方法</h3><p>Store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。</p><ul><li>getState()</li><li>dispatch(action)</li><li>subscribe(listener)</li><li>replaceReducer(nextReducer)</li></ul><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>随着应用变得越来越复杂，可以考虑将 <a href="https://www.redux.org.cn/docs/Glossary.html#reducer">reducer 函数</a> 拆分成多个单独的函数，拆分后的每个函数负责独立管理 <a href="https://www.redux.org.cn/docs/Glossary.html#state">state</a> 的一部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import counter from &#x27;./counter&#x27;</span><br><span class="line"></span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">counter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>combineReducers把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。</p><p>合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。</p><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p><p><strong>applyMiddleware(…middlewares)</strong></p><p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。</p><p>Middleware 最常见的使用场景是实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 <strong>dispatch 异步 actions</strong>。</p><p><strong>示例: 自定义 Logger Middleware</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">&#123; getState &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;will dispatch&#x27;</span>, action)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 middleware 链中下一个 middleware 的 dispatch。</span></span><br><span class="line">    <span class="keyword">let</span> returnValue = next(action)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;state after dispatch&#x27;</span>, getState())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般会是 action 本身，除非</span></span><br><span class="line">    <span class="comment">// 后面的 middleware 修改了它。</span></span><br><span class="line">    <span class="keyword">return</span> returnValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(</span><br><span class="line">  todos,</span><br><span class="line">  [ <span class="string">&#x27;Use Redux&#x27;</span> ],</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Understand the middleware&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// (将打印如下信息:)</span></span><br><span class="line"><span class="comment">// will dispatch: &#123; type: &#x27;ADD_TODO&#x27;, text: &#x27;Understand the middleware&#x27; &#125;</span></span><br><span class="line"><span class="comment">// state after dispatch: [ &#x27;Use Redux&#x27;, &#x27;Understand the middleware&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="compose-functions"><a href="#compose-functions" class="headerlink" title=" compose(...functions)"></a><code> compose(...functions)</code></h3><p>从右到左来组合多个函数。</p><p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 <a href="https://www.redux.org.cn/docs/Glossary.html#store-enhancer">store 增强器</a> 依次执行的时候，需要用到它。</p><p><strong>参数</strong></p><ol><li>(<em>arguments</em>): 需要合成的多个函数。预计每个函数都接收一个参数。它的返回值将作为一个参数提供给它左边的函数，以此类推。例外是最右边的参数可以接受多个参数，因为它将为由此产生的函数提供签名。（译者注：<code>compose(funcA, funcB, funcC)</code> 形象为 <code>compose(funcA(funcB(funcC())))</code>）</li></ol><p><strong>返回值</strong></p><p>(<em>Function</em>): 从右到左把接收到的函数合成后的最终函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> DevTools <span class="keyword">from</span> <span class="string">&#x27;./containers/DevTools&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;../reducers/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  compose(</span><br><span class="line">    applyMiddleware(thunk),</span><br><span class="line">    DevTools.instrument()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="TS与React"><a href="#TS与React" class="headerlink" title="TS与React"></a>TS与React</h1><ol><li>减少编写冗余的类型定义、类型标注，充分利用ts的自动类型推断，以及外部提供的类型声明。</li><li>类型安全：提供足够的类型信息来避免运行时错误，让错误暴露在开发期。这些类型信息同时能够提供代码补全、跳转到定义等功能。</li></ol><h2 id="React-FC"><a href="#React-FC" class="headerlink" title="React.FC"></a>React.FC</h2><p><code>React.FC</code>是函数式组件，是在TypeScript使用的一个<strong>泛型</strong>。FC是FunctionComponent的缩写，<code>React.FC</code>可以写成<code>React.FunctionComponent</code>。这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 声明Props类型</span><br><span class="line"> */</span><br><span class="line">export interface MyComponentProps &#123;</span><br><span class="line">  className?: string;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyComponent: FC&lt;MyComponentProps&gt; = props =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;hello react&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><p><a href="https://www.nextjs.cn/">https://www.nextjs.cn/</a></p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>要从头开始使用 React 构建一个完整的 Web 应用程序，需要考虑许多重要的细节：</p><ul><li>必须使用打包程序（例如 webpack）打包代码，并使用 Babel 等编译器进行代码转换。</li><li>你需要针对生产环境进行优化，例如代码拆分。</li><li>你可能需要对一些页面进行预先渲染以提高页面性能和 SEO。你可能还希望使用服务器端渲染或客户端渲染。</li><li>你可能必须编写一些服务器端代码才能将 React 应用程序连接到数据存储。</li></ul><p><strong>Next.js：React 开发框架</strong></p><ul><li>直观的、 <a href="https://www.nextjs.cn/docs/basic-features/pages">基于页面</a> 的路由系统（并支持 <a href="https://www.nextjs.cn/docs/routing/dynamic-routes">动态路由</a>）</li><li><a href="https://www.nextjs.cn/docs/basic-features/pages#pre-rendering">预渲染</a>。支持在页面级的 <a href="https://www.nextjs.cn/docs/basic-features/pages#static-generation-recommended">静态生成</a> (SSG) 和 <a href="https://www.nextjs.cn/docs/basic-features/pages#server-side-rendering">服务器端渲染</a> (SSR)</li><li>自动代码拆分，提升页面加载速度</li><li>具有经过优化的预取功能的 <a href="https://www.nextjs.cn/docs/routing/introduction#linking-between-pages">客户端路由</a></li><li><a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support">内置 CSS</a> 和 <a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#sass-support">Sass 的支持</a>，并支持任何 <a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#css-in-js">CSS-in-JS</a> 库</li><li>开发环境支持 <a href="https://www.nextjs.cn/docs/basic-features/fast-refresh">快速刷新</a></li><li>利用 Serverless Functions 及 <a href="https://www.nextjs.cn/docs/api-routes/introduction">API 路由</a> 构建 API 功能</li><li>完全可扩展</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nextjs-blog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="客户端导航"><a href="#客户端导航" class="headerlink" title="客户端导航"></a>客户端导航</h3><p>在 Next.js 中，页面是从<a href="https://www.nextjs.cn/docs/basic-features/pages"><code>pages</code>目录中</a>的文件导出的 React 组件。</p><p>页面与基于其<strong>文件名</strong>的路由相关联。例如，在开发中：</p><ul><li><code>pages/index.js</code>与<code>/</code>路由相关联。</li><li><code>pages/posts/first-post.js</code>与<code>/posts/first-post</code>路由相关联。</li></ul><p><strong>在页面之间导航</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#x27;next/link&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read &lt;Link href=&quot;/posts/first-post&quot;&gt;&lt;a&gt;this page!&lt;/a&gt;&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>该<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p><p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p><p>该<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p><p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p><p>这是您可以验证的简单方法：</p><ul><li>使用浏览器的开发人员工具将<code>background</code>CSS 属性更改<code>&lt;html&gt;</code>为<code>yellow</code>。</li><li>单击链接可在两个页面之间来回切换。</li><li>您会看到黄色背景在页面转换之间持续存在。</li></ul><p>这表明浏览器<em>未</em>加载完整页面并且客户端导航正在工作。</p><img src="https://www.nextjs.cn/static/images/learn/navigate-between-pages/client-side.gif" alt="Links" style="zoom:50%;" /><p>如果您使用了<code>&lt;a href=&quot;…&quot;&gt;</code>代替<code>&lt;Link href=&quot;…&quot;&gt;</code>并执行了此操作，则链接点击时背景颜色将被清除，因为浏览器会完全刷新。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>Next.js 支持具有动态路由的 pages（页面）。例如，如果你创建了一个命名为 <code>pages/posts/[id].js</code> 的文件，那么就可以通过 <code>posts/1</code>、<code>posts/2</code> 等类似的路径进行访问。</p><ul><li><code>pages/blog/[slug].js</code> → <code>/blog/:slug</code> (<code>/blog/hello-world</code>)</li><li><code>pages/[username]/settings.js</code> → <code>/:username/settings</code> (<code>/foo/settings</code>)</li><li><code>pages/post/[...all].js</code> → <code>/post/*</code> (<code>/post/2020/id/title</code>)</li></ul><h3 id="代码拆分和预取"><a href="#代码拆分和预取" class="headerlink" title="代码拆分和预取"></a>代码拆分和预取</h3><p>Next.js 会自动进行代码拆分，因此每个页面只加载该页面所需的内容。这意味着在呈现主页时，最初不会提供其他页面的代码。</p><p>这可确保即使您添加数百个页面，主页也能快速加载。</p><p>仅加载您请求的页面的代码也意味着页面变得孤立。如果某个页面抛出错误，应用程序的其余部分仍然可以工作。</p><p>此外，在 Next.js 的生产版本中，每当<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件出现在浏览器的视口中时，Next.js 都会在后台自动<strong>预取</strong>链接页面的代码。当您单击链接时，目标页面的代码已在后台加载，页面转换将近乎即时！</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p><code>&lt;Head&gt;</code>使用 代替小写字母<code>&lt;head&gt;</code>。<code>&lt;Head&gt;</code>是一个内置于 Next.js 的 React 组件。它允许您修改<code>&lt;head&gt;</code>页面的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Head from &#x27;next/head&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charSet</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&#123;props.description&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img统一放在public中，引用直接引用img，不需要添加图像路径</span><br><span class="line">src=&quot;/head.jpg&quot;</span><br></pre></td></tr></table></figure><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;`</span><br><span class="line">  …</span><br><span class="line">`&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这是使用一个名为<a href="https://github.com/vercel/styled-jsx">styled-jsx</a>的库。它是一个“CSS-in-JS”库——它允许你在 React 组件中编写 CSS，并且 CSS 样式将被<em>限定</em>（其他组件不会受到影响）。</p><p>Next.js 内置了对<a href="https://github.com/vercel/styled-jsx">styled-jsx 的</a>支持，但您也可以使用其他流行的 CSS-in-JS 库。我用的是materialUI框架中的css-in-js</p><ul><li><p>全局样式</p><p>如果你希望<strong>每个页面</strong>都加载一些 CSS，添加pages/_app.js文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;../styles/global.css&#x27;</span><br><span class="line">export default function App(&#123; Component, pageProps &#125;) &#123;</span><br><span class="line">  return &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个顶级styles目录并global.css在里面创建。将其导入pages/_app.js</p></li></ul><h2 id="内置API"><a href="#内置API" class="headerlink" title="内置API"></a>内置API</h2><p>某些页面需要获取外部数据以进行预渲染。有两种情况，在每种情况下，您都可以使用 Next.js 提供的特殊功能：</p><ol><li>您的页面 <strong>内容</strong> 取决于外部数据：使用 <code>getStaticProps</code>。</li><li>你的页面 <strong>paths（路径）</strong> 取决于外部数据：使用 <code>getStaticPaths</code> （通常还要同时使用 <code>getStaticProps</code>）。</li></ol><p><strong>getStaticProps</strong>函数在<strong>构建时</strong>被调用，并允许你在预渲染时将获取的数据作为 <code>props</code> 参数传递给页面。<strong>getStaticProps不会在页面组件中生效</strong></p><p>Next.js 允许你创建具有 <strong>动态路由</strong> 的页面。例如，你可以创建一个名为 <code>pages/posts/[id].js</code> 的文件用以展示以 <code>id</code> 标识的单篇博客文章。当你访问 <code>posts/1</code> 路径时将展示 <code>id: 1</code> 的博客文章。但是，在构建 <code>id</code> 所对应的内容时可能需要从外部获取数据。<strong>getStaticPaths</strong>函数在构建时被调用，并允许你指定要预渲染的路径。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数在构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取博文列表</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://.../posts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 据博文列表生成所有需要预渲染的路径</span></span><br><span class="line">  <span class="keyword">const</span> paths = posts.map(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: post.id &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ll pre-render only these paths at build time.</span></span><br><span class="line">  <span class="comment">// &#123; fallback: false &#125; means other routes should 404.</span></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让页面使用服务端渲染，你需要导出 getServerSideProps 异步函数。这个函数将在<strong>每次请求</strong>时在服务端被调用。例如，假设你的页面需要用最新的数据预渲染（通过外部的 api 获取数据）。你应该写下 getServerSideProps 来获取数据传递给 Page。</p><p>getServerSideProps 和 getStaticProps 很像，但是区别的是，getServerSideProps 是每个请求都会调用而不是在构建时。</p><h2 id="mardown解析"><a href="#mardown解析" class="headerlink" title="mardown解析"></a>mardown解析</h2><h3 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h3><p><a href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p><ul><li><p><a href="https://www.npmjs.com/package/react-markdown">react-markdown</a>将帮助我们解析和渲染 Markdown 文件</p></li><li><p>代码格式化：<code>react-syntax-highlighter</code>包</p></li><li><p>gray-matter](<a href="https://www.npmjs.com/package/react-markdown">https://www.npmjs.com/package/react-markdown</a>) 将解析我们博客的<em>顶部内容</em>。（文件顶部的部分<code>---</code> ）</p><p>我们需要这样的元数据<code>title</code>，<code>data</code> 并<code>description</code>和<code>slug</code>。您可以在此处添加任何您喜欢的内容</p></li></ul><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>slug</td><td>导航的参数</td></tr><tr><td>title</td><td>文章名称</td></tr><tr><td>data</td><td>最新时间</td></tr><tr><td>updated</td><td>文章更新日期</td></tr><tr><td>tags</td><td>文章標籤</td></tr><tr><td>category</td><td>文章分類</td></tr><tr><td>description</td><td>文章描述</td></tr></tbody></table><ul><li><a href="https://www.npmjs.com/package/raw-loader">raw-loader</a>将帮助我们导入我们的markdown文件。 </li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><a href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p><p><a href="https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js">https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js</a></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>material,classname报错，每次刷新，material失去效果。添加_app.js和__document.js文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> react技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> router </tag>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
            <tag> hooks </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/2020/09/25/%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/25/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>文本加粗标签   <strong></strong> <b></b>&gt; 工作里尽量使用strong</p><p>文本倾斜标签    <em></em>&gt;     <i></i>&gt;    工作里尽量使用em</p><p>删除线标签    <del></del>&gt;    <s></s>&gt;    工作里尽量使用del</p><p>下划线标签    <ins></ins>&gt;    <u></u>      工作里尽量使用ins</p><p> <sup>上标</sup>  <sub>下标</sub></p><p>超链接a:属性target,’_self’在自身页面打开，’_blank’打开一个新页面</p> <base target="_blank">  让所有的超链接都在新窗口打开<p>锚链接：<p id="sd"></p>    <a href="#sd">回到顶部</a></p><p>关键字：<mate name="keyword" content=""></p><p>网页描述:<mate name="description" content=""></p><p>网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com"></p><p>设置icon图标：<link rel="icon" href="xxx.ico"></p><p>img:<code>title</code>当鼠标滑动到元素上的时候显示,<code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>    <table><br>        <caption>23</caption><br>        <thead><br>            <th>1</th><br>            <th>2</th><br>            <th></th><br>        </thead><br>        <tbody><br>            <tr><br>                <td>1</td><br>                <td>1</td><br>                <td>1</td><br>            </tr><br>        </tbody><br>    </table></p><p>cellspacing：表示各单元格之间的空隙</p><p>cellpadding：表示单元格内容与单元格边界之间的距离</p><p>border-collapse:collapse;边框合并  </p><p>colspan=”2” 合并同一行上的单元格</p><p>rowspan=”2” 合并同一列上的单元格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">table    &#123; display: table &#125;</span><br><span class="line">tr       &#123; display: table-row &#125;</span><br><span class="line">thead    &#123; display: table-header-group &#125;</span><br><span class="line">tbody    &#123; display: table-row-group &#125;</span><br><span class="line">tfoot    &#123; display: table-footer-group &#125;</span><br><span class="line">col      &#123; display: table-column &#125;</span><br><span class="line">colgroup &#123; display: table-column-group &#125;</span><br><span class="line">td, th   &#123; display: table-cell &#125;</span><br><span class="line">caption  &#123; display: table-caption &#125;</span><br><span class="line">HTML Table是指使用原生的&lt;table&gt;标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。</span><br><span class="line">display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。</span><br></pre></td></tr></table></figure><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><fieldset></fieldset>  对表单信息分组<legend>分组</legend>   表单信息分组名称<optgroup label=""></optgroup>  对下拉列表select进行分组。Label=”” 分组名称。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  &lt;fieldset&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;legend&gt;信息分组名称&lt;/legend&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;select name=&quot;&quot; id=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;optgroup label=&quot;1&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/fieldset&gt;</span><br></pre></td></tr></table></figure><p><strong>表单元素属性</strong></p><ul><li>value 用于大部分表单元素的内容获取(option除外)</li><li>type 可以获取input标签的类型(输入框或复选框等)</li><li>disabled 禁用属性</li><li>checked 复选框选中属性</li><li>selected 下拉菜单选中属性</li></ul><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><strong>iframe</strong></h2><p>实际应用中，iframe可以当作一个子模块，像vue单一应用那样，选择菜单栏的选项，就切换页面相应的子模块。而使用原生的话，选择菜单栏的选项，就<strong>请求</strong>相应的iframe模块。</p><blockquote><p>如何知道是iframe模块？</p><p>右键点击，出现重新加载框架，点击重新加载框架，就局部加载该iframe模块</p></blockquote><p><img src="C:\Users\17355\Desktop\doc\document\img\总结\iframe.png" alt="iframe"></p><p><strong>注意如果要在iframe子页面获取父页面元素和window对象</strong>,因为iframe不存在公共的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>.parent.document).find(<span class="string">&#x27;selector&#x27;</span>).attr(<span class="string">&#x27;XXX&#x27;</span>)</span><br></pre></td></tr></table></figure><p>【iframe】同一个页面两个iframe，相互访问内部内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.页面b.html访问页面a.html中的laydateIn1</span><br><span class="line">window.parent.$(&quot;.panel-body&quot;)[0].contentWindow.$(&quot;#laydateIn1&quot;)</span><br><span class="line"></span><br><span class="line">2.页面a.html访问页面b.html中的c_stock</span><br><span class="line">window.parent.$(&quot;.panel-body&quot;)[1].contentWindow.$(&quot;#c_stock&quot;).val()</span><br><span class="line"></span><br><span class="line">3.重新加载iframe</span><br><span class="line">window.parent.$(&quot;iframe&quot;)[0].contentWindow.location.reload(true);</span><br></pre></td></tr></table></figure><h2 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;laoma&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--点击展示详细信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>HTML 5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This slide deck teaches you everything you need to know about HTML 5.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--小窗口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--进度条--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span>working...<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">low</span>=<span class="string">&quot;40&quot;</span> <span class="attr">high</span>=<span class="string">&quot;90&quot;</span> <span class="attr">optimum</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;91&quot;</span>&gt;</span>A+<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;toy.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- file text password radio checkbox button image submit reset select button --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some@email.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">min</span>=<span class="string">&quot;2010-08-14&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2011-08-14&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2010-08-14&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;50&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">results</span>=<span class="string">&quot;10&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;(555) 555-5555&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;^\(?\d&#123;3&#125;\)?[-\s]\d&#123;3&#125;[-\s]\d&#123;4&#125;.*?$&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;e.g. #bbbbbb&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">min</span>=<span class="string">&quot;-5&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p><strong>标签语义化</strong>：尽可能少的使用无语义的标签div和span；</p><p><strong>Charset  编码</strong>：</p><p>Ascll    Ansi    Unicode  Gbk     Gb2312    Big5    Utf-8  通用字符集</p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="class命名规范"><a href="#class命名规范" class="headerlink" title="class命名规范"></a>class命名规范</h2><p><a href="https://www.cnblogs.com/yyzyou/p/7920023.html">https://www.cnblogs.com/yyzyou/p/7920023.html</a></p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>头：header</p><p>页面主体：main</p><p>内容：content/container</p><p>侧栏：sidebar</p><p>栏目：column</p><p>页面外围控制整体布局宽度：wrapper</p><p>方向：left right center top bottom</p><p>内部： in</p><p>尾：footer</p><p>版权：copyright</p><h3 id="菜单和导航"><a href="#菜单和导航" class="headerlink" title="菜单和导航"></a>菜单和导航</h3><p>导航：nav</p><p>　　主导航：mainbav</p><p>　　子导航：subnav</p><p>　　顶导航：topnav</p><p>　　边导航：sidebar</p><p>　　左导航：leftsidebar</p><p>　　右导航：rightsidebar</p><p>菜单：menu</p><p>　　子菜单：submenu</p><p>​       下拉菜单:dropmenv</p><p>标签页：tab</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><table><thead><tr><th>文章列表：list</th><th align="center">提示信息：msg</th><th>小技巧：tips</th></tr></thead><tbody><tr><td>栏目标题：title</td><td align="center">字体：font</td><td>注释：note</td></tr><tr><td>文本：text</td><td align="center">摘要: summary</td><td></td></tr><tr><td></td><td align="center"></td><td></td></tr></tbody></table><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><table><thead><tr><th>加入：joinus</th><th>指南：guild</th><th>服务：service</th></tr></thead><tbody><tr><td>注册：regsiter</td><td>投票：vote</td><td>滚动：scroll</td></tr><tr><td>下载：download</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><table><thead><tr><th>当前的: current</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><table><thead><tr><th align="center">登录条：loginbar</th><th align="center">广告：banner</th><th align="center">功能区：shop</th></tr></thead><tbody><tr><td align="center">按钮：btn</td><td align="center">图标: icon</td><td align="center">线：line</td></tr><tr><td align="center">热点：hot</td><td align="center">新闻：news</td><td align="center">合作伙伴：partner</td></tr><tr><td align="center">友情链接：friendlink</td><td align="center">版权：copyright</td><td align="center">标签:label</td></tr><tr><td align="center">图片：pic</td><td align="center">首页：homepage</td><td align="center">模态：modal</td></tr><tr><td align="center">名片：card</td><td align="center">通知：notification</td><td align="center">平台：platform</td></tr><tr><td align="center">优惠券：coupon</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>样式文件命名<br>　　主要的:master.css<br>　　布局版面:layout.css<br>　　专栏:columns.css<br>　　文字:font.css<br>　　打印样式:print.css<br>　　主题:themes.css</p><h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><p><a href="https://blog.csdn.net/Jwhahaha/article/details/102483938">https://blog.csdn.net/Jwhahaha/article/details/102483938</a></p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p><ul><li>每个块级元素都是独自占一行。 </li><li>元素的高度、宽度、行高和边距都是可以设置的。　　 </li><li>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,<strong>高度由内容撑开</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">h1~h6:标题标签，用于标记网页中的大标题，依次从大到小</span><br><span class="line">p：用于标记网页中的段落性文字，默认占满横向区域</span><br><span class="line">div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽</span><br><span class="line">section：区段，是用来定义文档的某个区域，章节</span><br><span class="line">nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。</span><br><span class="line">header：标签定义文档的页眉</span><br><span class="line">footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等</span><br><span class="line">pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。</span><br><span class="line">address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行</span><br><span class="line">audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。</span><br><span class="line">/ 表格标签 /</span><br><span class="line">table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸</span><br><span class="line">thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tbody：表主体，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tr：表示一行</span><br><span class="line">th：表头中的第一个单元格</span><br><span class="line">td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列</span><br><span class="line">/ 有序列表，无序列表 /</span><br><span class="line">ul：无序列表</span><br><span class="line">ol：有序列表</span><br><span class="line">li：列表项</span><br><span class="line">dl：定义列表，用于描述类表中的项目（dt（dd））</span><br></pre></td></tr></table></figure><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素 inline"></a><strong>行内元素 inline</strong></h3><p>行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： </p><ul><li><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 </p></li><li><p>行内元素的高度、宽度、行高不可设置。 </p></li><li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p></li><li><p><strong>行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以</strong></p></li></ul><p>常见行内元素有以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化</span><br><span class="line"></span><br><span class="line">a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件</span><br><span class="line">有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址</span><br><span class="line">strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容</span><br><span class="line"></span><br><span class="line">b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调</span><br><span class="line">s：删除线，仅仅是删除的效果</span><br><span class="line">del：具有删除语义，delete删除</span><br><span class="line">em：强调文本，斜体展示</span><br><span class="line">sup：上标</span><br><span class="line">sub：下标</span><br></pre></td></tr></table></figure><h3 id="行内块级元素-inline-block"><a href="#行内块级元素-inline-block" class="headerlink" title="行内块级元素 inline-block"></a><strong>行内块级元素 inline-block</strong></h3><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p><ul><li>和其他行内或行内块级元素元素放置在同一行上；</li><li>元素的高度、宽度、行高以及顶和底边距都可设置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示</span><br><span class="line">button：按钮</span><br><span class="line">input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。</span><br><span class="line"></span><br><span class="line">单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值</span><br><span class="line">type=&quot;checkbox&quot;复选框</span><br><span class="line"></span><br><span class="line">label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态</span><br><span class="line">select:下拉列表</span><br><span class="line">option:下拉选项</span><br></pre></td></tr></table></figure><h2 id="float和position"><a href="#float和position" class="headerlink" title="float和position"></a>float和position</h2><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li><p>设置元素浮动后，对应的元素会脱离文档流，该元素的 <code>display</code> 值自动变成 <code>block</code></p></li><li><p>float 可以用来让文字环绕图片而已。</p></li><li><p>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p></li><li><p>假如某个div元素A是浮动的，如果A元素<strong>上一个元素也是浮动的</strong>，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素<strong>上一个元素是标准流中的元素</strong>，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。<a href="https://blog.csdn.net/qq_36595013/article/details/81810219">https://blog.csdn.net/qq_36595013/article/details/81810219</a></p><img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" /><p>假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。</p><img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" /><p>把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。</p></li><li><p><strong>清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear :none| left |right  | both</span><br><span class="line">none :允许两边都可以有浮动对象</span><br><span class="line">both :不允许有浮动对象</span><br><span class="line">left :不允许左边有浮动对象</span><br></pre></td></tr></table></figure></li><li><p>作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.CSS</span>浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动<span class="attribute">float</span>之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为<span class="number">0</span>。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。</span><br><span class="line">（<span class="number">1</span>）父元素使用<span class="attribute">overflow</span>:hidden来清除浮动，最好加上zoom:<span class="number">1</span>;</span><br><span class="line">（<span class="number">2</span>）父级<span class="selector-tag">div</span>定义<span class="attribute">height</span></span><br><span class="line">（<span class="number">3</span>）在父元素后面使用伪类：after和zoom</span><br><span class="line"><span class="selector-class">.box</span>:after&#123;</span><br><span class="line">display:block;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">2</span>）结尾处加空<span class="selector-tag">div</span>标签<span class="attribute">clear</span>:both</span><br><span class="line">（<span class="number">2</span>）对父元素设置display:table；使父元素形成BFC（块格式化上下文）</span><br><span class="line">BFC三个特性:防止上下margin重叠，防止浮动元素重叠，防止浮动塌陷</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷。</span><br><span class="line">给父级元素添加overflow:hidden</span><br></pre></td></tr></table></figure></li></ul><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><p><strong>position:absolute</strong></p><ul><li>会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。</li><li><strong>Z-index 仅能在定位元素上奏效（例如 position:absolute;）！</strong> </li><li>脱离文档流</li></ul></li><li><p><strong>position:relative</strong></p><ul><li><p>相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp" alt="img"></p></li></ul></li></ul><ul><li><strong>Position:fixed</strong><ul><li>固定定位之后，不占据原来的位置（脱标）</li><li>元素使用固定定位之后，会转化为行内块</li></ul></li></ul><p>不同点：position相应的块级元素会覆盖下面的内容（文字），而float只会覆盖块级元素，里面的文字会脱离</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><p><a href="https://www.jianshu.com/p/4d1dbb041bb2">https://www.jianshu.com/p/4d1dbb041bb2</a></p><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><p><strong>触发条件 (以下任意一条)</strong></p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><p><strong>BFC 特性及应用</strong></p><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%;" /><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%;" /><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%;" /><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%;" /><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%;" /><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p></li></ul><p><strong>开发中的应用</strong></p><ul><li>阻止<code>margin</code>重叠</li><li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 <code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li><p><strong>font-family</strong>:”Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana</p></li><li><p><strong>font-variant :</strong> <strong>normal</strong> | <strong>small-caps</strong>  设置字母字体 </p><p><strong>normal :</strong> 正常的字体     <strong>small-caps :</strong> 小型的大写字母字体 这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。</p></li><li><p><strong>text-transform :</strong> <strong>none</strong> | <strong>capitalize</strong>  | <strong>uppercase</strong> | <strong>lowercase</strong> </p><p><strong>capitalize :</strong> 　将每个单词的第一个字母转换成大写，其余无转换发生<br><strong>uppercase :</strong>  转换成大写<br><strong>lowercase :</strong> 　转换成小写</p></li><li><p><strong>text-decoration:</strong> none  |   underline   |     line-through</p></li><li><p><strong>text-indent :</strong> <em>length</em> 检索或设置对象中的文本的缩进。</p></li><li><p><strong>letter-spacing :</strong> <strong>normal</strong> | <em>length</em> （length允许为负值,px）检索或设置对象中的文字之间的间隔。</p></li><li><p><strong>text-size-adjust</strong>：auto | none | percentage 检索或设置移动端页面中对象文本的大小调整。</p><p>auto：文本大小根据设备尺寸进行调整。</p><p>none：文本大小不会根据设备尺寸进行调整。</p><p>percentage用百分比来指定文本大小在设备尺寸不同的情况下如何调整。</p></li><li><p><strong>direction</strong>: rtl把文本方向设置为“从右向左”；<br>ltr     默认。文本方向从左到右。<br>rtl     文本方向从右到左。<br>inherit     规定应该从父元素继承 direction 属性的值。</p></li><li><p><strong>line-height :</strong> <strong>normal</strong> | <em>length</em>  | inherit      行高 <strong>行高是指文本行基线间的垂直距离</strong> </p><p><a href="https://blog.csdn.net/a2013126370/article/details/82786681">https://blog.csdn.net/a2013126370/article/details/82786681</a></p><p><em>length :</em> 　百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小</p></li></ul><p><img src="https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>​    <strong>line-height=font-size+行间距</strong></p><blockquote><p>如果一个标签没有定义 <code>height</code> 属性，那么其最终表现的高度是由 <code>line-height</code> 决定的</p></blockquote><blockquote><p>一个容器没有设置高度，那么撑开容器高度的是 <code>line-height</code> 而不是容器内的文字内容</p></blockquote><blockquote><p>把 <code>line-height</code> 值设置为 <code>height</code> 一样大小的值可以实现单行文字的垂直居中</p></blockquote><ul><li><p><strong>vertical-align :</strong> middle|<em>length</em> </p><p>该属性定义display属性值为<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>table-cell</code>子元素<strong>相对父元素/相对整行/其它单元格的基线</strong>垂直对齐。允许指定负长度值和百分比值。 </p><ul><li>vertical-align不可继承，必须对<strong>子元素</strong>单独设置。</li></ul></li></ul><ul><li><p><a href="https://blog.csdn.net/qq_37210523/article/details/103145240">https://blog.csdn.net/qq_37210523/article/details/103145240</a></p><ul><li>white-space</li></ul><p><img src="https://img-blog.csdnimg.cn/2019111916525132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz,size_16,color_FFFFFF,t_70" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: normal;  <span class="comment">/*连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 */</span></span><br><span class="line"><span class="attribute">white-space</span>: nowrap;  <span class="comment">/* 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。*/</span></span><br><span class="line"><span class="attribute">white-space</span>: pre;  <span class="comment">/* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。*/</span></span><br><span class="line"><span class="attribute">white-space</span>: pre-wrap; <span class="comment">/* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。*/</span></span><br><span class="line"><span class="attribute">white-space</span>: pre-line;  <span class="comment">/* 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。*/</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">white-space</span>: break-spaces;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    与 pre-wrap的行为相同，除了：</span></span><br><span class="line"><span class="comment">    任何保留的空白序列总是占用空间，包括在行尾。</span></span><br><span class="line"><span class="comment">    每个保留的空格字符后都存在换行机会，包括空格字符之间。</span></span><br><span class="line"><span class="comment">    这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attribute">white-space</span>: inherit;</span><br><span class="line"><span class="attribute">white-space</span>: initial;</span><br><span class="line"><span class="attribute">white-space</span>: unset;</span><br></pre></td></tr></table></figure><ul><li><strong>word-break</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-break</span>：指定了怎样在单词内断行</span><br><span class="line"><span class="attribute">normal</span>只在允许的断字点换行（浏览器保持默认处理）。</span><br><span class="line">keep-all中文自动换行了，而英文使用默认换行方式 ---&gt;break-all</span><br><span class="line">break-word 允许正常的不能被分割的长单词强制分割换行</span><br><span class="line">//因为<span class="attribute">word-break</span>的break-word未列入标准，才会一般使用<span class="attribute">overflow-wrap</span>的break-word值</span><br><span class="line"><span class="attribute">overflow-wrap</span>(==<span class="attribute">word-wrap</span>) 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。</span><br><span class="line">break-all表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>white-space，控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line<br>word-break，控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all<br>word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是word-break的补充，它有两个值：normal | break-word</p></li><li><p><strong>text-overflow :</strong> <strong>clip</strong> | <strong>ellipsis</strong> </p><p><strong>clip :</strong> 　不显示省略标记（…），而是简单的裁切<br><strong>ellipsis :</strong> 　当对象内文本溢出时显示省略标记（…）  </p></li><li><p>文本缩略</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">4</span>) <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="comment">/*强制不换行 只在一行缩略  white-space: nowrap;*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/* 防止文本溢出 */</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="comment">/* 产生.....的效果 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="comment">/*-webkit-line-clamp:n;第n行缩略*/</span></span><br><span class="line">    -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>overflow: hidden;若第二行文字出现，因为间隔过小。可设置多行文字的间隔，line-height。</p></li></ul><h2 id="连写"><a href="#连写" class="headerlink" title="连写"></a>连写</h2><ul><li><p>font：font-style font-weight font-size/line-height font-family;</p><p>文本属性连写文字大小和字体为必写项。</p></li><li><p>border：color  style(solid实线dotted 点线dashed 虚线)   width</p><p>没有顺序要求，线型为必写项。</p></li><li><p>Padding: 20px;  上右下左内边距都是20px</p><p>Padding: 20px 30px;  上下20px  左右30px</p><p>Padding: 20px 30px 40px;  上内边距为20px 左右内边距为30px  下内边距为40</p><p>Padding: 20px 30px  40px 50px;  上20px 右30px 下40px 左 50px</p></li></ul><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><strong>clip :</strong> <strong>auto</strong> | <strong>rect (</strong> <em>number  number number number</em> **)**依据上-右-下-左的顺序剪切图像。必须将<a href="c_position.html">position</a>的值设为absolute，此属性方可使用。</p><p>clip-path  裁切一个圆角 inset(<top> <right> <bottom> <left> round <top-radius> <right-radius><bottom-radius> <left-radius>) </p><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p><a href="https://www.runoob.com/cssref/pr-object-fit.html">https://www.runoob.com/cssref/pr-object-fit.html</a></p><p>object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。</p><p>object-fit 一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">fill</td><td align="left">默认，不保证保持原有的比例，内容拉伸填充整个内容容器。</td></tr><tr><td align="left">contain</td><td align="left">保持原有尺寸比例。内容被缩放。</td></tr><tr><td align="left">cover</td><td align="left">保持原有尺寸比例。但部分内容可能被剪切。</td></tr><tr><td align="left">none</td><td align="left">保留原有元素内容的长度和宽度，也就是说内容不会被重置。</td></tr><tr><td align="left">scale-down</td><td align="left">保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。</td></tr><tr><td align="left">initial</td><td align="left">设置为默认值，<a href="https://www.runoob.com/cssref/css-initial.html">关于 <em>initial</em></a></td></tr><tr><td align="left">inherit</td><td align="left">从该元素的父元素继承属性。 <a href="https://www.runoob.com/cssref/css-inherit.html">关于 <em>inherit</em></a></td></tr></tbody></table><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="元素的水平居中"><a href="#元素的水平居中" class="headerlink" title="元素的水平居中"></a>元素的水平居中</h3><ul><li><p>元素为行内元素，设置父元素<code>text-align:center</code></p></li><li><p>如果子元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</p></li><li><p>绝对定位和移动: <code>absolute + transform</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent_box&#123;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .child_box&#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate( -50%,0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</p></li><li><p>```<br>display:block;<br>margin:auto;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 元素的垂直居中</span><br><span class="line"></span><br><span class="line">- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`</span><br><span class="line"></span><br><span class="line">- 使用`flex`布局，设置为`align-item：center`</span><br><span class="line"></span><br><span class="line">- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`</span><br><span class="line"></span><br><span class="line">- 绝对定位和移动: `absolute + transform`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.parent_box{</p><pre><code>        width: 400px;        height: 200px;        position: relative;    &#125;    .child_box&#123;        width: 200px;        height: 100px;        position: absolute;        left: 0;        top: 50%;        transform: translate( 0，-50%);    &#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值</span><br><span class="line"></span><br><span class="line">- 文本垂直居中设置`line-height`为`height`值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 垂直水平居中</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">/** 1 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: -50px 0 0 -50px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 2 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 3 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 4 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>如何垂直居中一个<code>&lt;img&gt;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#container     /**&lt;img&gt;的容器设置如下**/</span><br><span class="line">&#123;</span><br><span class="line">    display:table-cell;</span><br><span class="line">    text-align:center;</span><br><span class="line">    vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式 优先级1000</p></li><li><p>id选择器                                        优先级100</p></li><li><p>类选择器和伪类和属性                 优先级10</p></li><li><p>标签选择器和伪元素                     优先级1</p></li><li><p>通配符选择器                                优先级0</p></li><li><p>浏览器自定义或继承                    没有优先级</p><p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p></li><li><p>如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式</p></li><li><p>交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较</p></li><li><p>并集的话 就是各算各的。</p></li></ol><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> </span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>相邻兄弟选择器 A + B<br>普通兄弟选择器 A ~ B<br>子选择器 A &gt; B<br>后代选择器 A B</p><p>交集<br>A.B{<br>}<br>并集<br>A, B｛<br>｝ </p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:link&#123;属性:值;&#125;       链接默认状态 </span><br><span class="line">a:visited&#123;属性:值;&#125;     链接访问之后的状态 </span><br><span class="line">a:hover&#123;属性:值;&#125;      鼠标放到链接上显示的状态  a:active&#123;属性:值;&#125;      链接激活的状态</span><br><span class="line">a:focus&#123;属性:值；&#125;     获取焦点</span><br></pre></td></tr></table></figure><ul><li><code>p:first-of-type</code> 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-of-type(n)</code> 选择E的父元素下的第n个E元素</li><li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li><li><code>:before</code> 在元素之后添加内容。</li><li><code>:enabled</code> 已启用的表单元素。</li><li><code>:disabled</code> 已禁用的表单元素。</li><li><code>:checked</code> 单选框或复选框被选中。</li><li><code>:empty</code> 选中没有任何子节点的E元素；</li></ul><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">伪元素特性</span><br><span class="line">减少 dom 节点数,但不利于不利于 SEO</span><br><span class="line">它不存在于文档中，所以 js 无法操作它</span><br><span class="line">它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件</span><br></pre></td></tr></table></figure><ul><li>E::selection 可改变选中文本的样式</li></ul><ul><li>E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。</li></ul><ul><li><p>E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">块级元素才能有:before, :after，譬如 img 就不能设置，亦即某些元素是没有:before, :after 的</span><br><span class="line">伪类元素的display是默认值inline</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）各种图标</span><br><span class="line">利用这两个伪类，可以实现需要简单的图标</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">attr</span>()</span><br><span class="line">通过<span class="built_in">attr</span>()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。</span><br><span class="line">a::after&#123;</span><br><span class="line">    content:  <span class="built_in">attr</span>(href) ;</span><br><span class="line">&#125;</span><br><span class="line">element<span class="selector-class">.setAttribute</span>(&quot;data-age&quot;,age);</span><br><span class="line">element<span class="selector-class">.dataset</span><span class="selector-attr">[<span class="string">&quot;age&quot;</span>]</span></span><br><span class="line">&lt;<span class="selector-tag">a</span> href=&quot;http://www.cnblogs.com/starof<span class="string">&quot;&gt;starof&lt;/a&gt;</span></span><br><span class="line"><span class="string">（3）引用媒体文件</span></span><br><span class="line"><span class="string">a::before&#123;</span></span><br><span class="line"><span class="string">    content: url(&quot;</span>https://www.baidu.com/img/baidu_jgylogo3.gif<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">（4）清除浮动</span></span><br><span class="line"><span class="string">.cf:before,</span></span><br><span class="line"><span class="string">.cf:after &#123;</span></span><br><span class="line"><span class="string">    content: &quot;</span> <span class="string">&quot;;</span></span><br><span class="line"><span class="string">    display: table; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.cf:after &#123;</span></span><br><span class="line"><span class="string">    clear: both;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h2><ul><li>Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数</li></ul><ul><li>```<br>visibility:hidden; 隐藏元素  隐藏之后还占据原来的位置。<br>opacity=0，该元素隐藏起来了，但不会改变页面布局,还占据原来的位置<br>display:none;隐藏元素  隐藏之后不占据原来的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>透明度<br>background-color: rgba(0, 0, 0, 0.3);<br>opacity: 0.3;<br>transparent是颜色的一种，这种颜色叫透明色。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）</span><br><span class="line"></span><br></pre></td></tr></table></figure>input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {<pre><code>color: #666;font-size: 16px;</code></pre>  }  input:-moz-placeholder, textarea:-moz-placeholder {<pre><code>color: #666;font-size: 16px;</code></pre>  }  input::-moz-placeholder, textarea::-moz-placeholder {<pre><code>color: #666;font-size: 16px;</code></pre>  }  input:-ms-input-placeholder, textarea:-ms-input-placeholder {<pre><code>color: #666;font-size: 16px;</code></pre>  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># css3</span><br><span class="line"></span><br><span class="line">## 盒模型</span><br><span class="line"></span><br><span class="line">https://www.imooc.com/article/68238</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg&quot; alt=&quot;1.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">标准盒子模型</span><br><span class="line"></span><br></pre></td></tr></table></figure>盒子实际内容（content）的width/height=我们设置的width/height;<br>盒子总宽度/高度=width/height+padding+border+margin。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IE盒子模型</span><br><span class="line"></span><br></pre></td></tr></table></figure>content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)<br>盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**box-sizing 常用的属性有哪些？分别有什么作用**</span><br><span class="line"></span><br><span class="line">- `box-sizing: content-box;` 默认的标准(W3C)盒模型元素效果</span><br><span class="line">- `box-sizing: border-box;` 触发怪异(IE)盒模型元素的效果</span><br><span class="line">- `box-sizing: inherit;` 继承父元素 `box-sizing` 属性的值</span><br><span class="line"></span><br><span class="line">## 阴影</span><br><span class="line"></span><br><span class="line">文本阴影：text-shadow </span><br><span class="line"></span><br><span class="line">color  length  lenth opacity  [ inset(阴影向内) ] </span><br><span class="line"></span><br><span class="line">颜色 水平偏移量  垂直偏移量  模糊度  （缩展量）</span><br><span class="line"></span><br><span class="line">边框阴影 ：border-shadow</span><br><span class="line"></span><br><span class="line">box-shadow：[inset(阴影向内)]  水平偏移量  垂直偏移量  模糊度  （缩展量）  颜色</span><br><span class="line"></span><br><span class="line">## 边框圆角box-radius</span><br><span class="line"></span><br><span class="line"> 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（**顺时针方向**） </span><br><span class="line"></span><br><span class="line"> 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。 </span><br><span class="line"></span><br><span class="line"> 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角 </span><br><span class="line"></span><br><span class="line"> 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;</span><br><span class="line"></span><br><span class="line">**outline :**[ **outline-color** ](c_outlinecolor.html)||[**outline-style** ](c_outlinestyle.html)||[ **outline-width** ](c_outlinewidth.html)</span><br><span class="line"></span><br><span class="line">设置或检索对象外的线条轮廓。outline画在[border](c_border.html)外面，并且不一定是矩形</span><br><span class="line"></span><br><span class="line">## 边框图像</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-image-source: url(images/border.png);<br>border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。<br>border-image-width: 10px;指定图像边界的宽度：<br>border-image-repeat: round/stretch/repeat;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 背景</span><br><span class="line"></span><br><span class="line">**background:color url  repeat position  attachment**</span><br><span class="line"></span><br><span class="line">设置背景颜色会填充content,padding。</span><br><span class="line"></span><br><span class="line">连写的时候没有顺序要求，url为必写项  </span><br><span class="line"></span><br><span class="line">- **background-position:left top**</span><br><span class="line"></span><br><span class="line">- **background-attachment :** **scroll** | **fixed**  </span><br><span class="line"></span><br><span class="line">  **scroll :** 　背景图像是随对象内容滚动</span><br><span class="line">  **fixed :** 　背景图像固定 </span><br><span class="line"></span><br><span class="line">- **background-clip**：padding-box/content-box/border-box;  修改背景颜色区域/规定背景的绘制区域。</span><br><span class="line"></span><br><span class="line">- **background-origin:** border-box;修改背景图片所在区域</span><br><span class="line"></span><br><span class="line">- **background-position:**center center;图片水平垂直居中</span><br><span class="line"></span><br></pre></td></tr></table></figure>background-size<br>cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。<br>contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 渐变</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>background-image：linear-gradient();radial-gradient()<br>repeating-linear-gradient   repeating-radial-gradient</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 伸缩布局</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>display: flex; 会浮动<br>justify-content: space-between;两端对齐布局（伸缩布局）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>flex-direction: column;决定主轴的方向(即子元素的排列方向)<br>调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>justify-content（水平方向）定义了子元素在主轴上的对齐方式<br>主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>align-items（垂直方向）定义子元素在侧轴上如何对齐<br>调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p> flex-wrap<br> 控制是否换行，包括wrap、nowrap （不换行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用<br>可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>flex<br>控制子元素伸缩比例 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>align-self 侧轴上单个项目对齐方式<br>单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p>flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">order **定义子元素的排列顺序, 数值越小 排列越靠前 默认为0** </span><br><span class="line"></span><br><span class="line">## 多列布局</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>/<em>设置分成几列</em>/-webkit-column-count: 4;<br>/<em>当列宽</em>列数乘积大于盒子总宽，会自动调整列数*/<br>-webkit-column-width: 400px;<br>/<em>调整列之间的宽度</em>/<br>-webkit-column-gap: 60px;<br>-webkit-column-rule: 2px dashed #CCC;</p><p>//标题单独置一列<br>/<em>all代表所有列</em>/<br>-webkit-column-span: all;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置分成几列-webkit-column-count: 3;<br>当列宽*列数乘积大于盒子总宽，会自动调整列数-webkit-column-width: 200px;<br>调整列之间的宽度-webkit-column-gap: 60px;<br>-webkit-column-rule: 2px dotted #CCC;分割线设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 响应式</span><br><span class="line"></span><br><span class="line">### 单位</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/liwusen/article/details/80834546</span><br><span class="line"></span><br><span class="line">#### 像素px</span><br><span class="line"></span><br><span class="line">像素是网页布局的基础，**一个像素表示计算机屏幕所能显示的最小区域**，像素分为：**css像素和物理像素**。</span><br><span class="line"></span><br><span class="line">**css像素**：我们在js或者css代码中使用的px单位</span><br><span class="line"></span><br><span class="line">**物理像素(设备像素)**：只与设备或者说硬件有关，同样尺寸的屏幕，**设备的密度越高，物理像素也就越多**。</span><br><span class="line"></span><br><span class="line">**像素比(DRP)**：表示一个CSS像素占用几个物理像素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 CSS像素 = 物理像素／分辨率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>//有一个750px * 1134px的视觉稿<br>//pc端的布局视口通常情况下为980px<br>PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px<br>//移动端以iphone6为例，分辨率为375 * 667<br>iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px<br>//在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还有一个因素也会引起css中px的变化，那就是**用户缩放**。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。(1px 的宽度在 devicePixelRatio 等于 1.5 的设备上要放大 1.5 倍来显示，同时设备又不可能显示半个像素，只能取整处理) </span><br><span class="line"></span><br><span class="line">在移动端浏览器中以及某些桌面浏览器中，window对象有一个**devicePixelRatio**(设备像素比)属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 **devicePixelRatio = 物理像素 / 独立像素**。css中的**px就可以看做是设备的独立像素**，所以通过devicePixelRatio，我们可以知道该设备上**一个css像素代表多少个物理像素**。</span><br><span class="line"></span><br><span class="line">#### 视口</span><br><span class="line"></span><br><span class="line">**视口针对移动设备，对PC没用**</span><br><span class="line"></span><br><span class="line">(1) 布局视口（layout viewport）</span><br><span class="line">布局视口定义了pc网页在移动端的默认布局行为，因为通常pc的分辨率较大，布局视口默认为980px。也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示。因此我们可以明显看出来，默认为布局视口时，根植于pc端的网页在移动端展示很模糊。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2018/07/1532326331-2895-201407.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">(2) 视觉视口（visual viewport）</span><br><span class="line">视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2018/07/1532326332-9414-201407.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">(3) 理想视口（ideal viewport）</span><br><span class="line"></span><br><span class="line">理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。</span><br><span class="line"></span><br><span class="line">**应用**</span><br><span class="line"></span><br><span class="line">移动设备默认的viewport是layout viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。</span><br><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br><span class="line"></span><br><span class="line">该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</span><br><span class="line"></span><br><span class="line">| width         | 设置***layout viewport*** 的宽度，为一个正整数，或字符串&quot;width-device&quot; |</span><br><span class="line">| ------------- | ------------------------------------------------------------ |</span><br><span class="line">| initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数                 |</span><br><span class="line">| minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数                 |</span><br><span class="line">| maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数                 |</span><br><span class="line">| height        | 设置***layout viewport*** 的高度，这个属性对我们并不重要，很少使用 |</span><br><span class="line">| user-scalable | 是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许 |</span><br><span class="line"></span><br><span class="line">#### rem</span><br><span class="line"></span><br><span class="line">相对于根元素html的font-size值的大小，此单位若要用于屏幕自适应，可与vw配合使用设置根元素的字体大小。375px的网页的设计稿。此时，1vw=3.75px；4vw=15px；8vw=30px；</span><br><span class="line"></span><br><span class="line">#### 百分比%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 子元素**width**或**height**的百分比是**父元素width或height的百分比**</span><br><span class="line">2. **top**、**bottom**的百分比是相对于(默认定位)**父元素的height**</span><br><span class="line">3. **left**、**right**的百分比是相对于(默认定位)**父元素的width**</span><br><span class="line">4. **padding**、**margin**不论是垂直方向或者是水平方向，都相对于直接**父元素的width**</span><br><span class="line">5. **border-radius**、**translate**、**background-size**的百分比，则是相对于**自身的width**</span><br><span class="line"></span><br><span class="line">**两个缺点：**</span><br><span class="line"></span><br><span class="line">（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</span><br><span class="line">（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</span><br><span class="line"></span><br><span class="line">### 自适应</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/chenyoumei/p/10510321.html</span><br><span class="line"></span><br><span class="line">- 查看设计图，确定页面布局，组件的复用等</span><br><span class="line"></span><br><span class="line">- 尽可能的添加多的div来包含元素，并设置对应的classauto</span><br><span class="line"></span><br><span class="line">- 外层盒子使用flex进行布局，不设置绝对宽高px(使用rem或者%布局)，高度由里面的内容撑开（**撑不开就用margin、padding**）。**最外层盒子**设置为设计图的宽度（一般我是设置为19.2rem），并使用</span><br><span class="line"></span><br><span class="line">  `box-sizing:border-box以及margin：auto`</span><br><span class="line"></span><br><span class="line">- 内层盒子使用rem布局。</span><br><span class="line"></span><br><span class="line">- **Tips**</span><br><span class="line"></span><br><span class="line">  - float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</span><br><span class="line"></span><br><span class="line">  - 图片的自适应（fluid image）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  img { width: auto; max-width: 100%; }<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自适应exportExcel</span><br><span class="line"></span><br><span class="line">  - yd ui 移动端</span><br><span class="line"></span><br><span class="line">    https://blog.csdn.net/weixin_44823323/article/details/99640765</span><br><span class="line"></span><br><span class="line">    https://www.jianshu.com/p/b00cd3506782</span><br><span class="line"></span><br><span class="line">    ~~自适应不是指你缩放**页面大小**(ctrl+鼠标滚动条)，是指你浏览器大小变化自适应~~。</span><br><span class="line">  </span><br><span class="line">    一般不加自适应，缩放页面，会发现`$(document).width()`会根据缩放变大变小，但是**元素宽高不会变**，相应元素就会**感觉**变大变小。加入自适应（**自适应会根据页面大小来改变px，元素宽高会变**），缩放页面，相应元素**感觉**不会改变。</span><br><span class="line">  </span><br><span class="line">    **缩放页面大小有三种情况：**</span><br><span class="line">  </span><br><span class="line">    1. 改变浏览器宽高</span><br><span class="line">    2. ctrl+鼠标滚动条，改变页面大小</span><br><span class="line">    3. window中显示设置中的缩放与布局</span><br><span class="line">  </span><br><span class="line">    &gt; 像素比就是第二种和第三种情况</span><br><span class="line">  </span><br><span class="line">    ```css</span><br><span class="line">    (function (doc, win) &#123;</span><br><span class="line">            var docEl = doc.documentElement,</span><br><span class="line">                resizeEvt = &#x27;orientationchange&#x27; in window ? &#x27;orientationchange&#x27; : &#x27;resize&#x27;,</span><br><span class="line">                recalc = function () &#123;</span><br><span class="line">                    var clientWidth = docEl.clientWidth;</span><br><span class="line">                    if (!clientWidth) return;</span><br><span class="line">                    if(clientWidth&gt;=640)&#123;</span><br><span class="line">                        docEl.style.fontSize = &#x27;100px&#x27;;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        docEl.style.fontSize = 100 * (clientWidth / 640) + &#x27;px&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">    </span><br><span class="line">            if (!doc.addEventListener) return;</span><br><span class="line">            win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">            doc.addEventListener(&#x27;DOMContentLoaded&#x27;, recalc, false);</span><br><span class="line">        &#125;)(document, window);</span><br></pre></td></tr></table></figure></p><ul><li>媒体查询</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a href="http://www.animate.net.cn/1853.html">http://www.animate.net.cn/1853.html</a></p><h3 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h3><p>第一种叫过渡（transition）动画，就是从初始状态过渡到结束状态这个过程中所产生的动画。所谓的状态就是指大小、位置、颜色、变形（transform）等等这些属性。css过渡只能定义首和尾两个状态，所以是最简单的一种动画。</p><p><strong>参数</strong></p><ul><li>property – 什么属性将用动画表现，例如, opacity。</li><li>duration –  过渡的时间 </li><li>transition-delay – 设置过渡延时</li><li>timing-function  – 过渡的速度<ul><li>匀速linear  逐渐降速ease 加速ease-in 降速ease-out  先加速后减速ease-in-out</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform 和 transition 属性实现简单旋转效果的例子：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;transition: transform 3s ease-in&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">onclick</span>=<span class="string">&quot;this.style.transform=&#x27;rotate(360deg)&#x27;&quot;</span>&gt;</span></span><br><span class="line">点击这个方块，能让它旋转起来。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>第二种叫做关键帧（keyframes）动画。不同于第一种的过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，或者用关键帧来说的话，过渡动画只能定义第一帧和最后一帧这两个关键帧，而关键帧动画则可以定义任意多的关键帧，因而能实现更复杂的动画效果。</p><p>关键帧动画的定义方式也比较特殊，它使用了一个关键字 @keyframes 来定义动画。具体格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称&#123;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>animation-name:动画名称</li><li>animation-duration: 动画完成一个周期所花费的秒，默认为0</li><li>animation-timing-function: 动画的速度，默认ease</li><li>animation-delay：动画延时，默认为0</li><li>animation-iteration-count: 动画播放次数，默认为1，infinite无限次</li><li>animation-direction：动画是否再下一个周期逆向播放</li><li>animation-play-state：动画是否正在运行或暂停，默认是running，paused</li><li>animation-fill-mode：动画时间之外的状态    </li></ul><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5821d8e8b8bb59a5387d17dd3100ad21.png" alt="QQ截图20131102123530"></p><p> 这段代码定义了一个名为demo,且有5个关键帧的动画。0% ，10% 等这些表示的是时间点，是相对于整个动画的持续时间来说的，时间点之后的花括号里则是元素的状态属性集合，描述了这个元素在这个时间点的状态，动画发生时，就是从第一个状态到第二个状态进行过渡，然后从第二个状态到第三个状态进行过渡，直到最后一个状态。一般来说，0%和100%这两个关键帧是必须要定义的。</p><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/6e21739e7cb9ee141063b0bceb541fa2.png" alt="QQ截图20131102123530"></p><p>注意，为了达到最佳的浏览器兼容效果，在实际书写代码的时候，还必须加上各大浏览器的私有前缀</p><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5e08c5fe40dbf1178ed6283aba8f5843.png" alt="QQ截图20131102123530"></p><h3 id="转化transform"><a href="#转化transform" class="headerlink" title="转化transform"></a>转化transform</h3><p>CSS**<code>transform</code>**属性允许你旋转，缩放，倾斜或平移给定元素。</p><p>示例：<a href="https://www.vps5.com/example?pid=2959">https://www.vps5.com/example?pid=2959</a></p><ul><li><p>transform: rotate(360deg);旋转   </p></li><li><p>transform: skew(45deg);倾斜      </p></li><li><p>transform: scale(1.5);盒子扩大1.5倍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何实现小于12px的字体效果</span><br><span class="line">transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;</span><br><span class="line"></span><br><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure></li><li><p>transform: translate(400px) 向左移动400px    translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%</p></li></ul><h3 id="3D"><a href="#3D" class="headerlink" title="3D"></a><strong>3D</strong></h3><p><strong>3D 转换方法</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td align="left">定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr><tr><td align="left">translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td align="left">定义 3D 转化。</td></tr><tr><td align="left">translateX(<em>x</em>)</td><td align="left">定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td align="left">scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td align="left">定义 3D 缩放转换。</td></tr><tr><td align="left">scaleX(<em>x</em>)</td><td align="left">定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td align="left">rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td align="left">定义 3D 旋转。</td></tr><tr><td align="left">rotateX(<em>angle</em>)</td><td align="left">定义沿 X 轴的 3D 旋转。</td></tr></tbody></table><p><strong>3D 转换属性</strong></p><ul><li><p><a href="https://www.w3school.com.cn/cssref/pr_transform.asp">transform</a>：向元素应用 2D 或 3D 转换</p></li><li><p><a href="https://www.w3school.com.cn/cssref/pr_transform-origin.asp">transform-origin</a>：变形的原点，允许你改变被转换元素的位置。默认情况，变形的原点在元素的中心点，或者是元素X轴和Y轴的50%处。</p><p>示例：<a href="https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html">https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html</a></p></li><li><p><a href="https://www.w3school.com.cn/cssref/pr_transform-style.asp">transform-style</a>：规定<strong>被嵌套元素</strong>如何在 3D 空间中显示。</p><p>设置transform-style的值为flat，则该元素的所有<strong>子元素</strong>都将被平展到该元素的2D平面中呈现</p><p>设置transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中</p><p>示例：<a href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style</a></p></li><li><p><a href="https://www.w3school.com.cn/cssref/pr_perspective.asp">perspective</a>：定义 3D 元素的景深，当为元素定义 perspective 属性时，其<strong>子元素</strong>会获得透视效果，而不是元素本身（透视效果是写在父亲身上，而不是元素本身）。</p><p>用来设置用户和元素3D空间Z平面之间的距离。值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。</p><p>示例：<a href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1</a></p></li><li><p><a href="https://www.w3school.com.cn/cssref/pr_perspective-origin.asp">perspective-origin</a>：perspective属性的源点角度</p></li><li><p><a href="https://www.w3school.com.cn/cssref/pr_backface-visibility.asp">backface-visibility</a>：定义元素在不面对屏幕时是否可见。</p></li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:600px) &#123;   </span><br><span class="line">body &#123;      background-color: blue;   &#125;&#125;</span><br><span class="line">@media screen and (min-width:900px) &#123;  </span><br><span class="line">body &#123;      background-color: red;   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h1><p><strong>css预处理器sass</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　$blue : #1875e7;　</span><br><span class="line"></span><br><span class="line">　　div &#123;</span><br><span class="line">　　　color : $blue;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　$side : left;</span><br><span class="line"></span><br><span class="line">　　.rounded &#123;</span><br><span class="line">　　　　border-#&#123;$side&#125;-radius: 5px;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a><strong>计算功能</strong></h2><p>SASS允许在代码中使用算式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　body &#123;</span><br><span class="line">　　　　margin: (14px/2);</span><br><span class="line">　　　　top: 50px + 100px;</span><br><span class="line">　　　　right: $var * 10%;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h2><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div h1 &#123;</span><br><span class="line">　　　　color : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　div &#123;</span><br><span class="line">　　　　hi &#123;</span><br><span class="line">　　　　　　color:red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>属性也可以嵌套，比如border-color属性，可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　p &#123;</span><br><span class="line">　　　　border: &#123;</span><br><span class="line">　　　　　　color: red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在嵌套的代码块内，可以<strong>使用&amp;引用父元素</strong>。比如a:hover伪类，可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　a &#123;</span><br><span class="line">　　　　&amp;:hover &#123; color: #ffb3ff; &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong></p><p>SASS共有两种注释风格。</p><p>标准的CSS注释 /* comment */ ，会保留到编译后的文件。</p><p>单行注释 // comment，只保留在SASS源文件中，编译后被省略。</p><p>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">　　　　重要注释！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　.class1 &#123;</span><br><span class="line">　　　　border: 1px solid #ddd;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>class2要继承class1，就要使用@extend命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　.class2 &#123;</span><br><span class="line">　　　　@extend .class1;</span><br><span class="line">　　　　font-size:120%;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a><strong>Mixin</strong></h3><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p><p>使用@mixin命令，定义一个代码块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin left &#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　margin-left: 10px;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>使用@include命令，调用这个mixin。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">　　　　@include left;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>mixin的强大之处，在于可以指定参数和缺省值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　@mixin left($value: 10px) &#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　margin-right: $value;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，根据需要加入参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　div &#123;</span><br><span class="line">　　　　@include left(20px);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="通识"><a href="#通识" class="headerlink" title="通识"></a>通识</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头</span><br><span class="line">驼峰命名法。首字母小写，后面单词的首字母需要大写</span><br></pre></td></tr></table></figure><h3 id="数值判断转换"><a href="#数值判断转换" class="headerlink" title="数值判断转换"></a><strong>数值判断转换</strong></h3><ul><li><p>NaN：not a number 该属性用于指示某个值不是数字。 </p><ul><li>NaN 与任何值都不相等，包括他本身</li></ul></li><li><p>isNaN: is not a number判断是否是数字，若是数字返回false</p></li><li><p>isFinite(number ) 函数用于检查其参数是否是无穷大。</p><p><strong>提示：</strong> 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined</span><br><span class="line">null表示一个空，变量的值如果想为null，必须手动设置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象</span><br><span class="line">转换成false  空字符串  0  false  null  undefined</span><br></pre></td></tr></table></figure><p>转换成字符串类型：</p><ul><li>toString() String() 拼接字符串方式</li></ul><p><strong>转换成数值类型：</strong></p><ul><li><p>1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN </p></li><li><p>2.parseInt() </p></li><li><p>3.parseFloat()</p></li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a><strong>堆栈</strong></h3><p><strong>栈：</strong></p><ul><li><p>存储基础数据类型</p></li><li><p>栈会开辟一个内存</p></li><li><p>按值访问</p></li><li><p>存储的值大小固定</p></li><li><p>由系统自动分配内存空间</p></li><li><p>空间小，运行效率高</p></li><li><p>先进后出，后进先出</p></li><li><p>栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。</p></li><li><p>微任务和宏任务</p><p><strong>栈先进后出，队列先进先出</strong></p></li></ul><p><strong>堆:</strong></p><ul><li>存储引用数据类型</li><li>堆共用同一个内存</li><li>按引用访问</li><li>存储的值大小不定，可动态调整</li><li>主要用来存放对象</li><li>空间大，但是运行效率相对较低</li><li>无序存储，可根据引用直接获取</li></ul><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="位置获取"><a href="#位置获取" class="headerlink" title="位置获取"></a>位置获取</h3><h4 id="获取鼠标当前位置（事件对象）"><a href="#获取鼠标当前位置（事件对象）" class="headerlink" title="获取鼠标当前位置（事件对象）"></a>获取鼠标当前位置（事件对象）</h4><ul><li><p>offsetX、offsetY：  鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。内填充边意思是不包含border，但包含padding，类似于padding-box。</p></li><li><p>clientX、clientY： 鼠标当前位置 相对于 <strong>视口</strong>顶部、浏览器可视区域左部 的位置；</p></li><li><p>pageY、pageX：     鼠标当前位置 相对于 <strong>页面/文档</strong>顶部、<strong>页面/文档</strong>左部的位置；</p></li><li><p>screenY、screenX：鼠标当前位置 相对于 <strong>屏幕</strong>顶部、屏幕左部的位置；</p><p><strong>他们均是鼠标事件的一级属性 ，如e.clientY</strong></p></li></ul><p><img src="https://segmentfault.com/img/bVXWPA?w=1043&h=552" alt="图片描述"></p><p><img src="https://upload-images.jianshu.io/upload_images/1811036-510a2fbcd5bb2d17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="img"></p><p>Element.getBoundingClientRect()   获取元素相对于<strong>视口</strong>的位置 </p><p>top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。</p><p><img src="https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/240/format/webp" alt="img"></p><p><code>window.scrollTo(options)</code>方法,<code>options</code>是一个对象，有三个属性：<br><code>top</code>，<code>left</code><br><code>behavior</code> 类型String,表示滚动行为,支持参数 <code>smooth</code>(平滑滚动),<code>instant</code>(瞬间滚动),默认值auto（等同于<code>instant</code>）</p><h4 id="获取元素当前位置"><a href="#获取元素当前位置" class="headerlink" title="获取元素当前位置"></a>获取元素当前位置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName(&quot;scroll&quot;)[0].clientHeight</span><br></pre></td></tr></table></figure><ul><li><p>clientHeight：内容+padding（上下）</p><p>clientWidth：内容+padding（左右）</p></li><li><p>offsetTop：从边框border（不包含）距离父元素的高度距离</p><p>offsetLeft：从边框border（不包含）距离父元素的宽度距离</p><p>offsetHeight：内容+padding+border</p><p>offset Width：内容+padding+border</p></li><li><p>scrollleft/top 读取或设置元素滚动条到元素左边的距离。</p><p> scrollwidth/height 总的宽/高（显示+隐藏的）</p></li></ul><h4 id="获取浏览器宽高"><a href="#获取浏览器宽高" class="headerlink" title="获取浏览器宽高"></a>获取浏览器宽高</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.outerWidth/Height返回一个窗口的外部高度，包括所有界面元素（如工具栏）</span><br><span class="line"><span class="built_in">window</span>.innerWidth/Height获取浏览器显示区域（可视区域）的高度</span><br><span class="line">JQ</span><br><span class="line">获取浏览器显示区域（可视区域）的高度 ：   </span><br><span class="line">$(<span class="built_in">window</span>).height()=<span class="built_in">window</span>.innerHeight;   </span><br><span class="line">获取浏览器显示区域（可视区域）的宽度 ：</span><br><span class="line">$(<span class="built_in">window</span>).width()=<span class="built_in">window</span>.innerWidth</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JQ</span><br><span class="line">获取页面的文档高度(包括滚动出去的宽高)   </span><br><span class="line">$(<span class="built_in">document</span>).height();   </span><br><span class="line">获取页面的文档宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).width(); </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取滚动条到顶部的垂直高度 (即网页被卷上去的高度)  </span><br><span class="line">$(<span class="built_in">document</span>).scrollTop();   </span><br><span class="line">获取滚动条到左边的垂直宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).scrollLeft(); </span><br></pre></td></tr></table></figure><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><ul><li><p>js获取css属性值</p><ul><li>jquery方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//jquery方法</span><br><span class="line">const jq_width = $(&#x27;.box&#x27;).css(&#x27;width&#x27;);</span><br><span class="line">const jq_lineHeight = $(&#x27;.box&#x27;).css(&#x27;line-height&#x27;);</span><br><span class="line">console.log(jq_width,jq_lineHeight);//200px 150px</span><br></pre></td></tr></table></figure><ul><li>然后我们再用js原生方法去获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生style.css方法</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> js_width = box.style.width;</span><br><span class="line"><span class="keyword">const</span> js_lineHeight = box.style.lineHeight;</span><br><span class="line"><span class="built_in">console</span>.log(js_width,js_lineHeight);<span class="comment">//   50px</span></span><br><span class="line"><span class="comment">//在这里我们会发现style.css方法只能获取到写在标签上的属性 style = &quot;line-height:150px&quot; 不能获取写在&lt;style&gt;``&lt;/style&gt;中的css属性</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>window.getComputedStyle</code>这个方法获取所有经过浏览器计算过的样式</li></ul></li><li><p>elementNode.getAttribute(name)：方法通过名称获取属性的值。</p><p>elementNode.setAttribute(name, value)：方法创建或改变某个新属性。</p><p>elementNode.removeAttribute(name)：方法通过名称删除属性的值。</p></li></ul><h3 id="节点元素获取"><a href="#节点元素获取" class="headerlink" title="节点元素获取"></a>节点元素获取</h3><p>getElementsBy方法都是伪数组arguments</p><p>判断当前的子节点是否是元素节点    if (node.nodeType === 1)</p><p>parentNode    父元素        childNodes  所有子节点    children    所有的子元素</p><p>lastChild    获取最后一个子节点    lastElementChild     获取最后一个子元素</p><p>nextSibling  下一个兄弟节点        nextElementSibling    下一个兄弟元素</p><p>previousSibling   上一个兄弟节点     previousElementSibling    上一个兄弟元素</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>不会改变原来的字符串</strong></p><h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h4><p>charAt(index)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取指定位置处字符 myString.charAt(1)</span><br></pre></td></tr></table></figure><p>charCodeAt()      //获取指定位置处字符的ASCII码</p><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>indexOf(‘’,[index] )       //返回指定内容在元字符串中的位置，只找第一个匹配的,若没有则返回-1是，indexOf(‘a’,2);从位置2开始找到a的位置<br>lastIndexOf()     //从后往前找，只找第一个匹配的</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>拼接字符串，等效于+，+更常用</p><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>提取字符串的一部分，并返回新的字符串</p><p>str.slice(start, end) </p><p>end 参数可选，start可取正值，也可取负值。</p><p>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）<br>取负值时表示从索引为 length+start 位置截取到end所在位置的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar str = &quot;It is our choices that show what we truly are, far more than our abilities.&quot;;</span><br><span class="line">console.log(str.slice(0,-30)); // It is our choices that show what we truly are</span><br><span class="line">console.log(str.slice(-30)); // , far more than our abilities.</span><br></pre></td></tr></table></figure><h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><p>str.slice(start, end)<br>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）<br>取负值时表示从索引为 length+start 位置截取到end所在位置的字符</p><h4 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h4><p>返回字符串指定位置开始的指定数量的字符。</p><p>substr(fromIndex,length)           </p><p>start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。</p><p>length 表示截取的字符长度。</p><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>trim()去除空白<br>只能去除字符串前后的空白，字符之间的空格不能去掉</p><h4 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a><strong>toLocaleUpperCase</strong></h4><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射toLocaleUpperCase() 方法则是转换成大写的值。</p><p>语法：<em>str.toLocaleLowerCase()</em>, <em>str.toLocaleUpperCase()</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;ABCDEFG&#x27;.toLocaleLowerCase()); // abcdefg</span><br><span class="line">console.log(&#x27;abcdefg&#x27;.toLocaleUpperCase()); // ABCDEFG</span><br></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>split()字符转换为数组 split()还可以结合正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;a,b,c,d&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//以逗号为分割成数组</span></span><br><span class="line">arr.join(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="includes-ES6"><a href="#includes-ES6" class="headerlink" title="includes(ES6)"></a>includes(ES6)</h4><p>includes() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。</p><p>语法：<em>str.includes(subString [, position])</em></p><p>subString 表示要搜索的字符串，position 表示从当前字符串的哪个位置开始搜索字符串，默认值为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Practice makes perfect.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&quot;perfect&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&quot;perfect&quot;</span>,<span class="number">100</span>)); </span><br></pre></td></tr></table></figure><h4 id="endsWith-ES6"><a href="#endsWith-ES6" class="headerlink" title="endsWith(ES6)"></a>endsWith(ES6)</h4><p>endsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。</p><p>语法：<em>str.endsWith(substring [, position])</em></p><p>与contains 方法不同，position 参数的默认值为字符串长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Learn and live.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;live.&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;Learn&quot;</span>,<span class="number">5</span>)); </span><br></pre></td></tr></table></figure><p>startsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false。</p><p>语法：<em>str.startsWith(subString [, position])</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Where there is a will, there is a way.&quot;;</span><br><span class="line">console.log(str.startsWith(&quot;Where&quot;)); // true</span><br><span class="line">console.log(str.startsWith(&quot;there&quot;,6)); </span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="会改变原来数组的有："><a href="#会改变原来数组的有：" class="headerlink" title="会改变原来数组的有："></a>会改变原来数组的有：</h4><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>删除数组的最后一个元素并返回删除的元素。</p><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><p>向数组的末尾添加一个或更多元素，并返回新的长度。</p><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><p>删除并返回数组的第一个元素。</p><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><p>向数组的开头添加一个或更多元素，并返回新的长度。reverse()—反转数组的元素顺序。</p><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>翻转数组</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p><em>arr.sort([comparefn])</em></p><ul><li><p>comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序</p></li><li><p>如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：</p><ul><li>若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面；</li><li>若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；</li><li>若 comparefn(a, b) &gt; 0，那么a , b 将调换位置；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使是数组sort也是根据字符，从小到大排序</span></span><br><span class="line"><span class="comment">//采用冒泡排序</span></span><br><span class="line">sort(<span class="function"><span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="comment">// 倒序</span></span><br><span class="line"><span class="keyword">return</span> b - a;</span><br><span class="line">&#125;)</span><br><span class="line">fn（a,b）&#123;<span class="keyword">return</span> <span class="xml">&lt;0||&gt;0&#125;,返回小于0升序，大于0降序。</span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = [2,3,1,0].sort(function(a,b)&#123;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">    return a-b</span><br><span class="line">&#125;)</span><br><span class="line">:3 2</span><br><span class="line">:1 3 </span><br><span class="line">:1 2 </span><br><span class="line">:0 2</span><br><span class="line">:0 1</span><br></pre></td></tr></table></figure><p><strong>sort()方法的比较逻辑为：</strong><br>前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序</p><h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><p>用于插入、删除或替换数组的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start,deleteCount[, item1[, item2[, …]]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line"><span class="comment">// splice(position, numberOfItemsToRemove, item)</span></span><br><span class="line"><span class="comment">// 拼接函数(索引位置, 要删除元素的数量, 元素)</span></span><br><span class="line">array.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;three&quot;</span>); <span class="comment">// </span></span><br><span class="line">array; <span class="comment">//[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;boy&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> splices = array.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&quot;apple&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices); <span class="comment">// [&quot;boy&quot;] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span></span><br></pre></td></tr></table></figure><p>数组指定位置插入元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.insert = function (index, item) &#123;</span><br><span class="line">this.splice(index, 0, item);</span><br><span class="line">&#125;;</span><br><span class="line">var nums = [&quot;one&quot;, &quot;two&quot;, &quot;four&quot;];</span><br><span class="line">nums.insert(2, &#x27;three&#x27;); // 注意数组索引, [0,1,2..]</span><br><span class="line">array // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span><br></pre></td></tr></table></figure><h4 id="不会改变原来数组的有："><a href="#不会改变原来数组的有：" class="headerlink" title="不会改变原来数组的有："></a>不会改变原来数组的有：</h4><h5 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h5><p>将传入的数组或者元素与原数组合并，组成一个新的数组并返回。</p><p>语法：<em><strong>arr.concat(value1, value2, …, valueN)</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3];</span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(array); // [1, 2, 3], 可见原数组并未被修改</span><br></pre></td></tr></table></figure><p>若concat方法中不传入参数，那么将基于原数组<strong>浅复制</strong>生成一个一模一样的新数组（指向新的地址空间）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> array3 = array.concat();</span><br><span class="line"><span class="built_in">console</span>.log(array3); <span class="comment">// [&#123;a: 1&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(array3 === array); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>] === array3[<span class="number">0</span>]); <span class="comment">// true，新旧数组第一个元素依旧共用一个同一个对象的引用</span></span><br></pre></td></tr></table></figure><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p>将数组中的所有元素连接成一个字符串。</p><p>语法：<em>arr.join([separator = ‘,’])</em> separator可选，缺省默认为逗号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#x27;We&#x27;, &#x27;are&#x27;, &#x27;Chinese&#x27;];</span><br><span class="line">console.log(array.join()); // &quot;We,are,Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;+&#x27;)); // &quot;We+are+Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;&#x27;)); // &quot;WeareChinese&quot;</span><br></pre></td></tr></table></figure><h5 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h5><p>将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。</p><p>语法：<em>arr.slice([start[, end]])</em></p><p>参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。</p><p>如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。</p><p>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><strong>浅复制</strong> 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;color:&quot;yellow&quot;&#125;, 2, 3];</span><br><span class="line">var array2 = array.slice(0,1);</span><br><span class="line">console.log(array2); // [&#123;color:&quot;yellow&quot;&#125;]</span><br><span class="line">array[0][&quot;color&quot;] = &quot;blue&quot;;</span><br><span class="line">console.log(array2); // [&#123;color:&quot;bule&quot;&#125;]</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。</p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h5><h5 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf"></a>indexOf</h5><p>indexOf(arr[i],[index] )       //从位置index查找arr[i]在数组中的位置，只找第一个匹配的,若没有则返回-1</p><h5 id="lastindexOf"><a href="#lastindexOf" class="headerlink" title="lastindexOf"></a>lastindexOf</h5><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p><strong>迭代方法 不会修改原数组</strong></p><p>every()、filter()、forEach()、map()、some()</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>指定数组的每项元素都执行一次传入的函数，返回值为undefined。</p><p>语法：<strong>arr.forEach(fn, thisArg)</strong></p><p>fn 表示在数组每一项上执行的函数，接受三个参数：</p><ul><li>value 当前正在被处理的元素的值</li><li>index 当前元素的数组索引</li><li>array 数组本身</li></ul><p>thisArg 可选，用来当做fn函数内的this对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;cc&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sReturn = array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  array[index] = value * value;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// cc被打印了三次</span></span><br><span class="line">&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1, 9, 25], 可见原数组改变了</span></span><br><span class="line"><span class="built_in">console</span>.log(sReturn); <span class="comment">// undefined, 可见返回值为undefined</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>使用传入函数处理每个元素，并返回函数的返回值组成的新数组。</p><p>语法：<strong>arr.map(fn, thisArg)</strong></p><p>参数介绍同 forEach 方法的参数介绍。</p><h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>数组的每一项执行的函数都满足条件就返回true</p><h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素</p><p>语法：<strong>arr.filter(fn, thisArg)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array2); // [35, 80]</span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。</p><p>语法：<strong>arr.reduce(fn, initialValue)</strong></p><p>fn 表示在数组每一项上执行的函数，接受四个参数：</p><ul><li>previousValue 上一次调用回调返回的值，或者是提供的初始值</li><li>value 数组中当前被处理元素的值</li><li>index 当前元素在数组中的索引</li><li>array 数组自身</li></ul><p>initialValue 指定第一次调用 fn 的第一个参数。</p><h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><p>方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</p><p>语法：<strong>arr.entries()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">var iterator = array.entries();</span><br><span class="line">console.log(iterator.next()); //&#123; value: [ 0, &#x27;a&#x27; ], done: false &#125; </span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><p>keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）</p><p>语法：<strong>arr.keys()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;xyz&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.keys();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure><h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。</p><p>语法：<strong>arr.values()</strong></p><p>遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;xyz&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.values();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p> <strong>for…in循环</strong></p><p>精准的迭代，可以迭代对象的元素。也可以迭代数组。</p><p>【注意】使用<code>for ... in</code>，迭代的是元素（keys），对于数组来说，则为下标（0,1,2…,length-1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var key in arr) &#123;</span><br><span class="line">    //执行相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>for…of循环（ES6支持）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let item of arr) &#123;</span><br><span class="line">    //执行相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>for...in</code>不同的是，<code>for...of</code>迭代出来的是值（value），对于数组来说，则是一个元素值。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><strong>for…in遍历</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">author</span>: <span class="string">&quot;ztyzz&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&quot;2018.2.30&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> el <span class="keyword">in</span> book) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(book[el]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for … of遍历</strong></p><p>此方法，<strong>不能遍历普通对象</strong>(因为能够被for…of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口，使得它无法被for…of遍历。)，需要和<code>Object.keys()</code>搭配使用，先获取对象的所有key的数组 然后遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    name: &quot;hello&quot;,</span><br><span class="line">    id: &quot;2&quot;,</span><br><span class="line">    author: &quot;ztyzz&quot;,</span><br><span class="line">    time: &quot;2018.2.30&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">for(var key of Object.keys(book)) &#123;</span><br><span class="line">    console.log(book[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】<code>Object.values()</code>返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。</p><p>同时，由于<code>Object.keys()</code>返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。</p><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI<span class="comment">// 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.random()<span class="comment">// 生成随机数</span></span><br><span class="line"><span class="built_in">Math</span>.floor()/<span class="built_in">Math</span>.ceil() <span class="comment">// 向下取整/向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round()<span class="comment">// 取整，四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.abs()<span class="comment">// 绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max()/<span class="built_in">Math</span>.min() <span class="comment">// 求最大和最小值                                                                                                           </span></span><br><span class="line"><span class="built_in">Math</span>.sin()<span class="built_in">Math</span>.cos() <span class="comment">// 正弦/余弦</span></span><br><span class="line"><span class="built_in">Math</span>.power()/<span class="built_in">Math</span>.sqrt() <span class="comment">// 求指数次幂/求平方根</span></span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><h4 id="new-Date-创建新的日期对象"><a href="#new-Date-创建新的日期对象" class="headerlink" title="**new Date()**创建新的日期对象"></a>**new Date()**创建新的日期对象</h4><ol><li><p>用整数初始化日期对象</p><p>new Date(yyyy,mth,dd,hh,mm,ss);<br>new Date(yyyy,mth,dd); </p><p>注意：</p><ul><li>您不能省略月份。如果只提供一个参数，则将其视为毫秒。</li><li>一位和两位数年份将被解释为 19xx 年：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yyyy:四位数表示的年份</span><br><span class="line">mth:用整数表示月份，从（１月）0到１１（１２月）</span><br><span class="line">dd:表示一个 月中的第几天，从1到31</span><br><span class="line">hh:小时数，从0（午夜）到23（晚11点）</span><br><span class="line">mm: 分钟数，从0到59的整数</span><br><span class="line">ss:秒数，从0到59的整数</span><br></pre></td></tr></table></figure></li><li><p>用字符串初始化日期对象</p><p>new Date(“2017/06/06”); </p><p>new Date(“2017-08-08”); </p><p>new Date(“month dd,yyyy hh:mm:ss”);  </p><p>new Date(“month dd,yyyy”);</p></li><li><p>用毫秒时间戳初始化日期对象</p><p>new Date(ms);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。</span><br><span class="line">零时间是 1970 年 1 月 1 日 00:00:00 UTC。</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取日期方法"><a href="#获取日期方法" class="headerlink" title="获取日期方法"></a>获取日期方法</h4><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDate()</td><td align="left">以数值返回天（1-31）</td></tr><tr><td align="left">getDay()</td><td align="left">以数值获取周名（0-6）</td></tr><tr><td align="left">getFullYear()</td><td align="left">获取四位的年（yyyy）</td></tr><tr><td align="left">getHours()</td><td align="left">获取小时（0-23）</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">获取毫秒（0-999）</td></tr><tr><td align="left">getMinutes()</td><td align="left">获取分（0-59）</td></tr><tr><td align="left">getMonth()</td><td align="left">获取月（0-11）</td></tr><tr><td align="left">getSeconds()</td><td align="left">获取秒（0-59）</td></tr><tr><td align="left">getTime()</td><td align="left">获取时间（从 1970 年 1 月 1 日至今）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date.getFullYear()//获取完整的年份(4位,1970-????)</span><br><span class="line">date.getMonth() //获取当前月份(0-11,0代表1月)</span><br><span class="line">date.getDate()//获取几号   - 0 - 31 比如25</span><br><span class="line">date.getDay()//获取星期几 - 比如星期3的3</span><br><span class="line">date.getHours()//获取小时</span><br><span class="line">date.getTime()// 获取相对于1970-01-01的毫秒值</span><br></pre></td></tr></table></figure><h4 id="日期设置方法"><a href="#日期设置方法" class="headerlink" title="日期设置方法"></a>日期设置方法</h4><p>设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">setDate()</td><td align="left">以数值（1-31）设置日</td></tr><tr><td align="left">setFullYear()</td><td align="left">设置年（可选月和日）</td></tr><tr><td align="left">setHours()</td><td align="left">设置小时（0-23）</td></tr><tr><td align="left">setMilliseconds()</td><td align="left">设置毫秒（0-999）</td></tr><tr><td align="left">setMinutes()</td><td align="left">设置分（0-59）</td></tr><tr><td align="left">setMonth()</td><td align="left">设置月（0-11）</td></tr><tr><td align="left">setSeconds()</td><td align="left">设置秒（0-59）</td></tr><tr><td align="left">setTime()</td><td align="left">设置时间（从 1970 年 1 月 1 日至今的毫秒数）</td></tr></tbody></table><h4 id="时间戳转化为日期的方式"><a href="#时间戳转化为日期的方式" class="headerlink" title="时间戳转化为日期的方式"></a><strong>时间戳转化为日期的方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Mon May 28 2018</span><br><span class="line">console.log(newDate.toDateString());</span><br><span class="line"> </span><br><span class="line">// Mon, 28 May 2018 15:24:12 GMT</span><br><span class="line">console.log(newDate.toGMTString());</span><br><span class="line"> </span><br><span class="line">// 2018-05-28T15:24:12.000Z</span><br><span class="line">console.log(newDate.toISOString());</span><br><span class="line"> </span><br><span class="line">// 2018-05-28T15:24:12.000Z</span><br><span class="line">console.log(newDate.toJSON());</span><br><span class="line"></span><br><span class="line">// 2018/5/28</span><br><span class="line">console.log(newDate.toLocaleDateString());</span><br><span class="line"> </span><br><span class="line">// 2018/5/28 下午11:24:12</span><br><span class="line">console.log(newDate.toLocaleString());</span><br><span class="line"> </span><br><span class="line">// 下午11:24:12</span><br><span class="line">console.log(newDate.toLocaleTimeString());</span><br><span class="line"> </span><br><span class="line">// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(newDate.toString());</span><br><span class="line"> </span><br><span class="line">// 23:24:12 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(newDate.toTimeString());</span><br><span class="line"> </span><br><span class="line">// Mon, 28 May 2018 15:24:12 GMT</span><br><span class="line">console.log(newDate.toUTCString());</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><strong>（1）对象是单个实物的抽象。</strong></p><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;    </span><br><span class="line">      <span class="built_in">this</span>.name = name  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;咚咚&#x27;</span>)  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p1:&quot;</span>,p1);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p1.__proto__ === Person.prototype:&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Person.prototype:&quot;</span>,Person.prototype);</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170dd61fa1c7f710?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>new 命令的原理</strong></p><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>开始执行构造函数内部的代码。</li></ol><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" /><p>所有对象都有自己的原型对象（prototype）。原型对象的所有属性和方法，都能被实例对象共享。</p><p>一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p><img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" /><p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em>proto</em></h4><p>当一个实例对象被创建时，这个构造函数 将会把它的属性prototype赋给实例对象的内部属性__proto__。<strong>proto是指向构造函数原型对象的指针。</strong></p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>判断是否是数组 /判断某个对象是否是某个构造函数的实例 </p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p><a href="https://blog.csdn.net/qq_42926373/article/details/83149347">https://blog.csdn.net/qq_42926373/article/details/83149347</a></p><h4 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h4><p>不能继承父级的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数继承属性成员 </span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.type, s1.name, s1.age) <span class="comment">// =&gt; human 张三 18</span></span><br></pre></td></tr></table></figure><h4 id="原型方法继承"><a href="#原型方法继承" class="headerlink" title="原型方法继承"></a>原型方法继承</h4><p>不能继承父级的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype)</span><br><span class="line">Teacher.prototype.constructor = Teacher</span><br></pre></td></tr></table></figure><p><strong>一旦我们修改构造函数的原型对象，为了防止引用出现问题，同时也要修改原型对象的constructor属性。</strong></p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用原型的特性实现继承</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// 若不指明原型对象，会指向person</span></span><br><span class="line"><span class="comment">//console.log(Student.prototype.constructor);</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.type) <span class="comment">// =&gt; human</span></span><br><span class="line"></span><br><span class="line">s1.sayName() <span class="comment">// =&gt; hello 张三</span></span><br></pre></td></tr></table></figure><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><h3 id="指向对象"><a href="#指向对象" class="headerlink" title="指向对象"></a>指向对象</h3><p><a href="https://www.cnblogs.com/dongcanliang/p/7054176.html">https://www.cnblogs.com/dongcanliang/p/7054176.html</a></p><ul><li><p>在全局作用域下 this对象指向的是window对象</p></li><li><p>在函数作用域下 </p><ul><li>在非严格模式下: this的指向依旧是window对象</li><li>在严格模式下:this的指向是undefined</li></ul></li><li><p>超时调用（<code>setTimeout</code>回调）的代码都是在全局作用域环境中执行的</p></li><li><p>构造函数调用， 此时 this指向实例对象</p></li><li><p>在对象里面this的指向是当前该对象</p><p><strong>特殊情况</strong></p><ul><li>```js<br>var obj = {<pre><code>name()&#123;    console.log(this) //obj   function fn()&#123;       console.log(this) //window   &#125;   fn()&#125;</code></pre>}<br>obj.name()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  如何让函数里的那个函数fn也能使用当前obj这个对象了</span><br><span class="line"></span><br><span class="line">  1. 将this赋值给that</span><br><span class="line">  2. 使用箭头函数</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  var o = &#123;</span><br><span class="line">    prop: 37,</span><br><span class="line">    f: function() &#123;</span><br><span class="line">      return this.prop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  console.log(o.f());  //37</span><br><span class="line">  var a = o.f;</span><br><span class="line">  console.log(a()):  //undefined</span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数不绑定this。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this，<strong>所以不会在调用时指向其执行环境的（变量）对象</strong></p><ul><li><strong>注意：因为箭头函数内部的<code>this</code>是指向外层代码块的<code>this</code>的，所以我们可以通过改变外层代码块的<code>this</code>的指向从而改变箭头函数中<code>this</code>的指向</strong></li></ul></li></ul><h3 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> 作用</span><br><span class="line">他们的作用都是改变函数内部的<span class="built_in">this</span>。</span><br><span class="line">这三个函数都是<span class="built_in">Function</span>原型中的方法（所有的函数都是<span class="built_in">Function</span>的实例），也就是说只有函数才可以直接调用这些方法。</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> 三者区别</span><br><span class="line">参数： 三个函数的第一个参数都是需要绑定的 <span class="built_in">this</span>。</span><br><span class="line">call/apply 修改完<span class="built_in">this</span>指向后，会立即调用前面的函数，但是 bind 只是修改<span class="built_in">this</span>指向，并不会调用</span><br><span class="line">call/bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。</span><br><span class="line">apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。 </span><br><span class="line">    call 语法：  foo.call(<span class="built_in">this</span>, arg1,arg2, ... ,argn );</span><br><span class="line">    apply 语法： foo.apply(<span class="built_in">this</span>, [ arg1,arg2, ... ,argn ] );</span><br><span class="line">    bind 语法：  foo.bind(<span class="built_in">this</span>, arg1,arg2, ... ,argn);</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span>调用：</span><br><span class="line">call,apply： 调用后立即执行原函数。</span><br><span class="line">bind： 调用后返回已经绑定好<span class="built_in">this</span>的函数。</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span>场景</span><br><span class="line">处理伪数组 (最常用)</span><br><span class="line">继承</span><br><span class="line">取数组最大最小值</span><br><span class="line">合并数组</span><br></pre></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><blockquote><p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p></blockquote><ul><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li><li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li><li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li><li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li><li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li></ul><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addEventListener(&#x27;click&#x27;, fn, false);//false(默认)是事件冒泡，true是事件捕获</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。</span><br></pre></td></tr></table></figure><h3 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h3><ul><li><code>target</code>是事件触发的真实元素</li><li><code>currentTarget</code>是事件绑定的元素</li><li>事件处理函数中的<code>this</code>指向是中为<code>currentTarget</code>。</li><li><code>currentTarget</code>和<code>target</code>，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）<ul><li>当事件是子元素触发时，<code>currentTarget</code>为绑定事件的元素，<code>target</code>为子元素<ul><li>若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素           </li></ul></li><li>当事件是元素自身触发时，<code>currentTarget</code>和<code>target</code>为同一个元素。</li></ul></li></ul><p>e.type点击对象的事件类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">  &#125;); </span><br></pre></td></tr></table></figure><h2 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h2><p><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p><ul><li>新增选择器 <code>document.querySelector</code>、<code>document.querySelectorAll</code></li><li>拖拽释放(<code>Drag and drop</code>) API</li><li>媒体播放的 <code>video</code> 和 <code>audio</code></li><li>本地存储 <code>localStorage</code> 和 <code>sessionStorage</code></li><li>离线应用 <code>manifest</code></li><li>桌面通知 <code>Notifications</code></li><li>语意化标签 <code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li><li>增强表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li><li>地理位置 <code>Geolocation</code></li><li>多任务 <code>webworker</code></li><li>全双工通信协议 <code>websocket</code></li><li>历史管理 <code>history</code></li><li>跨域资源共享(CORS) <code>Access-Control-Allow-Origin</code></li><li>页面可见性改变事件 <code>visibilitychange</code></li><li>跨窗口通信 <code>PostMessage</code></li><li><code>Form Data</code> 对象</li><li>绘画 <code>canvas</code></li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><h4 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h4><h5 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h5><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 变量名错误</span><br><span class="line">var 1a;</span><br><span class="line">// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line"></span><br><span class="line">// 缺少括号</span><br><span class="line">console.log &#x27;hello&#x27;);</span><br><span class="line">// Uncaught SyntaxError: Unexpected string</span><br></pre></td></tr></table></figure><h5 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h5><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p><h5 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h5><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。</p><h5 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h5><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new 123</span><br><span class="line">// Uncaught TypeError: number is not a func</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></pre></td></tr></table></figure><p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p><h5 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h5><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.message <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.message <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure><h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p><p><code>throw</code>也可以抛出自定义错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function UserError(message) &#123;</span><br><span class="line">  this.message = message || &#x27;默认信息&#x27;;</span><br><span class="line">  this.name = &#x27;UserError&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw new UserError(&#x27;出错了！&#x27;);</span><br><span class="line">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p><p><code>throw</code><strong>可以抛出任何类型的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 抛出一个字符串</span><br><span class="line">throw &#x27;Error！&#x27;;</span><br><span class="line">// Uncaught Error！</span><br><span class="line"></span><br><span class="line">// 抛出一个数值</span><br><span class="line">throw 42;</span><br><span class="line">// Uncaught 42</span><br><span class="line"></span><br><span class="line">// 抛出一个布尔值</span><br><span class="line">throw true;</span><br><span class="line">// Uncaught true</span><br></pre></td></tr></table></figure><h4 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h4><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。</p><h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h4><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h4><ul><li>onload</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当页面加载完成执行</span></span><br><span class="line">  <span class="comment">// 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onunload</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当用户退出页面时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><h4 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h4><ul><li><p>Clipboard.JS：Selection 与 execCommand API</p><p>运行<code>ClipboardJS.isSupported()</code>来检查是否支持<code>clipboard.js</code></p><p>点击按钮两次才执行</p><p><a href="https://juejin.cn/post/6906635620752293902#heading-0">https://juejin.cn/post/6906635620752293902#heading-0</a></p></li><li><p>图像写入剪切板</p><p><a href="https://juejin.cn/post/6909237803050074126#heading-0">https://juejin.cn/post/6909237803050074126#heading-0</a></p></li><li><p>base64,file和Blob的转换</p><p><a href="https://juejin.cn/post/6844903862873112583">https://juejin.cn/post/6844903862873112583</a></p></li><li><p>阮一峰：剪贴板操作 Clipboard API 教程</p><p><a href="http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html">http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html</a></p></li></ul><h5 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大家好，我是阿宝哥&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">data-clipboard-action</span>=<span class="string">&quot;copy&quot;</span> <span class="attr">data-clipboard-target</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;success&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 <code>input</code> 元素之外，复制的目标还可以是 <code>div</code> 或 <code>textarea</code> 元素。在以上示例中，我们复制的目标是通过 <strong><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_data_attributes">data-* 属性</a></strong> 来指定。此外，我们也可以在实例化 clipboard 对象时，设置复制的目标：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-target.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果需要设置复制的文本，我们也可以在实例化 clipboard 对象时，设置复制的文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-text.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;大家好，我是阿宝哥&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="图像-1"><a href="#图像-1" class="headerlink" title="图像"></a>图像</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将base64转换为blob对象</span></span><br><span class="line"><span class="comment">//https://juejin.cn/post/6844903862873112583</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转换成file对象</span></span><br><span class="line">  <span class="comment">//return new File([u8arr], filename, &#123; type: mime &#125;);</span></span><br><span class="line">  <span class="comment">//转换成成blob对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imageBlob = dataURLtoFile(src);</span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> ClipboardItem(&#123;</span><br><span class="line">    [imageBlob.type]: imageBlob,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//检测浏览器是否支持clipboard-write</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">askWritePermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; state &#125; = <span class="keyword">await</span> navigator.permissions.query(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;clipboard-write&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> state === <span class="string">&quot;granted&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (askWritePermission()) &#123;</span><br><span class="line">    navigator.clipboard.write([item]);</span><br><span class="line">    alert(<span class="string">&quot;成功复制到剪切板&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;不支持复制&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Chrome 浏览器规定，navigator.clipboard只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</strong></p><h5 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></p><p><a href="https://zhuanlan.zhihu.com/p/97768916">https://zhuanlan.zhihu.com/p/97768916</a></p><p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410d77d17b~tplv-t2oaga2asx-watermark.awebp" alt="plain-type-blob"></p><p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），type 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410c51dbed~tplv-t2oaga2asx-watermark.awebp" alt="blob-structure"></p><p>Blob 构造函数的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var aBlob = new Blob(blobParts, options);</span><br></pre></td></tr></table></figure><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p><p>options：一个可选的对象，包含以下两个属性：</p><ul><li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li><li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。 它是以下两个值中的一个： <code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li></ul><h5 id="file对象"><a href="#file对象" class="headerlink" title="file对象"></a>file对象</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://developer.mozilla.org/zh-CN/docs/Web/API/File</a></p><p>File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象</p><p><strong>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中</strong></p><h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><p><strong>在web应用程序中使用文件</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images">https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images</a></p><h4 id="表单FormData对象"><a href="#表单FormData对象" class="headerlink" title="表单FormData对象"></a>表单FormData对象</h4><p>每一个控件都会生成一个键值对，所有的键值对都会提交到服务器。提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p><p>点击<code>submit</code>控件，就可以提交表单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.submit();</span><br></pre></td></tr></table></figure><p><strong>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程</strong></p><p>FormData 首先是一个构造函数，用来生成实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var formdata = new FormData(form);</span><br><span class="line"></span><br><span class="line">// 获取某个控件的值</span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 设置某个控件的值</span><br><span class="line">formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;张三&quot;</span><br></pre></td></tr></table></figure><h4 id="FormData-实例方法"><a href="#FormData-实例方法" class="headerlink" title="FormData 实例方法"></a>FormData 实例方法</h4><ul><li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li><li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li><li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li><li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li><li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li><li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li><li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li><li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li><li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li></ul><h4 id="自动校验"><a href="#自动校验" class="headerlink" title="自动校验"></a>自动校验</h4><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 必填 --&gt;</span><br><span class="line">&lt;input required&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须符合正则表达式 --&gt;</span><br><span class="line">&lt;input pattern=&quot;banana|cherry&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 字符串长度必须为6个字符 --&gt;</span><br><span class="line">&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数值必须在1到10之间 --&gt;</span><br><span class="line">&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 Email 地址 --&gt;</span><br><span class="line">&lt;input type=&quot;email&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 URL --&gt;</span><br><span class="line">&lt;input type=&quot;URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p><h3 id="WEB存储"><a href="#WEB存储" class="headerlink" title="WEB存储"></a>WEB存储</h3><p>本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.</p><ul><li><p>localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 存储 localStorage.sitename = &quot;菜鸟教程&quot;; </span><br><span class="line">// 查找 document.getElementById(&quot;result&quot;).innerHTML =localStorage.sitename;</span><br><span class="line">//移除 localStorage 中的 &quot;sitename&quot; :</span><br><span class="line">localStorage.removeItem(&quot;sitename&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</span><br><span class="line"></span><br><span class="line">- 保存数据：localStorage.setItem(key,value);</span><br><span class="line">- 读取数据：localStorage.getItem(key);</span><br><span class="line">- 删除单个数据：localStorage.removeItem(key);</span><br><span class="line">- 删除所有数据：localStorage.clear();</span><br><span class="line">- 得到某个索引的key：localStorage.key(index);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p></li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>设置属性（setAttribute）,属性名为’data-‘开头的，可以使用dataset来获取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(&#x27;data-age&#x27;, value);      dataset[&#x27;age&#x27;]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性length,返回类的数量</span><br><span class="line">classList.item(index)返回元素中索引值对应的类名。索引值从 <span class="number">0</span> 开始。</span><br><span class="line">classList.remove/add/toggle(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">classList.contains(<span class="string">&#x27;active&#x27;</span>)判断当前ClassList中有没有active</span><br><span class="line">classList.toggle(<span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;&#x27;</span>);toggle函数的第二个参数<span class="literal">true</span>为添加 <span class="literal">false</span>删除</span><br></pre></td></tr></table></figure><h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li><p>$([selector,[context]])</p><p>$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个  context 中查找。</p><h5 id="jQuery-代码"><a href="#jQuery-代码" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;input:radio&quot;</span>, <span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。</span></span><br></pre></td></tr></table></figure></li><li><p>```js<br>//DOM文档载入完成后执行的函数<br>$(function(){<br>  // 文档就绪<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ## this</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">当你用的是jquery时，就用$(this)，如果是JS，就用this</span><br><span class="line">jquery对象$(this)[0]等同于JS里的元素this</span><br><span class="line">console.log($(this)[0]==this) //true</span><br><span class="line"></span><br><span class="line">JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了</span><br><span class="line">$(this).get(0)与$(this)[0]等价。</span><br><span class="line">console.log($(this)[0]==$(this).get(0)) //true</span><br></pre></td></tr></table></figure></li><li><p>each(callback),每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;img&quot;).each(function(i)&#123;</span><br><span class="line">   this.src = &quot;test&quot; + i + &quot;.jpg&quot;;</span><br><span class="line"> &#125;);</span><br><span class="line">//this是js的this</span><br></pre></td></tr></table></figure><ul><li><p>size()/length当前匹配的元素个数</p></li><li><p>get(index)取得其中一个匹配的元素</p><h5 id="HTML-代码"><a href="#HTML-代码" class="headerlink" title="HTML 代码:"></a>HTML 代码:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;test1.jpg&quot;/&gt; &lt;img src=&quot;test2.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="jQuery-代码-1"><a href="#jQuery-代码-1" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;img&quot;).get(0);</span><br></pre></td></tr></table></figure></li><li><p>index(一个DOM选择器/ jQuery 选择器)</p><p>搜索匹配的元素，并返回相应元素的索引值，从0开始计数。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span>&gt;</span>baz<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">$(&#x27;li&#x27;).index(document.getElementById(&#x27;bar&#x27;)); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(&#x27;li&#x27;); //1，传递一个选择器，返回#bar在所有li中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(); //1，不传递参数，返回这个元素在同辈中的索引位置。</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p>attr(name|key,value)返回或设置被选元素的属性值。removeAttr</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(&#123; <span class="attr">src</span>: <span class="string">&quot;test.jpg&quot;</span>, <span class="attr">alt</span>: <span class="string">&quot;Test Image&quot;</span> &#125;);<span class="comment">//为所有图像设置src和alt属性。</span></span><br><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;test.jpg&quot;</span>);<span class="comment">//为所有图像设置src属性。</span></span><br></pre></td></tr></table></figure></li><li><p>removeAttr(name)从每一个匹配的元素中删除一个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).removeAttr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line"><span class="comment">//将文档中图像的src属性删除</span></span><br></pre></td></tr></table></figure></li><li><p>addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul li:last&#x27;</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index,<span class="keyword">class</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;item-&#x27;</span> + $(<span class="built_in">this</span>).index();</span><br><span class="line">&#125;);<span class="comment">//给li加上不同的class</span></span><br></pre></td></tr></table></figure></li><li><p>toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="built_in">this</span>).toggleClass(<span class="string">&quot;highlight&quot;</span>, count++ % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">&#125;);<span class="comment">//每点击三下加上一次 &#x27;highlight&#x27; 类</span></span><br></pre></td></tr></table></figure></li><li><p>html()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回p元素的内容。取得第一个匹配元素的html内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).html();</span><br><span class="line"><span class="comment">//设置所有 p 元素的内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).html(<span class="string">&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>text()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回p元素的文本内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).text();</span><br><span class="line"><span class="comment">//设置所有 p 元素的文本内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>val()</p></li></ul><h2 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h2><ul><li><p>css</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得第一个段落的color样式属性的值。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>);</span><br><span class="line"><span class="comment">//将所有段落的字体颜色设为红色并且背景为蓝色。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(&#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#ff0011&quot;</span>, <span class="string">&quot;background&quot;</span>: <span class="string">&quot;blue&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//将所有段落字体设为红色</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>height()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一段的高</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height();</span><br><span class="line"><span class="comment">//把所有段落的高设为 20:</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//以 10 像素的幅度增加 p 元素的高度</span></span><br><span class="line"> $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;p&quot;</span>).height(<span class="function"><span class="keyword">function</span>(<span class="params">n,c</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//n,c索引位置和元素旧的高度值</span></span><br><span class="line">    <span class="keyword">return</span> c+<span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><ul><li><p>prev + next匹配所有紧接在 prev 元素后的 next 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配所有跟在 label 后面的 input 元素</span></span><br><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line">    </span><br><span class="line">$(<span class="string">&quot;label + input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li><li><p>prev ~ siblings匹配 prev 元素之后的所有 siblings 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;form ~ input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li><p>:first获取第一个元素–&gt;last</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li:first&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>:not去除所有与给定选择器匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找所有未选中的 input 元素</span></span><br><span class="line">&lt;input name=<span class="string">&quot;apple&quot;</span> /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;flower&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;input:not(:checked)&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>:even()匹配所有索引值为偶数的元素，从 0 开始计数–&gt;:odd()</p></li><li><p>:eq()匹配一个给定索引值的元素,从 0 开始计数</p></li><li><p>:gt()匹配所有大于给定索引值的元素,从 0 开始计数–&gt;:It()</p></li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><h3 id="表单-1"><a href="#表单-1" class="headerlink" title="表单"></a>表单</h3><h2 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h2><h3 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h3><ul><li><p>append()向每个匹配的元素内部追加内容。</p></li><li><p>appendTo()把所有匹配的元素追加到另一个指定的元素元素集合中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;I would like to say: &lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).appendTo(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>prepend()向每个匹配的元素内部前置内容。–&gt;prependTo()</p></li></ul><h3 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h3><ul><li>after()在每个匹配的元素之后插入内容。–&gt;before</li><li>insertAfter–&gt;insertBefore</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>empty()删除匹配的元素集合中所有的子节点。</li><li>remove()从DOM中删除所有匹配的元素。</li></ul><h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</p><p>map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).append( $(&quot;input&quot;).map(function()&#123;</span><br><span class="line">  return $(this).val();</span><br><span class="line">&#125;).get().join(&quot;, &quot;) );get()jQuery转DOM对象</span><br><span class="line"></span><br><span class="line">$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。</span><br><span class="line">$.map( [0,1,2], function(n)&#123;</span><br><span class="line">  return n + 4;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式</p><p>find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$(“p span”)相同。</p><p>next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。</p><p>nextAll(expr),查找当前元素之后所有的同辈元素。</p><p>prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。</p><p>siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。</p><h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。</span><br><span class="line"></span><br><span class="line">**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。</span><br><span class="line">**data:**作为event.data属性值传递给事件对象的额外数据对象</span><br><span class="line">**fn:**每当事件触发时执行的函数。</span><br><span class="line"></span><br><span class="line">2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 </span><br><span class="line">3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。</span><br><span class="line">事件委托即事件冒泡</span><br><span class="line">// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp</span><br><span class="line">$(document.body).on(&quot;click&quot;, &quot;p&quot;, handler);</span><br><span class="line">e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡</span><br></pre></td></tr></table></figure><p>trigger(type,[data])在每一个匹配的元素上触发某类事件。</p><p>hover([over,]out)</p><p>over:鼠标移到元素上要触发的函数</p><p>out:鼠标移出元素要触发的函数</p><p>toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;td&quot;).toggle(</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).addClass(&quot;selected&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).removeClass(&quot;selected&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">);//对表格的切换一个类</span><br><span class="line">$(&#x27;td).toggle();//对表格切换显示/隐藏</span><br></pre></td></tr></table></figure><p>change([data],fn)当元素的值发生改变时，会发生 change 事件。</p><p>unload([[data],fn])在当用户离开页面时，会发生 unload 事件。</p><p>会发出 unload 事件：</p><ul><li>点击某个离开页面的链接  </li><li>在地址栏中键入了新的 URL  </li><li>使用前进或后退按钮  </li><li>关闭浏览器  </li><li>重新加载页面 </li></ul><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p><strong>js语言执行环境是单线程</strong></p><p>JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，<strong>单个脚本</strong>只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“<strong>事件循环</strong>”机制（Event Loop）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JS中的异步操作：</span><br><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">剩下的都是同步处理</span><br></pre></td></tr></table></figure><p><strong>同步任务和异步任务</strong></p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。</p><ul><li>宏任务：包括整体代码script，setTimeout，setInterval</li><li>微任务：Promise.then(非new Promise)，process.nextTick(node中)</li></ul><h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1.回调函数"></a>1.回调函数</h3><p>一个函数作为参数传递到另一个函数中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">callback()<span class="comment">//f1的任务</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure><p>优缺点:简单,容易部署,但不利于代码的阅读和维护,各部分之间高度耦合</p><p><strong>注意:回调并不一定是异步</strong></p><h3 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2.事件监听"></a>2.事件监听</h3><p>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p><p>监听函数:on,bind,listen,addEventListener</p><p>监听方法:onclick…</p><h3 id="3发布-订阅"><a href="#3发布-订阅" class="headerlink" title="3发布/订阅"></a>3发布/订阅</h3><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p><p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&#x27;done&#x27;, f2);</span><br></pre></td></tr></table></figure><p>然后，<code>f1</code>进行如下改写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">    jQuery.publish(&#x27;done&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p><p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(&#x27;done&#x27;, f2);</span><br></pre></td></tr></table></figure><h3 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h3><ul><li><p><strong>名称</strong><br> 译为“承诺”，这也就表达了将来会执行的操作，代表异步操作；</p></li><li><p><strong>状态</strong><br> 一共有三种状态，分别为<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</p></li><li><p><strong>特点</strong><br> (1)只有异步操作可以决定当前处于的状态，并且任何其他操作无法改变这个状态；<br> (2)一旦状态改变，就不会在变。状态改变的过程只可能是：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。如果状态发生上述变化后，此时状态就不会在改变了，这时就称为<code>resolved</code>（已定型）</p></li><li><p><strong>基本用法</strong></p><p>Promise 对象是由关键字 new 及其构造函数来创建的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something here ...</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        resolve(value); <span class="comment">// fulfilled</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error); <span class="comment">// rejected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该构造函数接收两个函数作为参数，分别是<code>resolve</code>和<code>reject</code>。<br> 当异步操作执行成功后，会将异步操作结果作为参数传入<code>resolve</code>函数并执行，此时 <code>Promise</code>对象状态从<code>pending</code>变为<code>fulfilled</code>；<br> 失败则会将异步操作的错误作为参数传入<code>reject</code>函数并执行，此时 <code>Promise</code>对象状态从<code>pending</code>变为<code>rejected</code>；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">a.then(<span class="function"><span class="keyword">function</span>(<span class="params">calue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(calue)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//42315</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">a.catch(<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">//返回新的promise，那么下一级.then()会在新的promise状态改变之后执行</span></span><br></pre></td></tr></table></figure><ul><li>返回新的promise，那么下一级.then()会在新的promise状态改变之后执行</li><li>没有return，相当于return Promise.resolve(undefined);</li><li>return非Promise的数据data，相当于return Promise.resolve(data);</li></ul><h3 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5.async/await"></a>5.async/await</h3><p>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</p><p>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</p><p>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p><p>声明</p><ul><li>函数：<code>async function Func() &#123;&#125;</code></li><li>函数表达式：<code>const func = async function() &#123;&#125;</code></li><li>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li><li>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li><li>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li></ul><p><strong>async函数的返回值总是一个Promise</strong></p><p>无论async函数有无await操作，其总是返回一个Promise。因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数。函数内部抛出的错误，会被then的第二个函数或catch方法捕获到</p><ol><li>没有显式return，相当于return Promise.resolve(undefined);</li><li>return非Promise的数据data，相当于return Promise.resolve(data);</li><li>return Promise, 会得到Promise对象本身</li></ol><p> <strong>await操作符的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rv] = await expression（expression可以是任何值，通常是一个promise）</span><br></pre></td></tr></table></figure><p>expression是Promise，rv等于Promise兑现的值，若Promise被拒绝，则抛出异常，由catch捕获<br>expression是非Promise，会立即被转换为resolve的Promise，rv等于expression</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">await</span> l();</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">await</span> h();</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">a().then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(a)<span class="comment">//[λ: a]</span></span><br><span class="line"><span class="comment">//1,[λ: a],3,5,6,2</span></span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><p>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></p><p>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</p><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p><ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul><p><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</p><p>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量分别接收Promise</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise();</span><br><span class="line"><span class="comment">//使用Promise.all</span></span><br><span class="line"><span class="keyword">let</span> [foo,bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(),getBar()]);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</p><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p><p>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</p><h1 id="底层API"><a href="#底层API" class="headerlink" title="底层API"></a>底层API</h1><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver">https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver</a></p><p>当父元素中的元素有删减，会调用该函数。</p><p>eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled</p><p>tip: 添加合理的判断条件，否则会执行死循环</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6和TS</title>
      <link href="/2020/09/25/es6/"/>
      <url>/2020/09/25/es6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文档来源</p><p><a href="http://caibaojian.com/es6/">http://caibaojian.com/es6/</a></p><h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a><strong>let和const</strong></h1><p><code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。同时JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率 </p><h2 id="1-不存在变量提升"><a href="#1-不存在变量提升" class="headerlink" title="1.不存在变量提升"></a><strong>1.不存在变量提升</strong></h2><p>暂时性死区: 区级作用域中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(x = y, y = 2)作为函数参数作用域，父作用域</span></span><br><span class="line"><span class="comment">//函数内部是一个单独的子作用域</span></span><br><span class="line">bar(); <span class="comment">// 报错。参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</span></span><br></pre></td></tr></table></figure><h2 id="2-暂时性死区"><a href="#2-暂时性死区" class="headerlink" title="2.暂时性死区"></a><strong>2.暂时性死区</strong></h2><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><h2 id="3-不允许重复声明"><a href="#3-不允许重复声明" class="headerlink" title="3.不允许重复声明"></a><strong>3.不允许重复声明</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错。let不允许在相同作用域内，重复声明同一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-为什么需要块级作用域？"><a href="#4-为什么需要块级作用域？" class="headerlink" title="4.为什么需要块级作用域？"></a><strong>4.为什么需要块级作用域？</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 内层变量可能会覆盖外层变量。 </span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内层的tmp变量覆盖了外层的tmp变量。</span></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>用来计数的循环变量泄露为全局变量。</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="5-块级作用域与函数"><a href="#5-块级作用域与函数" class="headerlink" title="5.块级作用域与函数"></a><strong>5.块级作用域与函数</strong></h2><p> <code>let</code>实际上为 JavaScript 新增了块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响,即<strong>块级作用域也属于作用域链中</strong>。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p><h2 id="在块级作用域中声明函数"><a href="#在块级作用域中声明函数" class="headerlink" title="在块级作用域中声明函数"></a><strong>在块级作用域中声明函数</strong></h2><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成<strong>函数表达式</strong>，而不是函数声明语句。</p><h2 id="6-const命令"><a href="#6-const命令" class="headerlink" title="6.const命令"></a><strong>6.const命令</strong></h2><p> <code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p> 只在声明所在的块级作用域内有效 </p><p> 对于<strong>复合类型</strong>的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变  </p><h2 id="7-顶层对象的属性"><a href="#7-顶层对象的属性" class="headerlink" title="7.顶层对象的属性"></a><strong>7.顶层对象的属性</strong></h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。 </p><p>ES5之中，顶层对象的属性与全局变量是等价的。  这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道 。 其次，程序员很容易不知不觉地就创建了全局变量 。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 </p><p> ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><p> 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//“模式匹配”</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);<span class="comment">//x=&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span><span class="comment">//另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x = 1  y = 2</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br><span class="line"><span class="number">3</span><span class="comment">//嵌套</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];<span class="comment">//b=2</span></span><br><span class="line"><span class="number">4</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">//head=1tail=[2, 3, 4]</span></span><br><span class="line"><span class="number">5</span><span class="comment">//只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="comment">//sixth=5</span></span><br><span class="line"><span class="number">6</span><span class="comment">//解构赋值允许指定默认值。</span></span><br><span class="line">[x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="number">7</span><span class="comment">//ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">//x=null</span></span><br><span class="line"><span class="comment">//undefined == null true</span></span><br></pre></td></tr></table></figure><h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//对象的解构赋值.数组的元素是按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span></span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="number">2</span><span class="comment">//如果变量名与属性名不一致，必须写成下面这样。</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="number">3</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line"><span class="comment">//f = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">//l = &#x27;world&#x27;</span></span><br><span class="line"><span class="number">4</span><span class="comment">//与数组一样，解构也可以用于嵌套结构的对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="number">5</span><span class="comment">//对象的解构也可以指定默认值。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//默认值生效的条件是，对象的属性值严格等于undefined。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点</span></span><br><span class="line"><span class="number">1</span><span class="comment">//如果要将一个已经声明的变量用于解构赋值，必须非常小心。</span></span><br><span class="line"><span class="comment">//JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;<span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="number">2</span><span class="comment">//由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">//类似数组的对象都有一个length属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数参数的默认值、解构赋值的默认值和解构赋值</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p><strong>函数参数的默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p><strong>解构赋值的默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值</p><p><strong>为了更容易理解，将上面两个代码合成一个，如下。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123; x: <span class="number">1</span>, y: <span class="number">1</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解构赋值的模式 &#123;x, y&#125;</span></span><br><span class="line"><span class="comment">// 解构赋值的默认值 x = 0, y = 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;x: 3, y: 8&#125; </span></span><br><span class="line"><span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;x: 3&#125; </span></span><br><span class="line"><span class="comment">// [3, 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;&#125; </span></span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(move()); <span class="comment">// 被解构赋值的参数 : &#123;x: 1, y: 1&#125; </span></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(<span class="literal">undefined</span>)); <span class="comment">// 被解构赋值的参数 : &#123;x: 1, y: 1&#125; </span></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h2 id="5-变量的解构赋值的作用"><a href="#5-变量的解构赋值的作用" class="headerlink" title="5.变量的解构赋值的作用"></a>5.变量的解构赋值的作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）交换变量的值</span><br><span class="line">（<span class="number">2</span>）从函数返回多个值</span><br><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line">（<span class="number">3</span>）函数参数的定义</span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line">（<span class="number">4</span>）提取 <span class="built_in">JSON</span> 数据</span><br><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line">（<span class="number">5</span>）函数参数的默认值(数组或者对象的默认值)</span><br><span class="line">（<span class="number">6</span>）遍历 <span class="built_in">Map</span> 结构</span><br><span class="line">（<span class="number">7</span>）输入模块的指定方法</span><br></pre></td></tr></table></figure><h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。</span></span><br><span class="line"><span class="string">&quot;\u0061&quot;</span>  <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">//但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</span></span><br><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="string">&quot;\u20BB7&quot;</span></span><br><span class="line"><span class="comment">// &quot; 7&quot;,如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</span></span><br><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;,只要将码点放入大括号，就能正确解读该字符</span></span><br><span class="line"><span class="comment">//&#x27;\u&#123;1F680&#125;&#x27; === &#x27;\uD83D\uDE80&#x27;大括号表示法与四字节的UTF-16编码是等价的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。charCodeAt方法只能分别返回前两个字节和后两个字节的值</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="comment">//汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271）</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;20bb7&quot;</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;61&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">is32Bit(<span class="string">&quot;𠮷&quot;</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">&quot;a&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">//ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）.所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。</span></span><br><span class="line"><span class="comment">//String.fromCodePoint</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">字符串的遍历器接口：<span class="keyword">for</span>...of循环遍历，可以识别大于<span class="number">0xFFFF</span>的码点</span><br><span class="line">ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于<span class="number">0xFFFF</span>的字符。</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="string">&#x27;𠮷&#x27;</span>.charAt(<span class="number">0</span>) <span class="comment">// &quot;\uD842&quot;</span></span><br><span class="line"><span class="string">&#x27;𠮷&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>===<span class="string">&#x27;\u004F\u030C&#x27;</span> <span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.length <span class="comment">// 2</span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.normalize() === <span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="comment">//如果repeat的参数是负数或者Infinity，会报错。</span></span><br><span class="line"><span class="comment">//如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</span></span><br><span class="line"><span class="comment">//参数NaN等同于0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板字符串，</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"><span class="comment">//模板字符串之中还能调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6还为原生的String对象，提供了一个raw方法。</span></span><br><span class="line"><span class="comment">//String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// &quot;Hi\\n5!&quot;</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// &#x27;Hi\\u000A!&#x27;</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">&#x27;test&#x27;</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#x27;t0e1s2t&#x27;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><p> 字符串对象共有4个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。 </p><p>ES6对正则表达式添加了<code>u</code>修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对于码点大于<code>0xFFFF</code>的Unicode字符，点字符不能识别，必须加上<code>u</code>修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/^.$/</span>.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别。  使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的Unicode字符。 </p><p> 除了<code>u</code>修饰符，ES6还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。 </p><p> <code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 </p><h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><ol><li>二进制和八进制表达方式</li></ol><p> ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p><ol start="2"><li><code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。 </li></ol><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。 </p><p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code>。 </p><ol start="3"><li><code>parseInt()</code>和<code>parseFloat()</code> </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="comment">// ES6的写法，这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Number.isInteger() </li></ol><p> <code>Number.isInteger()</code>用来判断一个数值是否为整数。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>5.Math对象的扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.Math.trunc()</span><br><span class="line">Math.trunc方法用于去除一个数的小数部分，返回整数部分。</span><br><span class="line">对于非数值，Math.trunc内部使用Number方法将其先转为数值。</span><br><span class="line">Math.trunc(&#x27;123.456&#x27;) // 123</span><br><span class="line">Math.trunc(true) //1</span><br><span class="line">Math.trunc(false) // 0</span><br><span class="line">Math.trunc(null) // 0</span><br><span class="line">对于空值和无法截取整数的值，返回NaN。</span><br><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(&#x27;foo&#x27;);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br><span class="line">Math.trunc(undefined) // NaN</span><br><span class="line">2.Math.sign()</span><br><span class="line">Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</span><br><span class="line">它会返回五种值。</span><br><span class="line">参数为正数，返回+1；参数为负数，返回-1；</span><br><span class="line">参数为 0，返回0；参数为-0，返回-0;</span><br><span class="line">其他值，返回NaN。</span><br><span class="line">Math.sign(&#x27;&#x27;)  // 0</span><br><span class="line">Math.sign(true)  // +1</span><br><span class="line">Math.sign(false)  // 0</span><br><span class="line">Math.sign(null)  // 0</span><br><span class="line">Math.sign(&#x27;9&#x27;)  // +1</span><br><span class="line">Math.sign(&#x27;foo&#x27;)  // NaN</span><br><span class="line">Math.sign()  // NaN</span><br><span class="line">Math.sign(undefined)  // NaN</span><br><span class="line">3.Math.cbrt()方法用于计算一个数的立方根。对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。</span><br></pre></td></tr></table></figure><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（<strong>iterable</strong>）的对象（包括ES6新增的数据结构Set和Map）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。只要是部署了<strong>Iterator</strong>接口的数据结构，<code>Array.from</code>都能将其转为数组。</p><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>Array.of</code>方法用于将一组值，转换为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="comment">//参数个数只有一个时，实际上是指定数组的长度。</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure><p>它接受三个参数。</p><ul><li>target（必需）：从该位置开始替换数据。</li><li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="find-和findIndex"><a href="#find-和findIndex" class="headerlink" title="find()和findIndex()"></a>find()和findIndex()</h2><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出<strong>第一个</strong>返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于0的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p><code>fill</code>方法使用给定值，填充一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。</p><h2 id="entries-，keys-和values"><a href="#entries-，keys-和values" class="headerlink" title="entries()，keys()和values()"></a>entries()，keys()和values()</h2><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="简洁表示法"><a href="#简洁表示法" class="headerlink" title="简洁表示法"></a>简洁表示法</h2><h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a><strong>属性简写</strong></h3><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line"> <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a><strong>方法简写</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个实际的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值，将会非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure><p>CommonJS模块输出变量，就非常合适使用简洁写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">getItem</span>: getItem,</span><br><span class="line">  <span class="attr">setItem</span>: setItem,</span><br><span class="line">  <span class="attr">clear</span>: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cart = &#123;</span><br><span class="line">  <span class="attr">_wheels</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;数值太小了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;class&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p><p>如果某个方法的值是一个Generator函数，前面需要加上星号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有两种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p><p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">abc</span>: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">&#x27;valueA&#x27;</span>,</span><br><span class="line">  [keyB]: <span class="string">&#x27;valueB&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: &quot;valueB&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">firstName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   <span class="comment">// &quot;sayName&quot;</span></span><br><span class="line">person.firstName.name <span class="comment">// &quot;get firstName&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上<code>get</code>。如果是存值函数，方法名的前面会加上<code>set</code>。</p><p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回“bound”加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回“anonymous”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// &quot;bound doSomething&quot;</span></span><br></pre></td></tr></table></figure><p>如果对象的方法是一个Symbol值，那么<code>name</code>属性返回的是这个Symbol值的描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">obj[key2].name <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>key1</code>对应的Symbol值有描述，<code>key2</code>没有。</p><h2 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p>ES5有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</li></ul><p>ES6新增了一个操作<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p><p>这四个操作之中，只有<code>for...in</code>会返回继承的属性。实际上，引入<code>enumerable</code>的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过这种手段，不会被<code>for...in</code>遍历到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;toString&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">&#x27;length&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p><p>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;<span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125;&#125;.prototype, <span class="string">&#x27;foo&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>目前，ES7有一个<a href="https://github.com/sebmarkbage/ecmascript-rest-spread">提案</a>，将Rest运算符（解构赋值）/扩展运算符（<code>...</code>）引入对象。Babel转码器已经支持这项功能。</p><p><strong>（1）解构赋值</strong></p><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p>另外，解构赋值不会拷贝继承自原型对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123; ...o2 &#125;;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>o3</code>是<code>o2</code>的拷贝，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量<code>y</code>和<code>z</code>，只能读取对象自身的属性，所以只有变量<code>z</code>可以赋值成功。</p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用x和y参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><p><strong>（2）扩展运算符</strong></p><p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>这等同于使用<code>Object.assign</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符可以用于合并两个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="built_in">Object</span>.assign(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p><p>这用来修改现有对象部分的部分属性就很方便了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;New Name&#x27;</span> <span class="comment">// Override the name property</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">    throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not thrown yet&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为x属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">      throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;thrown now&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这个两个值会被忽略，不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject = &#123; ...null, ...undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="属性删除"><a href="#属性删除" class="headerlink" title="属性删除"></a>属性删除</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> 删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。 </p><p> 只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p> <code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a><strong>属性是否存在：in 运算符</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> <code>in</code>运算符的一个问题是，<strong>它不能识别哪些属性是对象自身的，哪些属性是继承的。</strong><br> 可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.valueOf() === obj // true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">1 + obj // &quot;1[object Object]&quot;</span><br></pre></td></tr></table></figure><p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure><p>返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。</p><p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(value)</span><br></pre></td></tr></table></figure><p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。</p><p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p><ul><li>数值：返回<code>[object Number]</code>。</li><li>字符串：返回<code>[object String]</code>。</li><li>布尔值：返回<code>[object Boolean]</code>。</li><li>undefined：返回<code>[object Undefined]</code>。</li><li>null：返回<code>[object Null]</code>。</li><li>数组：返回<code>[object Array]</code>。</li><li>arguments 对象：返回<code>[object Arguments]</code>。</li><li>函数：返回<code>[object Function]</code>。</li><li>Error 对象：返回<code>[object Error]</code>。</li><li>Date 对象：返回<code>[object Date]</code>。</li><li>RegExp 对象：返回<code>[object RegExp]</code>。</li><li>其他对象：返回<code>[object Object]</code>。</li></ul><p><a href="https://wangdoc.com/javascript/stdlib/attributes.html">https://wangdoc.com/javascript/stdlib/attributes.html</a></p><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES5可以通过下面的代码，部署<code>Object.is</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p><p>属性名为Symbol值的属性，也会被<code>Object.assign</code>拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="built_in">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><code>Object.assign</code>方法实行的是<strong>浅拷贝</strong>，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p><p>有一些函数库提供<code>Object.assign</code>的定制版本（比如Lodash的<code>_.defaultsDeep</code>方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p><p>注意，<code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign</code>把数组视为属性名为0、1、2的对象，因此目标数组的0号属性<code>4</code>覆盖了原数组的0号属性<code>1</code>。</p><h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><p><code>Object.assign</code>方法有很多用处。</p><p><strong>（1）为对象添加属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p><p><strong>（2）为对象添加方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p><p><strong>（3）克隆对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）合并多个对象</strong></p><p>将多个对象合并到某个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  <span class="function">(<span class="params">target, ...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  <span class="function">(<span class="params">...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><p><strong>（5）为属性指定默认值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p><p>注意，由于存在深拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致<code>DEFAULTS</code>对象的该属性不起作用。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto，[propertiesObject])</span><br></pre></td></tr></table></figure><ul><li><p>proto<br>新创建对象的原型对象。</p></li><li><p>propertiesObject<br>可选。需要传入一个对象，<strong>该对象的属性类型参照Object.defineProperties()的第二个参数</strong>。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// Uncaught TypeError: Property description must be an object: 3</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1</span></span><br><span class="line">obj.b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))<span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>,&#123;<span class="attr">a</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,       <span class="comment">// 属性值</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,     <span class="comment">//  是否可以重写值</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">//是否可枚举</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>  <span class="comment">//是否可以修改以上几项配置</span></span><br><span class="line">&#125;&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123;a: 2&#125;</span></span><br><span class="line">obj2.a=<span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj2)<span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p><strong><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</strong></p><h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><strong><code>__proto__</code>属性</strong></h4><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括IE11）都部署了这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入ES6的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p><p>在实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">proto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="literal">undefined</span> || <span class="built_in">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(<span class="built_in">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="built_in">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure><h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象。它是ES6正式推荐的设置原型对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p><h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p>该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><h4 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong><br>obj<br>要定义属性的对象。</li><li>prop<br>要定义或修改的属性的名称或 Symbol 。</li><li>descriptor<br>要定义或修改的属性描述符。</li></ul><p>对象里目前存在的属性描述符有两种主要形式：<em>*<em>数据描述符</em>和*存取描述符</em><strong>。<em>数据描述符</em>是一个具有值的属性，该值可以是可写的，也可以是不可写的。<em>存取描述符</em>是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；</strong>不能同时是两者**。</p><ul><li><p>configurable<br>true 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。<br>默认为 false</p></li><li><p>enumerable<br>true 只有在枚举相应对象上的属性时该属性显现。<br>默认为 false</p><p><code>enumerable</code> 定义了对象的属性是否可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a> 中被枚举。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;c&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">3</span> &#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a,d</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// [&#x27;a&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>value<br>与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。<br>默认为 undefined.</p></li><li><p>writable<br>true只有与该属性相关联的值被assignment operator改变时。<br>默认为 false</p></li><li><p>get<br>作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。<br>默认为 undefined</p></li><li><p>set<br>作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。<br>默认为 undefined</p></li></ul><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>方法会返回一个布尔值，指示对象<strong>自身属性</strong>中是否具有指定的属性（也就是，是否有指定的键）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.property1 = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.hasOwnProperty(<span class="string">&#x27;property1&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure><p>即使属性的值是 null 或 undefined，只要属性存在，hasOwnProperty 依旧会返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.propOne = <span class="literal">null</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;propOne&#x27;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">o.propTwo = <span class="literal">undefined</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;propTwo&#x27;</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><p><strong>自身属性与继承属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.prop = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);             <span class="comment">// 返回 true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>);         <span class="comment">// 返回 false</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;hasOwnProperty&#x27;</span>);   <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><h4 id="getOwnPropertyDescriptors"><a href="#getOwnPropertyDescriptors" class="headerlink" title="getOwnPropertyDescriptors"></a>getOwnPropertyDescriptors</h4><p>ES5有一个<code>Object.getOwnPropertyDescriptor</code>方法，返回某个对象属性的描述对象（descriptor）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123; value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>ES7有一个提案，提出了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的提出目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowMerge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象<code>obj</code>。</p><p>另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: prot,</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(prot);</span><br><span class="line">obj.foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现Mixin（混入）模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(</span><br><span class="line">    <span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">      c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>。</p><p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，还会有<code>Reflect.getOwnPropertyDescriptors</code>方法。</p><h4 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h4><p>该方法返回一个数组，其中包含了当前对象<strong>所有属性</strong>的名称（字符串），不论它们是否可枚举。当然，也可以用<code>Object.keys()</code>来单独返回可枚举的属性。</p><h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>ES5引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p>目前，ES7有一个<a href="https://github.com/tc39/proposal-object-values-entries">提案</a>，引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p><p><code>Object.values</code>只返回对象自身的可遍历属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的。<code>Object.values</code>不会返回这个属性。</p><p><code>Object.values</code>会过滤属性名为Symbol值的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h4><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p><p>如果原对象的属性名是一个Symbol值，该属性会被省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非Symbol值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p><p><code>Object.entries</code>的基本用途是遍历对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line"><span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure><p><code>Object.entries</code>方法的一个用处是，将对象转为真正的<code>Map</code>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>自己实现<code>Object.entries</code>方法，非常简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    arr.push([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Iterator循环"><a href="#Iterator循环" class="headerlink" title="Iterator循环"></a>Iterator循环</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> JavaScript表示“<strong>集合</strong>”的数据结构：</p><p>数组（<code>Array</code>）和对象（<code>Object</code>），Map和Set</p><p>若 数组的成员是<code>Map</code>，<code>Map</code>的成员是对象 ， 这样就需要一种统一的接口机制，来处理所有不同的数据结构。  </p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构<strong>提供统一的访问机制</strong>。 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作 </p><p><strong>Iterator 的遍历过程是这样的。</strong></p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，<strong>遍历器对象本质上，就是一个指针对象。</strong></p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p> 每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。 </p><p>模拟<code>next</code>方法返回值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 </p><p> 默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。**<code>Symbol.iterator</code>属性本身是一个函数**，就是当前数据结构默认的遍历器生成函数。  执行这个函数，就会返回一个遍历器对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。</p><p> 一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。  </p><p> <strong>原生具备 Iterator 接口的数据结构如下。</strong></p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p> 变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。 </p><p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><h2 id="调用Iterator接口的场合"><a href="#调用Iterator接口的场合" class="headerlink" title="调用Iterator接口的场合"></a>调用Iterator接口的场合</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><strong>解构赋值</strong></h3><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a><strong>扩展运算符</strong></h3><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h3><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure><h3 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a><strong>其他场合</strong></h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h2 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h2><ol><li><p>最原始的写法就是<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组提供内置的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...in</code>循环可以遍历数组的键名。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for...in循环主要是为遍历对象而设计的，不适用于遍历数组。</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不同于forEach方法，它可以与break、continue和return配合使用。</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p><strong>基本用法</strong></p><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  y = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h2><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br></pre></td></tr></table></figure><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>（1）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br></pre></td></tr></table></figure><p><strong>（2）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>4）字符串</strong></p><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br></pre></td></tr></table></figure><p>上面的箭头函数等同于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p><p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="Class基本语法"><a href="#Class基本语法" class="headerlink" title="Class基本语法"></a>Class基本语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// &quot;function&quot;</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表明，<strong>类的数据类型就是函数，类本身就指向构造函数。</strong></p><p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的<code>prototype</code>属性上面。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/y9AUb9"><img src="https://s3.ax1x.com/2021/01/28/y9AUb9.png" alt="y9AUb9.png" style="zoom: 67%;" /></a></p><p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外，<strong>类的内部所有定义的方法，都是不可枚举的</strong>（non-enumerable）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure><p>这一点与ES5的行为不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，<strong>自动调用</strong>该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// return Object.create(this);将Foo赋值给了实例对象的原型对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo</span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p><h2 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;x&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;y&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code><strong>自身的属性</strong>（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与ES5的行为保持一致。</p><p>与ES5一样，类的所有实例共享一个原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.__proto__ === p2.__proto__</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是使用箭头函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&#x27; &#x27;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><p><strong>实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</strong><code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//Foo1&#123;&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//Foo1&#123;&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo1()</span><br></pre></td></tr></table></figure><h3 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>父类的静态方法，可以被子类继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.classMethod() + <span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod();</span><br></pre></td></tr></table></figure><h2 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，（在构造函数中）返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用new生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">&#x27;张三&#x27;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>不存在变量提升</li><li>类的所有实例共享一个原型对象（_proto_）</li><li>类本身就指向构造函数</li><li>类的所有方法都定义在类的<code>prototype</code>属性上面</li><li>类的内部所有定义的方法，都是不可枚举的</li><li>类没有自身属性，所有方法都定义在类的<code>prototype</code>属性上面。而类创造的实例，有自身属性，这是类中constructor赋值给实例的，相当于调用了类中的constructor方法，并返回给实例对象。</li></ul><h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p> Promise 是异步编程的一种解决方案，所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 </p><p> <code>Promise</code>对象有以下两个特点 ：</p><p>1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。 <code>resolved</code>统一只指<code>fulfilled</code>状态 </p><p><strong>优点：</strong> 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数 </p><p><strong>缺点：</strong> 无法取消<code>Promise</code>  其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。    </p><h2 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h2><p> <code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);<span class="comment">//在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。第二个函数是可选的，不一定要提供。</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br><span class="line"><span class="comment">//Promise 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。</span></span><br></pre></td></tr></table></figure><p><code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用<code>resolve</code>函数和<code>reject</code>函数时带有参数,参数是另一个Promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//`p1`和`p2`都是 Promise 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。p1的状态由p2决定</span></span><br><span class="line"><span class="comment">//注意，这时`p1`的状态就会传递给`p2`，也就是说，`p1`的状态决定了`p2`的状态。如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变；如果`p1`的状态已经是`resolved`或者`rejected`，那么`p2`的回调函数将会立刻执行。</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br><span class="line"><span class="comment">//上面代码中，`p1`是一个 Promise，3 秒之后变为`rejected`。`p2`的状态在 1 秒之后改变，`resolve`方法返回的是`p1`。由于`p2`返回的是另一个 Promise，导致`p2`自己的状态无效了，由`p1`的状态决定`p2`的状态。所以，后面的`then`语句都变成针对后者（`p1`）。又过了 2 秒，`p1`变为`rejected`，导致触发`catch`方法指定的回调函数。</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p> <code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&quot;/post/1.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p> <code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/posts.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，**<code>then()</code>方法指定的回调函数**，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。 </p><p>建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。  理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">2.</span><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">3.</span><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>3种写法等价， 抛出一个错误 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p> Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 </p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p> <code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 <code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p> 在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。  </p><h3 id="Promise-prototype-all"><a href="#Promise-prototype-all" class="headerlink" title="Promise.prototype.all()"></a>Promise.prototype.all()</h3><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p> <code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，<strong>如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理</strong>。另外，<code>Promise.all()</code>方法的参数可以不是数组，但<strong>必须具有 Iterator 接口</strong>，且返回的每个成员都是 Promise 实例。 </p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><h3 id="Promise-resolve-reject"><a href="#Promise-resolve-reject" class="headerlink" title="Promise.resolve/reject"></a>Promise.resolve/reject</h3><p>有时需要将<strong>现有对象转为 Promise 对象</strong>，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;我在第二行&#x27;</span>);</span><br><span class="line"><span class="comment">//Promise.resolve(&#x27;foo&#x27;)</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">//new Promise(resolve =&gt; resolve(&#x27;foo&#x27;))</span></span><br><span class="line"><span class="keyword">var</span> cast = <span class="built_in">Promise</span>.resolve(original);</span><br><span class="line"><span class="comment">//参数original是一个 Promise 实例</span></span><br><span class="line"><span class="comment">//那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</span></span><br><span class="line">cast.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value: &#x27;</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;original === cast ? &#x27;</span> + (original === cast));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;original === cast ? true&quot;</span></span><br><span class="line"><span class="comment">// &quot;value: 我在第二行&quot;</span></span><br></pre></td></tr></table></figure><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>Generator 函数的语法糖 , 使得异步操作变得更加方便。 </p><h2 id="async对-Generator-的改进"><a href="#async对-Generator-的改进" class="headerlink" title="async对 Generator 的改进"></a><code>async</code>对 Generator 的改进</h2><p> <code>async</code>函数对 Generator 函数的改进，体现在以下四点。 </p><p>（1）内置执行器</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。 不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行 </p><p>（2）更好的语义</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。 <code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。 </p><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><p>必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，<strong>除非遇到<code>return</code>语句或者抛出错误</strong>。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。 </p><ul><li><p>async<code>函数内部抛出错误，会导致返回的Promise对象变为</code>reject<code>状态。抛出的错误对象会被</code>catch`方法回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">        a=<span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="comment">// return e //[TypeError: Assignment to constant variable.]</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);<span class="comment">//[Error: TypeError: Assignment to constant variable.]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">    <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line">  <span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p></li><li><p>没有return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="comment">//没有return，就类似于resolved(undefined)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">    <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),<span class="comment">//undefined</span></span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>return出来一个promise对象。如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p></li></ul><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><ul><li><p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西(会被转成一个立即<code>resolve</code>的Promise对象)。</p></li><li><p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a= <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved</span>)=&gt;</span>&#123;</span><br><span class="line">        resolved(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></li><li><p>执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;)()<span class="comment">//这里模拟的是请求事件</span></span><br><span class="line">    <span class="keyword">let</span> b = a<span class="comment">//必须a获取到</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>,b)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1,3,4/5,2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);<span class="comment">//进入异步队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>) </span><br><span class="line">、、</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">asnyc1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeOut</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">//出错了</span></span><br></pre></td></tr></table></figure><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p><code>async</code>函数返回的 Promise 对象</p><p>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><h1 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h1><p>TypeScript 是一门基于 JavaScript 拓展的语言，它是 JavaScript 的超集，并且给 JavaScript 添加了静态类型检查系统。TypeScript 能让我们在开发时发现程序中类型定义不一致的地方，及时消除隐藏的风险，大大增强了代码的可读性以及可维护性。</p><h2 id="TS和JS"><a href="#TS和JS" class="headerlink" title="TS和JS"></a>TS和JS</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><strong>1. JavaScript运行依赖NodeJs环境和浏览器环境</strong></p><p><a href="https://www.cnblogs.com/raind/p/10568159.html">https://www.cnblogs.com/raind/p/10568159.html</a></p><p>javascript是一种解释型，直译式脚本语言，JavaScript 本身是没有预编译的，浏览器内的js引擎直接解释源代码并执行。在浏览器运行 JavaScript 之前必须编译成客户端的机器码。</p><ul><li>将<code>JavaScript</code>代码转换为<code>JavaScript-AST</code></li><li>将<code>AST</code>代码转换为字节码</li><li>运算时计算字节码</li></ul><p><strong>2. TypeScript运行流程，以下操作均为TSC操作，三步执行完继续同上操作，让浏览器解析</strong></p><p><a href="https://zhuanlan.zhihu.com/p/45898674">https://zhuanlan.zhihu.com/p/45898674</a></p><ul><li>将<code>TypeScript</code>代码编译为 <code>TypeScript-AST</code></li><li>检查<code>AST</code>代码上<strong>类型检查</strong></li><li>类型检查后，编译为<code>JavaScript</code>代码</li><li><code>JavaScript</code>代码转换为<code>JavaScript-AST</code></li><li>将<code>AST</code>代码转换为字节码</li><li>运算时计算字节码</li></ul><p><img src="https://pic1.zhimg.com/v2-4f4017f944fb4ef89084df4bcdc79d3c_r.jpg" alt="preview"></p><p>1.<strong>预处理器（preprocessing）处理</strong></p><p>预处理器负责根据<code>待编译文件</code>计算参与编译的文件，生成<code>源文件</code>列表，构成<code>编译上下文</code> 和 <code>Program</code></p><img src="https://pic2.zhimg.com/80/v2-d130e0803514d7562191618337a74b2d_720w.jpg" alt="img" style="zoom:50%;" /><p><strong>编译列表中的文件 = 待编译文件 + 依赖文件 + @types 文件</strong></p><p><strong>待编译文件</strong>:默认为项目目录下所有的 .ts、.tsx、.d.ts 为待编译文件(tsconfig.json)</p><p><strong>依赖文件</strong> :</p><ol><li><code>&lt;reference path=... /&gt;</code> 标签引入的依赖声明文件</li><li><code>import</code> 表达式引入的文件</li></ol><blockquote><p>注意：<br>当解析 import 导入的的时候，会优先选择 .ts/.tsx文件而不是 .d.ts 文件，以确保处理的是最新的文件</p></blockquote><p><strong>@types</strong>:</p><p>所有可见的 <code>@types</code> 目录下的所有文件</p><blockquote><p>如：<code>node_modules/@types</code>、<code>./node_modules/@types/</code>等等</p></blockquote><p>2.<strong>语法分析器（parser）处理</strong></p><p>语法分析器将<code>预处理器</code>得到的<code>源文件列表</code>中的文件解析生成包含抽象语法树（AST）Node 的 <code>SourceFile</code> 对象</p><p><strong><code>SourceFile</code>对象 = <code>源文件 AST</code> + <code>额外信息</code> (如文件名及文件信息等)</strong></p><p><a href="https://blog.csdn.net/qq_41257129/article/details/100901729">https://blog.csdn.net/qq_41257129/article/details/100901729</a></p><blockquote><p>类似：</p><p> var myDiv = React.createElement(‘div’, { title: ‘this is a div’, id: ‘mydiv’ }, ‘这是一个div’, myH1)</p></blockquote><p>3.<strong>联合器（Binder）处理</strong></p><p>联合器遍历并处理<code>语法分析器</code>生成的 <code>AST</code>，并将 AST 中的声明结合放到一个 <code>Symbol</code> 中。</p><p>然后通过 <code>createSourceFile</code> API 生成带有 <code>Symbol</code>的 <code>SourceFile</code></p><p><strong><code>SourceFile对象</code> = <code>源文件 AST</code> + <code>Symbol</code> + <code>额外信息</code> (如文件名及文件信息等)</strong></p><blockquote><p>此时的 Symobl 仅表示<strong>单个文件</strong>的声明信息</p></blockquote><p>4.、<strong>类型解析器与检查器（Type resolver / Checker）处理</strong></p><p><strong>4.1、生成 <code>Program</code></strong></p><p>通过调用 <code>createProgramAPI</code> 来创建 <code>Program</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program = All SourceFile + CompilerOptions</span><br></pre></td></tr></table></figure><p><strong>4.2、生成 <code>TypeChecker</code> 进行处理</strong></p><p>通过 <code>Program</code> 实例创建 <code>TypeChecker</code></p><blockquote><p>TypeChecker是TypeScript类型系统的核心，它负责计算出不同文件里的Symbols之间的关系，将Type赋值给Symbol，并生成任何语义Diagnostic（比如：error）</p></blockquote><p>处理内容：</p><ol><li><p><code>TypeChecker</code> <strong>合并</strong>不同的 <code>SourceFile</code> 里的 <code>Symbol</code> 到一个单独的视图，创建单一的<code>Symbol</code>表（囊括所有文件的全局Symbol视图 ）</p></li><li><p>类型检查</p><blockquote><p>Symbol 合并到一张表后，TypeChecker就可以解决关于这个程序的任何问题了。 这些“问题”可以是：</p><ol><li><p>这个Node的Symbol是什么？</p></li><li><p>这个Symbol的Type是什么？</p></li><li><p>在AST的某个部分里有哪些Symbol是可见的？</p></li><li><p>某个函数声明的Signature都有哪些？</p></li><li><p>针对某个文件应该报哪些错误？</p></li></ol></blockquote></li></ol><p><strong>5.生成器（Emitter）处理</strong></p><p>通过 Program 创建一个 Emitter</p><p>Emitter 将给定的 SourceFile 生成编译后文件（<code>.js</code>，<code>.jsx</code>，<code>.d.ts</code>和<code>.js.map</code>）</p><h3 id="类型绑定"><a href="#类型绑定" class="headerlink" title="类型绑定"></a>类型绑定</h3><p><strong>JavaScript</strong></p><p>JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型。<code>JavaScript</code><strong>动态</strong>绑定类型，只有运行程序才能知道类型，在程序运行之前<code>JavaScript</code>对类型一无所知</p><p><strong>TypeScript</strong></p><p><code>TypeScript</code>是在程序运行前（也就是编译时）就会知道当前是什么类型。当然如果该变量没有定义类型，那么<code>TypeScript</code>会自动类型推导出来。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>JavaScript弱类型语言</strong></p><p>比如在<code>JavaScript</code>中<code>1 + true</code>这样一个代码片段，<code>JavaScript</code>存在隐式转换，这时<code>true</code>会变成<code>number</code>类型<code>number(true)</code>和1相加。</p><p><strong>TypeScript强类型语言</strong></p><p>在<code>TypeScript</code>中，<code>1+true</code>这样的代码会在<code>TypeScript</code>中报错，提示<code>number</code>类型不能和<code>boolean</code>类型进行运算。</p><h3 id="何时检查类型"><a href="#何时检查类型" class="headerlink" title="何时检查类型"></a>何时检查类型</h3><p><strong>JavaScript</strong></p><p>在<code>JavaScript</code>中只有在程序运行时才能检查类型。类型也会存在隐式转换，很坑。</p><p><strong>TypeScript</strong></p><p>在<code>TypeScript</code>中，在编译时就会检查类型，如果和预期的类型不符合直接会在编辑器里报错、爆红</p><h2 id="TS特殊符号"><a href="#TS特殊符号" class="headerlink" title="TS特殊符号"></a>TS特殊符号</h2><p><a href="https://blog.csdn.net/qiwoo_weekly/article/details/108557466">https://blog.csdn.net/qiwoo_weekly/article/details/108557466</a></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="?. 运算符"></a>?. 运算符</h3><p>可选链（Optional Chaining）运算符是一种先检查属性是否存在，再尝试访问该属性的运算符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 相当于 a == null ? undefined : a.b;</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a.b 的值.</span></span><br><span class="line"></span><br><span class="line">a?.[x];</span><br><span class="line"><span class="comment">// 相当于 a == null ? undefined : a[x];</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a[x] 的值</span></span><br><span class="line"></span><br><span class="line">a?.b();</span><br><span class="line"><span class="comment">// 相当于a == null ? undefined : a.b();</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是函数的话，会抛类型错误异常，否则计算 a.b() 的结果</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>在 TypeScript 中使用 <code>interface</code> 关键字就可以声明一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="keyword">string</span>;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">let semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们声明了 <code>Person</code> 接口，它包含了两个必填的属性 <code>name</code> 和 <code>age</code>。在初始化 Person 类型变量时，如果缺少某个属性，TypeScript 编译器就会提示相应的错误信息，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.(2741)</span></span><br><span class="line">let lolo: Person  = &#123; <span class="comment">// Error</span></span><br><span class="line">  name: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述的问题，我们可以把某个属性声明为可选的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="keyword">string</span>;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lolo: Person  = &#123;</span><br><span class="line">  name: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="| 分隔符"></a>| 分隔符</h3><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的一种，联合类型使用 <code>|</code> 分隔每个类型。联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = (name: <span class="keyword">string</span> | undefined) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>以上示例中 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>定义类型由两种方式：接口（interface）和类型别名（type alias）</p><p>interface只能定义对象类型，type声明的方式可以定义组合类型，交叉类型和原始类型</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;<span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;<span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;  <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure><p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ```），并且以<code>$&#123; expr &#125;</code>这种形式嵌入表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><p>这与下面定义<code>sentence</code>的方式效果相同：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +<span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在<strong>元素类型</strong>后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第二种方式是使用<strong>数组泛型</strong>，<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的<strong>数组</strong>，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用<strong>联合类型</strong>替代：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log(c);    <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，<strong>我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库</strong>。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在<strong>编译时</strong>可选择地包含或移除类型检查。 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.toFixed(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure><p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something: <span class="built_in">any</span>;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p><strong>null</strong></p><p>在 JavaScript 中 null 表示 “什么都没有”。</p><p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p><p>用 typeof 检测 null 返回是 object。</p><p><strong>undefined</strong></p><p>在 JavaScript 中, undefined 是一个没有设置值的变量。</p><p>typeof 一个没有值的变量会返回 undefined。</p><p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行错误</span></span><br></pre></td></tr></table></figure><p>上面的例子中变量 x 只能是数字类型。如果一个类型可能出现 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行正确</span></span><br></pre></td></tr></table></figure><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 是其它类型（包括 null 和 undefined）的子类型，代表那些永不存在的值的类型。这意味着声明为 never 类型的变量只能被 never 类型所赋值。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p><p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的<strong>类型转换</strong>，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 <strong>TypeScript会假设程序员，已经进行了必须的检查。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：&lt;类型&gt;值 或 值 as 类型</span><br><span class="line">在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种</span><br></pre></td></tr></table></figure><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>另一个为<code>as</code>语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><ul><li><p>例子一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func(val: string | number): number &#123;</span><br><span class="line">  if (val.length) &#123;</span><br><span class="line">    return val.length</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return val.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数 val 是一个联合类型，在这里的意思是说 val 可以是字符串类型也可以是数值类型。代码中要返回参数的长度，但是 length 是字符串的属性，而数值是没有这个属性的，所以当 val 是数值时，就先用 toSting() 来将数字转换为字符串再取长度。这样的逻辑本身没问题，但是在编译阶段一访问 val.length 时就报错了，因为 <strong>访问联合类型值的属性时，这个属性必须是所有可能类型的共有属性，</strong>而length不是共有属性，val 的类型此时也没确定，所以编译不通过。为了通过编译，此时就可以使用类型断言了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func(val: string | number): number &#123;</span><br><span class="line">  if ((&lt;string&gt;val).length) &#123;</span><br><span class="line">    return (&lt;string&gt;val).length</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return val.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.bar = 123; // Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span><br><span class="line">foo.bas = &#x27;hello&#x27;; // Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">interface Foo &#123;</span><br><span class="line">  bar: number;</span><br><span class="line">  bas: string;</span><br><span class="line">&#125;</span><br><span class="line">const foo = &#123;&#125; as Foo;</span><br><span class="line">foo.bar = 123;</span><br><span class="line">foo.bas = &#x27;hello&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="const-断言"><a href="#const-断言" class="headerlink" title="const 断言"></a>const 断言</h4><p>TypeScript 3.4 引入了一种新的字面量构造方式，也称为 const 断言。当我们使用 const 断言构造新的字面量表达式时，我们可以向编程语言发出以下信号</p><ul><li>表达式中的任何字面量类型都不应该被扩展；</li><li><strong>对象字面量的属性</strong>，将使用 <code>readonly</code> 修饰；</li><li><strong>数组字面量</strong>将变成 <code>readonly</code> 元组。</li></ul><p>下面我们来举一个 const 断言的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> X = <span class="keyword">typeof</span> x; <span class="comment">// type X = &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> y:X=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> Y = <span class="keyword">typeof</span> y; <span class="comment">// type Y = readonly [10, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">text</span>: <span class="string">&quot;hello&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> Z = <span class="keyword">typeof</span> z; <span class="comment">// let z: &#123; readonly text: &quot;hello&quot;; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="类型断言的用途"><a href="#类型断言的用途" class="headerlink" title="类型断言的用途"></a>类型断言的用途</h4><ul><li>将一个联合类型断言为其中一个类型</li><li>将一个父类断言为更加具体的子类</li><li>将任何一个类型断言为 <code>any</code></li><li>将 <code>any</code> 断言为一个具体的类型</li></ul><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><p>事实上，它等价于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>作用：</strong></p><ul><li>对“对象”进行约束描述</li><li>对“类”的一部分行为进行抽象</li></ul><p><strong>特点：</strong></p><ul><li><p>接口与值的结构必须相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">    size: number;</span><br><span class="line">    label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">    console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line">let myObj1 = &#123; label: &quot;Size 10 Object&quot; &#125;;</span><br><span class="line">let myObj2 = &#123; label: &quot;Size 10 Object&quot;, other:1 &#125;;</span><br><span class="line">//少了</span><br><span class="line">printLabel(myObj1);</span><br><span class="line">//多了</span><br><span class="line">printLabel(myObj2);</span><br></pre></td></tr></table></figure></li><li><p>可以捕获引用了不存在的属性时的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">    size: number;</span><br><span class="line">    label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">    console.log(labelledObj.labell);</span><br><span class="line">  &#125;</span><br><span class="line">let myObj = &#123; size:10, label: &quot;Size 10 Object&quot; &#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure></li></ul><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p><p>下面是应用了“option bags”的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;<span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;<span class="attr">color</span>: <span class="string">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， <code>x</code>和<code>y</code>再也不能被改变了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h3><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p><h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>&#123; size: number; label: string; &#125;</code>到仅期望得到<code>&#123; label: string; &#125;</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p><p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code>例子来说：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; width: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>注意传入<code>createSquare</code>的参数拼写为*<code>colour</code>*而不是<code>color</code>。 在JavaScript里，这会默默地失败。 <strong>编译器能够捕获引用了未声明属性的错误</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>解决</strong></p><ul><li>最简便的方法是使用<strong>类型断言</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure><ul><li>加上额外属性声明，允许对象引用除可选属性以外的其他属性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;<span class="comment">//加上额外属性声明，允许对象引用除可选属性以外的其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 具体的格式是一个只有<strong>参数列表</strong>和<strong>返回值类型</strong>的函数定义。<strong>参数列表</strong>里的每个参数都需要名字和类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">  (param1: <span class="built_in">string</span>, <span class="attr">param2</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何<strong>创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc: Func = <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> param1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> param2 === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</strong> 比如，我们使用下面的代码重写上面的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc: Func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> a === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字索引——约束数组</span></span><br><span class="line"><span class="comment">// index 是随便取的名字，可以任意取名</span></span><br><span class="line"><span class="comment">// 只要 index 的类型是 number，那么值的类型必须是 string</span></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  <span class="comment">// key 的类型为 number ，一般都代表是数组</span></span><br><span class="line">  <span class="comment">// 限制 value 的类型为 string</span></span><br><span class="line">  [index:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr:StringArray = [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串索引——约束对象</span></span><br><span class="line"><span class="comment">// 只要 index 的类型是 string，那么值的类型必须是 string</span></span><br><span class="line"><span class="keyword">interface</span> StringObject &#123;</span><br><span class="line">  <span class="comment">// key 的类型为 string ，一般都代表是对象</span></span><br><span class="line">  <span class="comment">// 限制 value 的类型为 string</span></span><br><span class="line">  [index:<span class="built_in">string</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj:StringObject = &#123;<span class="attr">name</span>:<span class="string">&#x27;ccc&#x27;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里， <code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&quot;Mallory&quot;</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p><h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候<strong>不同类之间可以有一些共有的特性</strong>，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;SecurityDoor alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SecurityDoor()</span><br><span class="line">a.alert()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Car()</span><br><span class="line">b.alert()</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口，下例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span>, <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">lightOn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">lightOff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>接口可以继承接口，下例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm：</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> <span class="title">implements</span> <span class="title">LightableAlarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">lightOn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">lightOff</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>接口也可以继承类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">point</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">point</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x)</span><br><span class="line">&#125;&#125;;</span><br><span class="line">point3d.point()</span><br></pre></td></tr></table></figure><p>为什么 TypeScript 会支持接口继承类呢？</p><p>实际上，当我们在声明 <code>class Point</code> 时，除了会创建一个名为 <code>Point</code> 的类之外，同时也创建了一个名为 <code>Point</code> 的类型（实例的类型）。</p><p>所以我们既可以将 <code>Point</code> 当做一个类来用（使用 <code>new Point</code> 创建它的实例）,也可以将 <code>Point</code> 当做一个类型来用（使用 <code>: Point</code> 表示参数的类型）</p><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SquareSquare <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square =&#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p><p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p><h3 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h3><p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p><ul><li>类（Class）：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 <code>new</code> 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h3 id="ES6-中类的用法"><a href="#ES6-中类的用法" class="headerlink" title="ES6 中类的用法"></a>ES6 中类的用法</h3><p>下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 <a href="http://es6.ruanyifeng.com/#docs/class">ECMAScript 6 入门 - Class</a>。</p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p><p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Meow, &#x27;</span> + <span class="built_in">super</span>.sayHi(); <span class="comment">// 调用父类的 sayHi()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(c.sayHi()); <span class="comment">// Meow, My name is Tom</span></span><br></pre></td></tr></table></figure><h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Kitty&#x27;</span>); <span class="comment">// setter: Kitty</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>; <span class="comment">// setter: Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">isAnimal</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">instanceof</span> Animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">Animal.isAnimal(a); <span class="comment">// true</span></span><br><span class="line">a.isAnimal(a); <span class="comment">// TypeError: a.isAnimal is not a function</span></span><br></pre></td></tr></table></figure><h3 id="ES7-中类的用法"><a href="#ES7-中类的用法" class="headerlink" title="ES7 中类的用法"></a>ES7 中类的用法</h3><p>ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。</p><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>ES7 提案中，可以使用 <code>static</code> 定义一个静态属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.num); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h3 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h3><h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>下面举一些例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code>private</code> 属性在外部的可访问性。</p><p>上面的例子编译后的代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.</span></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure><h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public name: string;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public readonly name;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p><p>什么是抽象类？</p><p>首先，抽象类是不允许被实例化的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p><p>其次，抽象类中的抽象方法必须被子类实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p><p>下面是一个正确使用抽象类的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends =</span><br><span class="line">  (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__extends) ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.constructor = d;</span><br><span class="line">    &#125;</span><br><span class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : ((__.prototype = b.prototype), <span class="keyword">new</span> __());</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> Cat = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">  __extends(Cat, _super);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _super.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Meow, My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Cat;</span><br><span class="line">&#125;)(Animal);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><p>给类加上 TypeScript 的类型很简单，与接口类似：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p><h4 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h4><p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</strong></p><p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p><p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="literal">undefined</span>, <span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&#x27;Cat&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&#x27;Tom&#x27;</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> cat = buildName(<span class="literal">undefined</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: any[] = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0">ES6 中的 rest 参数</a>。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h3><p>学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 <code>this</code>工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 <code>this</code>的地方。 如果你想了解JavaScript里的 <code>this</code>是如何工作的，那么首先阅读Yehuda Katz写的<a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda的文章详细的阐述了 <code>this</code>的内部工作原理，因此我们这里只做简单介绍。</p><h3 id="this和箭头函数"><a href="#this和箭头函数" class="headerlink" title="this和箭头函数"></a><code>this</code>和箭头函数</h3><p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p><p>下面看一个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>可以看到<code>createCardPicker</code>是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 <code>createCardPicker</code>返回的函数里的<code>this</code>被设置成了<code>window</code>而不是<code>deck</code>对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code>视为<code>window</code>。 （注意：在严格模式下， <code>this</code>为<code>undefined</code>而不是<code>window</code>）。</p><p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 <code>this</code>值，而不是调用时的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture &#x27;this&#x27; right here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。 它会指出 <code>this.suits[pickedSuit]</code>里的<code>this</code>的类型为<code>any</code>。</p><h3 id="this参数"><a href="#this参数" class="headerlink" title="this参数"></a><code>this</code>参数</h3><p>不幸的是，<code>this.suits[pickedSuit]</code>的类型依旧为<code>any</code>。 这是因为 <code>this</code>来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code>参数。 <code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">    <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">    card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">    cards: <span class="built_in">number</span>[];</span><br><span class="line">    createCardPicker(<span class="built_in">this</span>: Deck): <span class="function">() =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><p>现在TypeScript知道<code>createCardPicker</code>期望在某个<code>Deck</code>对象上调用。 也就是说 <code>this</code>是<code>Deck</code>类型的，而非<code>any</code>，因此<code>--noImplicitThis</code>不会报错了。</p><h3 id="this参数在回调函数里"><a href="#this参数在回调函数里" class="headerlink" title="this参数在回调函数里"></a><code>this</code>参数在回调函数里</h3><p>你可以也看到过在回调函数里的<code>this</code>报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， <code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过 <code>this</code>参数来避免错误。 首先，库函数的作者要指定 <code>this</code>的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type. Second, annotate your calling code with <code>this</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">onClickBad</span>(<span class="params"><span class="built_in">this</span>: Handler, e: Event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// oops, used this here. using this callback would crash at runtime</span></span><br><span class="line">        <span class="built_in">this</span>.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后TypeScript会检测到 <code>addClickListener</code>要求函数带有<code>this: void</code>。 改变 <code>this</code>类型来修复这个错误：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">onClickGood</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span>, e: Event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t use this here because it&#x27;s of type void!</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure><p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用 <code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123; <span class="built_in">this</span>.info = e.message &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可行的因为箭头函数不会捕获<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个 <code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 <code>Handler</code>的原型链上。 它们在不同 <code>Handler</code>对象间是共享的。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p><p>利用联合类型，我们可以这么实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p><p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><p>当我们需要写一个传入什么类型就得到什么类型的函数</p><ul><li><p>```<br>function one(a: any) : any{<br>  return a;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  function one(a: any) : any&#123;</span><br><span class="line">      if(typeof a === &#x27;number&#x27;) &#123;</span><br><span class="line">          let ret = (a as number)</span><br><span class="line">          return ret ;</span><br><span class="line">      &#125;</span><br><span class="line">      return a;</span><br><span class="line">  &#125;</span><br><span class="line">  //每一种类型都写一个方法</span><br></pre></td></tr></table></figure></li><li><p>```<br>function one<T>(a: T) : T{</p><pre><code>return a;</code></pre><p>}<br>let a1 = one<number>(1)<br>let a2 = one(520)<br>//描述T是什么类型的时候，你可以在<number>描述它是一个 number类型，同样也可以这样描述描述(a: T) 对应（520）， T 就是 520的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 泛型函数</span><br><span class="line"></span><br><span class="line">不用泛型的话，这个函数可能是下面这样：</span><br><span class="line"></span><br><span class="line">```ts</span><br><span class="line">function identity(arg: number): number &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者，我们使用<code>any</code>类型来定义函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>any</code>类型会导致这个函数可以接收任何类型的<code>arg</code>参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p><p>因此，我们需要一种方法使<strong>返回值的类型与传入参数的类型是相同的</strong>。 这里，我们使用了 <strong>类型变量</strong>，它是一种特殊的变量，只用于表示类型而不是值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/bVbIe5N" alt="generic-type-filled.jpg"></p><p><strong>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</strong></p><p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// type of output will be &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p><p>第二种方法更普遍。利用了<em><strong>类型推论</strong></em> – 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// type of output will be &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。</p><h4 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h4><p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p><p>看下之前<code>identity</code>例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想同时打印出<code>arg</code>的长度。我们很可能会这样做：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn&#x27;t have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，<strong>这些类型变量代表的是任意类型</strong>，所以使用这个函数的人可能传入的是个数字，而<strong>数字是没有 <code>.length</code>属性</strong>的。</p><p>现在假设我们想操作<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code>的的类型为<code>number</code>。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><p>我们也可以这样实现上面的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myGenericNumber.add(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">let myIdentity: GenericIdentityFn = identity;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以把泛型参数提前到接口名上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">name</span>: T;</span><br><span class="line">    getAge(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: Person&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;兔兔&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">getAge</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;。</span><br></pre></td></tr></table></figure><h3 id="泛型约束extends"><a href="#泛型约束extends" class="headerlink" title="泛型约束extends"></a>泛型约束extends</h3><p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn&#x27;t have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p><p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字来实现约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, 类型“number”的参数不能赋给类型“Lengthwise”的参数。</span></span><br></pre></td></tr></table></figure><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，type是type1和type2接口的交集。 就是说这个类型的对象同时拥有了这二种类型的成员。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> type1&#123;</span><br><span class="line">    <span class="attr">a1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">a2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type2&#123;</span><br><span class="line">    <span class="attr">b1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">b2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type&lt;t,k&gt;&#123;</span><br><span class="line">   <span class="attr">a</span>:t,</span><br><span class="line">   <span class="attr">b</span>:k</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c:<span class="keyword">type</span>&lt;type1,type2&gt; = &#123;</span><br><span class="line">   <span class="attr">a</span>:&#123;</span><br><span class="line">       <span class="attr">a1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">a2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">b</span>:&#123;</span><br><span class="line">       <span class="attr">b1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">b2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)<span class="comment">//&#123; a: &#123; a1: 1, a2: &#x27;1&#x27; &#125;, b: &#123; b1: 1, b2: &#x27;1&#x27; &#125; &#125; </span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> type1&#123;</span><br><span class="line">    <span class="attr">a1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">a2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type2&#123;</span><br><span class="line">    <span class="attr">b1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">b2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type&lt;t,k&gt;&#123;</span><br><span class="line">   a1,</span><br><span class="line">   a2,</span><br><span class="line">   b1,</span><br><span class="line">   b2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c:<span class="keyword">type</span>&lt;type1,type2&gt; = &#123;</span><br><span class="line">       <span class="attr">a1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">a2</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">       <span class="attr">b1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">b2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)<span class="comment">//&#123; a1: 1, a2: &#x27;1&#x27;, b1: 1, b2: &#x27;1&#x27; &#125; </span></span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。</p><p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p><h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据<strong>类型推论</strong>的规则推断出一个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p><p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p><h3 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a><code>typeof</code>类型保护</h3><h3 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a><code>instanceof</code>类型保护</h3><p><em><code>instanceof</code>类型保护</em>是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为&#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为&#x27;StringPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof</code>的右侧要求是一个构造函数，TypeScript将细化为：</p><ol><li>此构造函数的 <code>prototype</code>属性的类型，如果它的类型不为 <code>any</code>的话</li><li>构造签名所返回的类型的联合</li></ol><p>以此顺序。</p><h3 id="类型别名type"><a href="#类型别名type" class="headerlink" title="类型别名type"></a>类型别名type</h3><h4 id="type关键字"><a href="#type关键字" class="headerlink" title="type关键字"></a><strong>type关键字</strong></h4><p>说明：字面意思，用来给一个类型起个新名字。生成一个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str1 = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> str2 = <span class="function">()=&gt;</span><span class="built_in">string</span>;   <span class="comment">//此为函数类型形状，注意跟下面区分</span></span><br><span class="line"><span class="keyword">type</span> str = str1 | str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s:str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s1:str = <span class="function">() =&gt;</span><span class="string">&quot;heihei&quot;</span>;   <span class="comment">//为箭头函数</span></span><br></pre></td></tr></table></figure><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起别名不会新建一个类型 - 它创建了一个新 <em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p><p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br></pre></td></tr></table></figure><p>我们也可以使用类型别名来在属性里引用自己：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; <span class="attr">next</span>: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class="line"><span class="keyword">var</span> s = people.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure><p>然而，类型别名不能出现在声明右侧的任何地方。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="type-与-interface-的区别"><a href="#type-与-interface-的区别" class="headerlink" title="type 与 interface 的区别"></a>type 与 interface 的区别</h4><p>接口VS类型别名<br>相同点：<br>都可以描述一个对象或者函数<br>都允许拓展（extends和交叉类型）<br>不同点：<br>type 可以声明基本类型别名，联合类型，元组等类型<br>type 语句中还可以使用 typeof 获取实例的 类型进行赋值<br>interface 能够声明合并</p><h5 id="相似的"><a href="#相似的" class="headerlink" title="相似的"></a>相似的</h5><p><code>type</code> 用于定义数据的类型别名。<code>interface</code> 用于定义数据的类型别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> user:User=&#123;</span><br><span class="line">    <span class="attr">name1</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> user:User=&#123;</span><br><span class="line">    <span class="attr">name1</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不相似的"><a href="#不相似的" class="headerlink" title="不相似的"></a>不相似的</h5><p><code>type</code> 与 <code>interface</code> 都可以实现继承，但是他们的表现形式不同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface extends interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type 与 type 交叉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface extends type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type 与 interface 交叉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>type</code> 作为类型的别名，因此可以轻易的实现声明基本类型别名，联合类型，元组等类型，而 interface 则不行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型,</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    <span class="attr">b</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"><span class="keyword">let</span> c:Pet=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure><p>interface 能够声明合并，而 type 不行（会报重复声明错误）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a:User=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;q&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&#x27;men&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> guest = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> guest = &#123;</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type 报错</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6和TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常识</title>
      <link href="/2020/09/25/%E5%B8%B8%E8%AF%86/"/>
      <url>/2020/09/25/%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>浏览器内核：浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</p><ul><li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。</li><li><code>Gecko</code>内核：<code>Netscape6</code>及以 上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li><li><code>Presto</code>内核：<code>Opera7</code>及以上。 [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li><li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。 [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li></ul><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><p><a href="https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA">https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA</a></p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程和线程的概念可以这样理解：</p><blockquote><p>进程是一个工厂，工厂有它的独立资源–工厂之间相互独立–线程是工厂中的工人，多个工人协作完成任务–工厂内有一个或多个工人–工人之间共享空间</p></blockquote><p>工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。</p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KzcDnDRlicWl0V3fV9Qtzg8n4segZjiaiaCqr982pXRSEIGOq7ics1CRm4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /><p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存） 线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KDibJqU6bBoWCNcT6QS22cFxOygakR1519HdRzOp2iagK5ibfJQWm2e4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" /><p>浏览器是多进程的，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p><h4 id="浏览器包含的进程"><a href="#浏览器包含的进程" class="headerlink" title="浏览器包含的进程"></a>浏览器包含的进程</h4><ol><li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p></li><li><ul><li>负责浏览器的界面显示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其它进程</li><li>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>,绘制到用户界面上</li><li>网络资源的管理，下载</li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></li><li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p></li><li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等</p></li></ol><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><ul><li>避免单个<code>page crash</code>影响整个浏览器</li><li>避免第三方插件<code>crash</code>影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器; 当然，内存等资源消耗也会更大，像空间换时间一样。</p><h3 id="浏览器内核-渲染进程"><a href="#浏览器内核-渲染进程" class="headerlink" title="浏览器内核(渲染进程)"></a>浏览器内核(渲染进程)</h3><p>对于普通的前端操作来说，最重要的<strong>渲染进程</strong>：页面的渲染，<code>js</code>的执行，事件的循环等都在这个进程内执行</p><p><strong>浏览器是多进程的，浏览器的渲染进程是多线程的；</strong></p><p>渲染进程如下：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KO3Pmiabeq4UPvMSR2fM00YkQAicSmHoXtezy928XErvNLpFlBwcVXic0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a><code>GUI</code>渲染线程</h4><ul><li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>,构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li><li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li><li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li></ul><h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a><code>JS</code>引擎线程</h4><ul><li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li><li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li><li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li><li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li><li>javascript是单线程的， 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点。所以javascript是单线程的。</li></ul><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul><li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li><li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li><li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li></ul><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul><li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li><li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li></ul><h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步<code>http</code>请求线程</h4><ul><li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新型一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li></ul><h3 id="Browser主进程和浏览器内核（渲染进程）的通信过程"><a href="#Browser主进程和浏览器内核（渲染进程）的通信过程" class="headerlink" title="Browser主进程和浏览器内核（渲染进程）的通信过程"></a>Browser主进程和浏览器内核（渲染进程）的通信过程</h3><p>打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开<code>Tab</code>页的渲染进程）</p><ul><li><code>Browser</code>主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code>渲染进程</li><li><code>Render</code>渲染进程的<code>Renderer</code>接口收到消息，简单解释后，交给渲染线程<code>GUI</code>，然后开始渲染</li><li><code>GUI</code>渲染线程接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code>主进程获取资源和需要<code>GPU</code>进程来帮助渲染</li><li>当然可能会有<code>JS</code>线程操作<code>DOM</code>（这可能会造成回流并重绘）</li><li>最后<code>Render</code>渲染进程将结果传递给<code>Browser</code>主进程</li><li><code>Browser</code>主进程接收到结果并将结果绘制出来</li></ul><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KHgay7bNfvibNicDvJGvOhbupYVh19Vgbbm37TxbgqxYgMtEJwdIibolsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h3><h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><ol><li>普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）</li><li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li></ol><p>可以简单理解下：<code>GPU</code>中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p><strong>如何变成复合图层（硬件加速）</strong></p><p>将元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li><p>最常用的方式：<code>translate3d</code>,<code>translatez</code></p></li><li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p></li><li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p></li><li><p>```<br><video><iframe><canvas><webgl>等元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其它，譬如以前的`flash`插件</span><br><span class="line"></span><br><span class="line">**复合图层的作用**</span><br><span class="line"></span><br><span class="line">一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</span><br><span class="line"></span><br><span class="line">#### JS的多线程WebWorker</span><br><span class="line"></span><br><span class="line">`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？</span><br><span class="line"></span><br><span class="line">所以，后来`HTML5`中支持了`WebWorker`。</span><br><span class="line"></span><br><span class="line">这样理解下：</span><br><span class="line"></span><br><span class="line">创建`Worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`）`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据）</span><br><span class="line"></span><br><span class="line">所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可。</span><br><span class="line"></span><br><span class="line">而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题。</span><br><span class="line"></span><br><span class="line">**`WebWorker`与`SharedWorker`**</span><br><span class="line"></span><br><span class="line">既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）</span><br><span class="line"></span><br><span class="line">`WebWorker`只属于某个页面，不会和其他页面的`Render`进程（浏览器内核进程）共享 所以`Chrome`在`Render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。</span><br><span class="line"></span><br><span class="line">`SharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`Render`进程，可以为多个`Render`进程共享使用 所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次。</span><br><span class="line"></span><br><span class="line">看到这里，应该就很容易明白了，本质上就是进程和线程的区别。`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程</span><br><span class="line"></span><br><span class="line">#### microtask与macrotask</span><br><span class="line"></span><br><span class="line">MacroTask（宏任务）</span><br><span class="line"></span><br><span class="line">- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见`MDN`）、`I/O`、`UI Rendering`。</span><br><span class="line"></span><br><span class="line">MicroTask（微任务）</span><br><span class="line"></span><br><span class="line">- `Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3K0kUDZVKgibMd3rBeeBeGfGlRicQfffWIia7lWPAWXIEtkzLQB5vpl9iaFw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">#### 从`Event Loop`谈`JS`的运行机制</span><br><span class="line"></span><br><span class="line">`Event Loop`即事件循环，是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。</span><br><span class="line"></span><br><span class="line">javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</span><br><span class="line"></span><br><span class="line">单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</span><br><span class="line"></span><br><span class="line">- `JS`分为同步任务和异步任务</span><br><span class="line">- 同步任务都在主线程上执行，形成一个执行栈</span><br><span class="line">- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</span><br><span class="line">- 一旦执行栈中的所有同步任务执行完毕（此时`JS`引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3K4aULQ2mmxexCFrU6kicG7ly2995IniaAm21CVBnBSLA9qmntNE27kPhQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KxYCZN7mibAPNZlibpHtZdMC19NoicE9OViakek1iafSviciaYQD6rI3GiaicVOg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## JS 代码是怎样运行起来的</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/UGf-VgcZ0jAD5SXIlHO9-Q</span><br><span class="line"></span><br><span class="line">### V8 引擎</span><br><span class="line"></span><br><span class="line">在介绍 V8 引擎的概念之前，我们先来回顾一下编程语言。**编程语言可以分为机器语言、汇编语言、高级语言。**</span><br><span class="line"></span><br><span class="line">- 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。</span><br><span class="line"></span><br><span class="line">- 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。</span><br><span class="line"></span><br><span class="line">- 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。</span><br><span class="line"></span><br><span class="line">  ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0sXFMfsjvzic9vOarl9rHq8jWYtJBw47F3yrUqcasQcqjMENoSDYpCJw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">高级语言一定要转化为机器语言才能被计算机执行，而且越高级的语言转化的时间越久。**高级语言又可以分为解释型语言、编译型语言。**</span><br><span class="line"></span><br><span class="line">- 编译型语言：需要编译器进行一次编译，被编译过的文件可以多次执行。如 C++、C 语言。</span><br><span class="line"></span><br><span class="line">- 解释型语言：不需要事先编译，通过解释器一边解释一边执行。启动快，但执行慢。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们知道 JavaScript 是一门高级语言，并且是动态类型语言，我们在定义一个变量时不需要关心它的类型，并且可以随意的修改变量的类型。而在像 C++这样的静态类型语言中，我们必须提前声明变量的类型并且赋予正确的值才行。也正是因为 JavaScript 没有像 C++那样可以事先提供足够的信息供编译器编译出更加低级的机器代码，它只能在运行阶段收集类型信息，然后根据这些信息进行编译再执行，所以 JavaScript 也是解释型语言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这也就意味着 JavaScript 要想被计算机执行，需要一个能够快速解析并且执行 JavaScript 脚本的程序，这个程序就是我们平时所说的 JavaScript 引擎。这里我们给出 V8 引擎的概念:**V8 是 Google 基于 C++ 编写的开源高性能 Javascript 与 WebAssembly 引擎。用于 Google Chrome（Google 的开源浏览器） 以及 Node.js 等。**</span><br><span class="line"></span><br><span class="line">### CPU 是如何执行机器指令的？</span><br><span class="line"></span><br><span class="line">将高级语言转化为机器语言之后，CPU 又是怎样执行的呢？我们以一段 C 代码为例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    int x = 1;</span><br><span class="line"></span><br><span class="line">    int y = 2;</span><br><span class="line"></span><br><span class="line">    int z = x + y;</span><br><span class="line"></span><br><span class="line">    return z;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0x7A7PvzwweIap7bYulfTot4icLibCwQ2ICnwB5icTyeia1Eibic85oWjndfw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>CPU 执行机器指令的流程</strong></p><ul><li><p>首先程序在执行之前会被装进内存。</p></li><li><p>系统会将二进制代码中的第一条指令的地址写入到 PC 寄存器中。</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0xQbLlrWaKxm7ttRQP39rbKjxJUILrbJA4g6yA292QxMbrko5viaKZ3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li><p>CPU 根据 PC 寄存器中的地址，从内存中取出指令。</p></li><li><p>将下一条指令的地址更新到 PC 寄存器中。</p></li><li><p>分析当前取出指令，并识别出不同的类型的指令，以及各种获取操作数的方法。</p></li><li><p>加载指令：从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。</p></li><li><p>存储指令：将寄存器中的内容复制到内存某个位置，并覆盖掉内存中的这个位置上原来的内容。</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0EgzgickcldFO9KFr7D2qaYeWBfyjEwbVYKf24Splib3EcFOa4y4tv0Lw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>上图中 movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中的地址，这条指令的作用是将寄存器中的值拷贝到内存中。</p><ul><li>更新指令：复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。</li></ul><p>…</p><ul><li>执行指令完毕，进入下一个 CPU 时钟周期。</li></ul><h3 id="V8-引擎的编译流水线"><a href="#V8-引擎的编译流水线" class="headerlink" title="V8 引擎的编译流水线"></a>V8 引擎的编译流水线</h3><p>接下来我们先从宏观的角度来看一下 V8 是怎么执行 JavaScript 代码的，然后再对每一步进行分析。</p><ul><li><p>初始化基础环境；</p></li><li><p>解析源码生成 AST 和作用域；</p></li><li><p>依据 AST 和作用域生成字节码；</p></li><li><p>解释执行字节码；监听热点代码；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0FEIGZwRe79nNsAnx7YNAupDEj7NdT0rWGmhk9CEtIfMMO5nmcNJDiag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li></ul><h1 id="渲染-优化"><a href="#渲染-优化" class="headerlink" title="渲染/优化"></a>渲染/优化</h1><h2 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h2><p><strong>重绘（repaint或redraw）</strong>：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p>触发重绘的条件：改变元素外观属性。如：color，background-color等。</p><p><strong>重排（重构/回流/reflow）</strong>：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(<strong>reflow</strong>)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p><strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p><h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p><strong>基础版本</strong></p><ul><li><p>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</p></li><li><p>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</p></li><li><p>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）</p><ul><li><p>解析<code>html</code>建立<code>dom</code>树</p></li><li><p>解析<code>css</code>构建<code>render</code>树（将<code>css</code>代码解析成树形的数据结构，然后结合<code>dom</code>合并成<code>render</code>树）</p></li><li><p>布局<code>render</code>树（<code>Layout/reflow</code>）,负责各元素尺寸，位置的计算</p></li><li><p>绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>）,显示在屏幕上</p><p>渲染完毕后就是<code>load</code>事件了，之后就是自己的<code>JS</code>逻辑处理</p><ul><li>composite：普通图层和复合图层<ul><li>普通文档流内可以理解为一个复合图层</li><li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li></ul></li></ul></li></ul></li></ul><p><strong>详细版</strong></p><ol><li><p>在浏览器地址栏输入URL</p></li><li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p><ol><li><p>如果资源未缓存，发起新请求</p></li><li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p></li><li><p>检验新鲜通常有两个HTTP头进行控制</p><p>Expires和Cache-Control：</p><ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p></li><li><p>浏览器获取主机ip地址，过程如下：</p><ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p></li><li><p>打开一个socket与目标IP地址，端口建立TCP链接</p><p>三次握手如下：</p><ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li><p>TCP链接建立后<strong>发送HTTP请求</strong></p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p></li><li><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p><ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p></li><li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p></li><li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p></li><li><p>构建DOM树：</p><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p></li><li><p>构建CSSOM树：</p><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树</a>:</p><ol><li><p>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：</p><p>1）<code>script</code>,<code>meta</code>这样本身不可见的标签。</p><p>2)被css隐藏的节点，如<code>display: none</code></p></li><li><p>对每一个可见节点，找到恰当的CSSOM规则并应用</p></li><li><p>发布可视节点的内容和计算样式</p></li></ol></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p><strong>网络</strong></p><ul><li>域名：利用多个域名来存储网站资源，节约主域名的连接数，优化页面响应速度 </li><li>减少<code>HTTP</code>请求次数：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li><li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li><li>懒加载也是一个经常被提及的技术，视窗外的内容是不会被用户立即看到的，这时加载过多的内容反而拖慢了网站整体的渲染，我们就可以用懒加载推迟这部分内容的加载来达到加速可访问和可交互性的目的，等用户即将到达视窗内的时候再开始加载这部分内容，通常懒加载会与loading和骨架屏等技术搭配使用。</li></ul></li><li><p><strong>缓存</strong></p><ul><li>CDN缓存</li><li>强缓存和协商缓存</li></ul></li><li><p><strong>代码优化</strong></p><ul><li>对组件使用<code>Gzip</code>压缩</li><li><code>Tree-shaking</code>指的是消除没被引用的模块代码，减少代码体积大小，以提高页面的性能</li></ul></li><li><p><strong>html</strong></p><ul><li><p>减少<code>DOM</code>元素数量</p></li><li><p>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）</p><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li><li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul></li><li><p>页面头部的<code>&lt;style&gt;&lt;/style&gt;</code> <code>&lt;script&gt;&lt;/script&gt;</code> 会阻塞页面；（因为 <code>Renderer</code>进程中 <code>JS</code>线程和渲染线程是互斥的）</p></li><li><p>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</p></li><li><p>页面中空的 <code>href</code> 和 <code>src</code> 会阻塞页面其他资源的加载 (阻塞下载进程)</p></li></ul></li><li><p><strong>css</strong></p><ul><li>将样式表放到页面顶部</li><li>不使用<code>CSS</code>表达式</li><li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li><li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li><li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li></ul></li><li><p><strong>Javascript</strong></p><ul><li>将脚本放到页面底部</li><li>将<code>javascript</code>和<code>css</code>从外部引入</li><li>压缩<code>javascript</code>和<code>css</code></li><li>删除不需要的脚本</li><li>减少<code>DOM</code>访问</li></ul></li><li><p><strong>图片</strong></p><ul><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化<code>css</code>精灵</li><li>不要在<code>HTML</code>中拉伸图片</li><li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li><li>对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul><li>小图标优势在于<ul><li>减少<code>HTTP</code>请求</li><li>避免文件跨域</li><li>修改及时生效</li></ul></li></ul></li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li></ul></li></ul><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><p><a href="https://mp.weixin.qq.com/s/-MbBKo6l-SxSmJmKvaWTGQ">https://mp.weixin.qq.com/s/-MbBKo6l-SxSmJmKvaWTGQ</a></p><p>白屏大概可能的原因有两种：</p><ol><li>js 执行过程中的错误</li><li>资源错误</li></ol><p><strong>从而造成根节点下所有 DOM 被卸载</strong></p><h2 id="调试工具Network及优化"><a href="#调试工具Network及优化" class="headerlink" title="调试工具Network及优化"></a>调试工具Network及优化</h2><p><a href="https://mp.weixin.qq.com/s/CfL-uVNcKPasfcBcrifROA">https://mp.weixin.qq.com/s/CfL-uVNcKPasfcBcrifROA</a></p><p>Network面板记录了与服务器交互的具体细节。</p><p>在这里我们可以看到发起的请求数量，传输体积以及解压缩后的体积，同时还可以知道哪些资源是命中了强缓存，哪些资源命中的协商缓存。</p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeo09qdFM2poL7rdmxdriaHl6F5zQZXyNeze3lzic6Nia5Su2awfdjpREDw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><p>查看某一个请求的瀑布流可以让我们清晰的看到一个资源从服务器到达我们的电脑所花的时间。如上图，排队用了1.65ms，DNS查询用了21.47ms，initial connection(进行TCP握手的时间)用了56.25ms，SSL握手的时间用了37.87ms，然后又用了100多ms第一个字节到达我们的电脑(TTFB - 上面的查询/建立)，接收整个文档花了17ms。这时候我们基于上面的信息就可以粗略的得到，如果能在请求资源之前如果已经得到DNS地址(预查询)可以省去21ms，已经进行过握手可以省去100ms(预连接)，如果干脆请求也不请求可以省去200ms(缓存)继而针对这些点做对应的策略。Network面板可以让我们初步评估网站性能，对网站整体的体积，网络的影响带来一个整体的认知，同时提供一些辅助功能，如禁用缓存，block某些资源。</p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>与服务器交互首先要进行DNS查询，得到服务器的IP地址，浏览器会首先查询自己的缓存，之后会查询本地HOSTS，如果仍然没找到会发起向DNS服务器查询的请求。</p><h3 id="建立HTTP-TCP-连接"><a href="#建立HTTP-TCP-连接" class="headerlink" title="建立HTTP(TCP)连接"></a>建立HTTP(TCP)连接</h3><p>得到服务器IP之后，首先进行三次握手，之后会进行SSL握手(HTTPS)，SSL握手时会向服务器端确认HTTP的版本</p><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了<code>Connection: Keep-Alive</code>，<code>keep-alive</code>的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生<strong>队头阻塞</strong>的问题。HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。connection keep-alive</p><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p>HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以<strong>并行传输</strong>而不被阻塞，这样就解决了HTTP1.1时复用会产生的<strong>队头阻塞</strong>的问题，同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。Nginx开启HTTP2的方式特别容易，只需要加一句<code>http2</code>既可开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl http2; # 加一句 http2.</span><br><span class="line"> server_name domain.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存通过复用之前的获取过的资源，可以显著提高网站和应用程序的性能，合理的缓存不仅可以节省巨大的流量也会让用户二次进入时身心愉悦，如果一个资源完全走了本地缓存，那么就可以节省下整个与服务器交互的时间，如果整个网站的内容都被缓存在本地，那即使离线也可以继续访问(很酷，但还没有完全很酷)。HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。整体流程如下：</p><img src="https://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeL4DnraNibZ7SicOaeSyKiaH36VRU8z4mvYhxO6ELYSUu5e4ibsANYvohLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" /><p><strong>强缓存</strong></p><p>强缓存根据请求头的<code>Expires</code>和<code>Cache-Control</code>判断是否命中强缓存，命中强缓存的资源直接从本地加载，不会发起任何网络请求。<code>Cache-Control</code>的值有很多:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class="line">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure><p>常用的有<code>max-age</code>，<code>no-cache</code>和<code>no-store</code>。<code>max-age</code> 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现<code>age</code>标明这个资源当前的新鲜程度。<code>no-cache</code> 会让浏览器缓存这个文件到本地但是不用，Network中<code>disable-cache</code>勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。<code>no-store</code> 会完全放弃缓存这个文件。服务器响应时的<code>Cache-Control</code>略有不同，其中有两个需要注意下:</p><ol><li>public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。</li><li>private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。</li></ol><p><code>Expires</code>是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在<code>max-age</code>的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。另外，如果你的服务器的返回内容中不存在<code>Expires</code>，<code>Cache-Control: max-age</code>，或 <code>Cache-Control:s-maxage</code>但是存在<code>Last-Modified</code>时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的<code>Date_value - Last-Modified_value</code>值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有<code>no-cache</code>或<code>no-store</code>在响应头中。</p><p><strong>协商缓存</strong></p><p>协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。服务器响应中会携带<code>ETag</code>和<code>Last-Modified</code>，<code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成<code>Last-Modified</code>被修改，所以在HTTP / 1.1 出现了<code>ETag</code>。<code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的<code>If-None-Match</code>的header会将上次返回的<code>ETag</code>发送给服务器，询问该资源的<code>ETag</code>是否有更新，有变动就会发送新的资源回来<code>ETag</code>(<code>If-None-Match</code>)的优先级高于<code>Last-Modified</code>(<code>If-Modified-Since</code>)，优先使用<code>ETag</code>进行确认。协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。</p><p><strong>CDN</strong></p><p>CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从<strong>最近的CDN服务器拿取资源而不是从源站拿取</strong>，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性。</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a><strong>压缩</strong></h4><p>合理的压缩资源可以有效减少传输体积，减少传输体积的结果就是用户更快的拿到资源开始解析。压缩在各个阶段都会出现，比如上面提到的HTTP2的首部压缩，进行到这一步的压缩是指对整个资源文件进行的压缩。浏览器在发起请求时会在headers中携带<code>accept-encoding: gzip, deflate, br</code>，告知服务器客户端可以接受的压缩算法，之后响应资源会在响应头中携带<code>content-encoding: gzip</code>告知本文件的压缩算法。</p><p><strong>GZIP压缩</strong></p><p>GZIP是非常常用的压缩算法，现代客户端都会支持，你可以在上传文件时就上传一份压缩后的文件，也可以让Nginx动态压缩。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul><li>未使用 var 声明的全局变量</li><li>闭包函数(Closures)</li><li>循环引用(两个对象相互引用)</li><li>控制台日志(console.log)</li><li>移除存在绑定事件的DOM元素(IE)</li><li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li></ul><h1 id="网络-安全"><a href="#网络-安全" class="headerlink" title="网络 安全"></a>网络 安全</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li><p>应用层包括:</p><p>1、超文本传输协议（HTTP）:万维网的基本协议；<br>2、文件传输（TFTP简单文件传输协议）；<br>3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；<br>4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；<br>5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。</p></li></ul><ul><li><p>计算机上的应用程序如何找到另一台计算机上的相同的应用程序？</p><p>IP地址：唯一确定网络的一台电脑</p><p>端口：<strong>确定电脑上的具体哪个应用程序</strong></p><p>域名：由于IP地址不方便记忆，所以给IP地址起了个别名—域名，也就是通过域名可以找到对应的IP地址</p><p>DNS：domain name system 域名系统，保存了域名和IP地址的对应关系</p></li></ul><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p><a href="https://zhuanlan.zhihu.com/p/24860273">https://zhuanlan.zhihu.com/p/24860273</a></p><p>TCP协议和UDP协议与TCP/IP协议的联系:TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。</p><p>TCP/IP协议集包括</p><ol><li>应用层（<strong>应用进程间通信和交互的规则</strong>：如域名DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议）</li><li>传输层（<strong>两台主机中进程之间的通信</strong>：<strong>传输控制协议TCP</strong>，<strong>用户数据报协议 UDP</strong>）</li><li>网络层（<strong>不同主机提供通信服务</strong>）</li></ol><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来</p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。</p><p>第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我</p><p>第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。</p><p><strong>3次握手的特点</strong><br>没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。</p><h5 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h5><p>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；</p><p>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；</p><p>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；</p><p>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。</p><p>由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。</p><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p>1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。</p><p>2、SYN 同步序列号，TCP建立连接时将这个位置1。</p><p>3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h4><p><strong>User Data Protocol，用户数据报协议</strong></p><p>1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p><p>2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。</p><p>3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p><p>4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。</p><p>5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p><p>6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。</p><p>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p><p><strong>ping命令</strong>是用来探测主机到主机之间是否可通信，如果不能<strong>ping</strong>到某台主机，表明不能和这台主机建立连接。<strong>ping命令</strong>是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。</p><p>ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><img src="https://image-static.segmentfault.com/563/628/563628850-5fa50187ba70e_fix732" alt="img"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP三点注意事项：</p><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议，即：服务器不需要知道客户端是谁,只认请求（一次请求request,一次相应response）</li></ul><p><img src="https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2019022420515851.png" alt="img"></p><h4 id="HTTP-请求响应报文"><a href="#HTTP-请求响应报文" class="headerlink" title="HTTP 请求响应报文"></a>HTTP 请求响应报文</h4><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p><img src="https://upload-images.jianshu.io/upload_images/12603307-27e3bf8fde18f443.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" /><p>响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)</p><img src="https://upload-images.jianshu.io/upload_images/12603307-cf75b41f632499a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp" alt="img" style="zoom: 67%;" /><h4 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h4><ul><li><p>1XX：信息状态码</p><ul><li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li></ul></li><li><p>2XX：成功状态码</p><table><thead><tr><th>200</th><th>OK</th><th>请求成功。一般用于GET与POST请求</th></tr></thead><tbody><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr></tbody></table></li><li><p>3XX：重定向JSON.parse(</p><table><thead><tr><th>300</th><th>Multiple Choices</th><th>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table></li><li><p>4XX：客户端错误</p><table><thead><tr><th>400</th><th>Bad Request</th><th>客户端请求的语法错误，服务器无法理解</th></tr></thead><tbody><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr></tbody></table></li><li><p>5XX:服务器错误</p><table><thead><tr><th>500</th><th>Internal Server Error</th><th>服务器内部错误，无法完成请求</th></tr></thead><tbody><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table></li></ul><h4 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h4><p><img src="https://img2018.cnblogs.com/blog/1301998/201906/1301998-20190621104932351-2057147169.png" alt="img"></p><h5 id="HTTP消息头"><a href="#HTTP消息头" class="headerlink" title="HTTP消息头"></a>HTTP消息头</h5><p><code>HTTP消息头</code>是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。</p><p>Query Params：常用是<strong>get</strong>方式请求，query是指<strong>请求行</strong>中请求的参数，一般是指URL中？后面的参数</p><p>Body Params：常用是<strong>post</strong>方式请求，body是指<strong>请求体</strong>中的数据</p><h5 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h5><p><strong>HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文</strong></p><p><strong>HTTP最常见的请求头如下：</strong></p><table><thead><tr><th>协议头</th><th>说明</th><th>示例</th><th>状态</th></tr></thead><tbody><tr><td>Accept</td><td>可接受的响应内容类型（<code>Content-Types</code>）。</td><td><code>Accept: text/plain</code></td><td>固定</td></tr><tr><td>Accept-Charset</td><td>可接受的字符集</td><td><code>Accept-Charset: utf-8</code></td><td>固定</td></tr><tr><td>Accept-Encoding</td><td>可接受的响应内容的编码方式。</td><td><code>Accept-Encoding: gzip, deflate</code></td><td>固定</td></tr><tr><td>Accept-Language</td><td>可接受的响应内容语言列表。</td><td><code>Accept-Language: en-US</code></td><td>固定</td></tr><tr><td>Accept-Datetime</td><td>可接受的按照时间来表示的响应内容版本</td><td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td><td>临时</td></tr><tr><td>Authorization</td><td>用于表示HTTP协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td><td>固定</td></tr><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中的，是否使用缓存机制。</td><td><code>Cache-Control: no-cache</code>              max-age：缓存无法返回缓存时间长于max-age规定秒的文档</td><td>固定</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td><code>Connection: keep-alive``Connection: Upgrade</code></td><td>固定</td></tr><tr><td>Cookie</td><td>由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td><td><code>Cookie: $Version=1; Skin=new;</code></td><td>固定：标准</td></tr><tr><td>Content-Length</td><td>以8进制表示的请求体的长度</td><td><code>Content-Length: 348</code></td><td>固定</td></tr><tr><td>Content-MD5</td><td>请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td><td>Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td><td>废弃</td></tr><tr><td>Content-Type</td><td>请求体的MIME类型 （用于POST和PUT请求中）</td><td>Content-Type: application/x-www-form-urlencoded</td><td>固定</td></tr><tr><td>Date</td><td>发送该消息的日期和时间（以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td><td>Date: Dec, 26 Dec 2015 17:30:00 GMT</td><td>固定</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td><code>Expect: 100-continue</code></td><td>固定</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td><code>From: user@itbilu.com</code></td><td>固定</td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td><td><code>Host: www.itbilu.com:80``Host: www.itbilu.com</code></td><td>固定</td></tr><tr><td>If-Match</td><td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td><td>If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Modified-Since</td><td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td><strong>固定</strong></td></tr><tr><td><strong>If-None-Match</strong></td><td>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</td><td>If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Range</td><td>如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td><td>If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Unmodified-Since</td><td>仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td><td>If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td>固定</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数。</td><td><code>Max-Forwards: 10</code></td><td>固定</td></tr><tr><td>Origin</td><td>发起一个针对<a href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td><td><code>Origin: http://www.itbilu.com</code></td><td>固定: 标准</td></tr><tr><td>Pragma</td><td>与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td><td><code>Pragma: no-cache</code></td><td>固定</td></tr><tr><td>Proxy-Authorization</td><td>用于向代理进行认证的认证信息。</td><td>Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td><td>固定</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以0开始。</td><td><code>Range: bytes=500-999</code></td><td>固定</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td><td>Referer: <a href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td><td>固定</td></tr><tr><td>TE</td><td>浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td><td><code>TE: trailers,deflate</code></td><td>固定</td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td><code>User-Agent: Mozilla/……</code></td><td>固定</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议。</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td>固定</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的。</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td><td>固定</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容体中可能存在错误。</td><td>Warning: 199 Miscellaneous warning</td><td>固定</td></tr></tbody></table><h5 id="Response-Header"><a href="#Response-Header" class="headerlink" title="Response Header"></a>Response Header</h5><p><strong>响应报文</strong>：<strong>当收到get或post等方法发来的请求后，服务器就要对报文进行响应。</strong></p><table><thead><tr><th align="left">响应头</th><th align="left">说明</th><th align="left">示例</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以<code>跨域源资源共享</code></td><td align="left"><code>Access-Control-Allow-Origin: *</code></td><td align="left">临时</td></tr><tr><td align="left">Accept-Patch</td><td align="left">指定服务器所支持的文档补丁格式</td><td align="left">Accept-Patch: text/example;charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">服务器所支持的内容范围</td><td align="left"><code>Accept-Ranges: bytes</code></td><td align="left">固定</td></tr><tr><td align="left">Age</td><td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td><td align="left"><code>Age: 12</code></td><td align="left">固定</td></tr><tr><td align="left">Allow</td><td align="left">对于特定资源的有效动作;</td><td align="left"><code>Allow: GET, HEAD</code></td><td align="left">固定</td></tr><tr><td align="left">Cache-Control</td><td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td><td align="left"><code>Cache-Control: max-age=3600</code></td><td align="left">固定</td></tr><tr><td align="left">Connection</td><td align="left">针对该连接所预期的选项</td><td align="left"><code>Connection: close</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Disposition</td><td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td><td align="left">Content-Disposition: attachment; filename=”fname.ext”</td><td align="left">固定</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应资源所使用的编码类型。</td><td align="left"><code>Content-Encoding: gzip</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Language</td><td align="left">响就内容所使用的语言</td><td align="left"><code>Content-Language: zh-cn</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left"><code>Content-Length: 348</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Location</td><td align="left">所返回的数据的一个候选位置</td><td align="left"><code>Content-Location: /index.htm</code></td><td align="left">固定</td></tr><tr><td align="left">Content-MD5</td><td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td><td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td><td align="left">已淘汰</td></tr><tr><td align="left">Content-Range</td><td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td><td align="left">Content-Range: bytes 21010-47021/47022</td><td align="left">固定</td></tr><tr><td align="left">Content-Type</td><td align="left">当前内容的<code>MIME</code>类型</td><td align="left">Content-Type: text/html; charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Date</td><td align="left">此条消息被发送时的日期和时间(以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td><td align="left">固定</td></tr><tr><td align="left">ETag</td><td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td><td align="left">固定</td></tr><tr><td align="left">Expires</td><td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td><td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td><td align="left">固定: 标准</td></tr><tr><td align="left">Last-Modified</td><td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Link</td><td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td><td align="left"><code>Link: </code>; rel=”alternate”</td><td align="left">固定</td></tr><tr><td align="left">Location</td><td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td><td align="left">Location: <a href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td><td align="left">固定</td></tr><tr><td align="left">P3P</td><td align="left">P3P策略相关设置</td><td align="left">P3P: CP=”This is not a P3P policy!</td><td align="left">固定</td></tr><tr><td align="left">Pragma</td><td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td><td align="left"><code>Pragma: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">要求在访问代理时提供身份认证信息。</td><td align="left"><code>Proxy-Authenticate: Basic</code></td><td align="left">固定</td></tr><tr><td align="left">Public-Key-Pins</td><td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td><td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td><td align="left">固定</td></tr><tr><td align="left">Refresh</td><td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td><td align="left">Refresh: 5; url=<a href="http://itbilu.com/">http://itbilu.com</a></td><td align="left"></td></tr><tr><td align="left">Retry-After</td><td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td><td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Server</td><td align="left">服务器的名称</td><td align="left"><code>Server: nginx/1.6.3</code></td><td align="left">固定</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置<code>HTTP cookie</code></td><td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td><td align="left">固定标准</td></tr><tr><td align="left">Status</td><td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td><td align="left"><code>Status: 200 OK</code></td><td align="left"></td></tr><tr><td align="left">Trailer</td><td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td><td align="left"><code>Trailer: Max-Forwards</code></td><td align="left">固定</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td><td align="left">Transfer-Encoding: chunked</td><td align="left">固定</td></tr><tr><td align="left">Upgrade</td><td align="left">要求客户端升级到另一个高版本协议。</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td align="left">固定</td></tr><tr><td align="left">Vary</td><td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td><td align="left"><code>Vary: *</code></td><td align="left">固定</td></tr><tr><td align="left">Via</td><td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td><td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td><td align="left">固定</td></tr><tr><td align="left">Warning</td><td align="left">一般性警告，告知在实体内容体中可能存在错误。</td><td align="left">Warning: 199 Miscellaneous warning</td><td align="left">固定</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表示在请求获取这个实体时应当使用的认证模式。</td><td align="left"><code>WWW-Authenticate: Basic</code></td><td align="left">固定</td></tr></tbody></table><p><strong>在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，是解决跨域的一种方法。</strong></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>在HTTP1.1规范中，新增了一个HTTP头信息：ETag。</p><p>浏览器<strong>第一次</strong>请求一个资源的时候，服务端给予返回，并且返回了<strong>ETag</strong>: “50b1c1d4f775c61:df3” 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将<strong>If-None-Match</strong>: W/“50b1c1d4f775c61:df3” 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。</p><p>通过Etag来利用浏览器的缓存，降低我们服务器的带宽压力。</p><p><strong>第一次请求，服务器返回Etag。强缓存，expires和Cache-Control，判断是否过期，过期，请求服务器，服务端拿到该ETAG，对比资源是否发生变化，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</strong></p><p><a href="https://www.jianshu.com/p/cb72dfb0f7b3">https://www.jianshu.com/p/cb72dfb0f7b3</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8</a></p><p><a href="https://louiszhai.github.io/2017/04/07/http-cache/">https://louiszhai.github.io/2017/04/07/http-cache/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/7567844-3fa31eccdfc2f4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp" alt="img"></p><h3 id="缓存的流程"><a href="#缓存的流程" class="headerlink" title="缓存的流程"></a>缓存的流程</h3><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p><ul><li>先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li><li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li><li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li><li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li><li>当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul><p><strong>本地缓存阶段(也称强缓存)</strong></p><p>先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</p><ul><li><code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</li><li><code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</li></ul><p><strong>协商缓存阶段(也称弱缓存)</strong></p><p>如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</p><ul><li><code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li><li><code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li><li><code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li><li><code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li></ul><h3 id="缓存有关的HTTP消息报头"><a href="#缓存有关的HTTP消息报头" class="headerlink" title="缓存有关的HTTP消息报头"></a>缓存有关的HTTP消息报头</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><ul><li><strong>max-age</strong>（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</li><li><strong>s-maxage</strong>（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说<strong>max-age用于普通缓存，而s-maxage用于代理缓存</strong>。如果存在s-maxage，则会覆盖掉max-age和Expires header。</li><li><strong>no-cache</strong> 指定不缓存响应，<strong>表明资源不进行缓存</strong>，但是设置了 no-cache 之后并<strong>不代表浏览器不缓存</strong>，而是在<strong>获取缓存前要向服务器确认资源是否被更改</strong>。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。（no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期，即走协商缓存的路线）</li><li><strong>no-store</strong> 绝对禁止缓存，如果用了这个命令就是<strong>不会进行缓存</strong>，<strong>每次请求资源都要从服务器重新获取</strong>。（no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。）</li></ul><h4 id="Cache-Control与Expires"><a href="#Cache-Control与Expires" class="headerlink" title="Cache-Control与Expires"></a>Cache-Control与Expires</h4><p>Cache-Control与 Expires的作用一致，都是<strong>指明当前资源的有效期</strong>，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过 Cache-Control的选择更多，设置更细致，如果同时设置的话，其<strong>优先级高于 Expires</strong>。</p><h4 id="public-与-private"><a href="#public-与-private" class="headerlink" title="public 与 private"></a>public 与 private</h4><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它<strong>既可以被浏览器缓存，也可以被代理服务器缓存</strong>；如果我们设置了 private，则该资源<strong>只能被浏览器缓存</strong>。private 为默认值。</p><h4 id="Last-Modified与ETag"><a href="#Last-Modified与ETag" class="headerlink" title="Last-Modified与ETag"></a>Last-Modified与ETag</h4><p><strong>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符</strong>，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h4 id="Last-Modified-ETag-与-Cache-Control-Expires"><a href="#Last-Modified-ETag-与-Cache-Control-Expires" class="headerlink" title="Last-Modified/ETag 与 Cache-Control/Expires"></a>Last-Modified/ETag 与 Cache-Control/Expires</h4><ul><li>配置 Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，<strong>还是会发送请求到服务器</strong>询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</li><li>Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，<strong>不会发送任何请求</strong>。两者一起使用时， Cache-Control/Expires的优先级要高，即<strong>当本地副本根据 Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间 Last-Modified或实体标识 Etag了。</strong></li><li>一般情况下，两者会配合一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag将能够很好利用304，从而减少响应开销。</li></ul><h4 id="有Last-Modified为什么还要有ETag？"><a href="#有Last-Modified为什么还要有ETag？" class="headerlink" title="有Last-Modified为什么还要有ETag？"></a>有Last-Modified为什么还要有ETag？</h4><p>HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul><h2 id="描述一下XSS和CRSF攻击？防御方法？"><a href="#描述一下XSS和CRSF攻击？防御方法？" class="headerlink" title="描述一下XSS和CRSF攻击？防御方法？"></a>描述一下XSS和CRSF攻击？防御方法？</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>即为（Cross Site Scripting）, 中文名为跨站脚本,XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>Cross Site Request Forgery，跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p><p>eg:David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0ng0DPsEaWQULZjqQ8Sw6KICkbQpPuo0GrtWLqYpw5aehchurtbqo0ibfvkls6mNWxHiaSOoMQIeHmoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li><li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li><li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li></ul><p>如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。</p><p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="XSS与CSRF有什么区别吗？"><a href="#XSS与CSRF有什么区别吗？" class="headerlink" title="XSS与CSRF有什么区别吗？"></a><strong>XSS与CSRF有什么区别吗？</strong></h3><ul><li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li></ul><h2 id="web安全及防护原理"><a href="#web安全及防护原理" class="headerlink" title="web安全及防护原理"></a>web安全及防护原理</h2><ul><li><code>sql</code>注入原理<ul><li>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li></ul></li><li>总的来说有以下几点<ul><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li><li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li><li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li></ul></li></ul><p><strong>XSS原理及防范</strong></p><ul><li><code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li></ul><p><strong>XSS防范方法</strong></p><ul><li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li></ul><p><strong>XSS与CSRF有什么区别吗？</strong></p><ul><li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li></ul><p><strong>CSRF的防御</strong></p><ul><li>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li><li>通过验证码的方法</li></ul><h2 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h2><p><a href="https://javascript.ruanyifeng.com/bom/cors.html">https://javascript.ruanyifeng.com/bom/cors.html</a></p><p> cross-origin resource sharing, 跨域资源共享.  它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。 </p><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p><p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p><h3 id="跨域请求分类"><a href="#跨域请求分类" class="headerlink" title="跨域请求分类"></a>跨域请求分类</h3><p>浏览器将跨域请求分为两大类: 简单请求和非简单请求.</p><p>同时满足以下条件的请求都为简单请求:</p><ul><li>a. 请求方式为下列之一: <ul><li>GET</li><li>POST</li><li>HEAD</li></ul></li><li>b. 请求头信息不超出以下字段: <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p><p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h4 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h4><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等）。如果需要包含 Cookie 信息，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p><p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p><p>下面是一段浏览器的 JavaScript 脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &#x27;http://api.alice.com/cors&#x27;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;PUT&#x27;, url, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）<code>Access-Control-Request-Method</code></strong></p><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p><p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p><h4 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h4><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS http://api.bob.com HTTP/1.1</span><br><span class="line">Status: 200</span><br><span class="line">Access-Control-Allow-Origin: https://notyourdomain.com</span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure><p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他 CORS 相关字段如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p><p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p><p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p><p>该字段与简单请求时的含义相同。</p><p><strong>（4）<code>Access-Control-Max-Age</code></strong></p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h4 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h4><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p><p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p><h3 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" class="headerlink" title="为什么要有同源限制？"></a>为什么要有同源限制？</h3><ul><li>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li><li>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p><strong>XMLHttpRequest</strong></p><p> XMLHttpRequest(XHR) 对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。 </p><p> <code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。 </p><p> <strong>1.  属性</strong></p><ul><li><strong>XMLHttpRequest.responseType</strong>  表示服务器返回数据的类型，这个属性是可写的，在 open 之后，send 之前，告诉服务器返回指定类型的数据。如果 responseType 设为空字符串，就等同于默认值 text 表示服务器返回文本数据； </li><li><strong>XMLHttpRequest.onreadystatechange</strong>当 <code>readyState</code> 属性发生变化时，调用的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventHandler"><code>EventHandler</code></a>。</li><li><strong>readyState</strong> HTTP 请求的状态，当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。 </li><li><strong>status</strong>   由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。 </li><li><strong>response</strong>   该属性只读表示服务器返回的数据体，可能是任意的数据类型，比如字符串，对象，二进制对象等，具体类型由responseType 属性决定。如果本次请求没有成功或者数据不完整，该属性等于 null </li></ul><p> <strong>2.  方法</strong></p><table><thead><tr><th>abort()</th><th>取消当前响应，关闭连接并且结束任何未决的网络活动</th></tr></thead><tbody><tr><td>getAllResponseHeaders()</td><td>把 HTTP 响应头部作为未解析的字符串返回</td></tr><tr><td>getResponseHeader()</td><td>返回指定的 HTTP 响应头部的值</td></tr><tr><td>open()</td><td>初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求</td></tr><tr><td>send()</td><td>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体</td></tr><tr><td>setRequestHeader()</td><td>向一个打开但未发送的请求设置或添加一个 HTTP 请求头</td></tr></tbody></table><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><ul><li><p><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</p></li><li><p><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</p><p><strong>Ajax</strong>表示Asynchronous JavaScript and XML(异步JavaScript和XML)，使我们可以获取数据并显示新的内容而不必载入一个新的Web页面</p><p><strong>1)    创建XMLHttpRequest</strong>    </p><p>var xhr = new XMLHttpRequest()；标准浏览器</p><p>var xhr = new ActiveXObject(‘Microsoft.XMLHTTP’)；IE老版本</p><p><strong>2)    准备发送    xhr.open(1，2，3)</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数1，请求方式，get获取数据，post提交数据</span><br><span class="line">参数2，请求地址url</span><br><span class="line">参数3，同步异步标志位，true是异步</span><br></pre></td></tr></table></figure><ul><li><p>get请求，url要加参数，这样php才能接受到参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;/01.php?username&#x27;+username+&#x27;&amp;password&#x27;+password</span><br></pre></td></tr></table></figure><p><code>encodeURI（）</code>用来对中文参数进行编码，防止中文乱码</p></li><li><p>post请求，url只需要地址,不需要参数,参数在send中传递</p></li></ul></li></ul><p>  <strong>3)    执行发送动作</strong>   </p><ul><li>get请求 xhr.send(null)；</li></ul><ul><li><p>post请求 </p><p>xhr.setRequestHeader(“content-Type”,”application/x-www-form-urlencoded”)<strong>//必须要请求头信息</strong></p><p>​    在Form元素的语法中，EncType表明提交数据的格式</p><p>​    用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。</p><ul><li>application/x-www-form-urlencoded ： 窗体数据被编码为名称/值对。这是标准的编码格式。（默认）</li><li>multipart/form-data ： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。(type=file使用)</li><li>text/plain ： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。</li></ul><p>var param=’username’+username+’password’+password;</p><p>xhr.send(param);这里不需要encodeURI编码</p></li></ul><p>  <strong>4）指定回调函数    浏览器调用</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xhr.readystate == <span class="number">4</span>)是否接收到数据&#123;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)数据是否正常&#123;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">var</span> data = xhr.responseXML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. 创建连接 **/</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">/** 2. 连接服务器 **/</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">/** 3. 发送请求 **/</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">/** 4. 接受请求 **/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">success(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">/** false **/</span></span><br><span class="line">fail &amp;&amp; fail(xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><strong>jsonp的原理</strong>：html中通过动态创建一个script标签，通过它的src属性发送跨域请求，从服务器端响应的<strong>数据格式是一个函数的调用</strong>,函数名要一致。eg:$callback.’(username=’.$uname.’)’</p><ul><li><p>html中的函数就是回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">script.src=<span class="string">&#x27;http::/1.html/1.php?callback=hello&amp;username=123&#x27;</span>;</span><br><span class="line"></span><br><span class="line">head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cb</span> = <span class="variable">$_Get</span>[<span class="variable">$callback</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$uname</span> = <span class="variable">$_Get</span>[<span class="variable">$username</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cb</span>.<span class="string">&#x27;(&#x27;</span>.<span class="string">&#x27;&#123;&quot;username&quot;:&quot;&#x27;</span><span class="variable">$uname</span><span class="string">&#x27;&quot;&#125;&#x27;</span>.<span class="string">&#x27;)&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p> 1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>  2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>  3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><a href="https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg">https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg</a></p><h3 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a><strong>Cookie机制</strong></h3><p>在程序中，会话跟踪是很重要的事情。理论上，<strong>一个用户的所有请求操作都应该属于同一个会话</strong>，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p><p>而Web应用程序是使用HTTP协议传输数据的。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p><p>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li><li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure><h4 id="Domain-Path"><a href="#Domain-Path" class="headerlink" title="Domain / Path"></a><strong>Domain / Path</strong></h4><blockquote><p>你不能拿清华的校园卡进北大。</p></blockquote><p>Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 <a href="http://www.example.com/">www.example.com</a> 会设为 example.com，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。</p><p>Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p><h4 id="Expires-Max-Age"><a href="#Expires-Max-Age" class="headerlink" title="Expires / Max-Age"></a><strong>Expires / Max-Age</strong></h4><blockquote><p>你毕业了卡就不好使了。</p></blockquote><p>Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p><p>Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p><p>如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。</p><p>如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p><h4 id="Secure-HttpOnly"><a href="#Secure-HttpOnly" class="headerlink" title="Secure / HttpOnly"></a><strong>Secure / HttpOnly</strong></h4><blockquote><p>有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。</p></blockquote><h3 id="cookie读写"><a href="#cookie读写" class="headerlink" title="cookie读写"></a>cookie读写</h3><h4 id="HTTP-头对-cookie-的读写"><a href="#HTTP-头对-cookie-的读写" class="headerlink" title="HTTP 头对 cookie 的读写"></a><strong>HTTP 头对 cookie 的读写</strong></h4><p>HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure><p>那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>height=180; domain=me.jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>weight=80; domain=me.jimu.com </span><br></pre></td></tr></table></figure><h4 id="前端对-cookie-的读写"><a href="#前端对-cookie-的读写" class="headerlink" title="前端对 cookie 的读写"></a><strong>前端对 cookie 的读写</strong></h4><p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p><p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct</span></span><br></pre></td></tr></table></figure><p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code>cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">// username=jimu; height=180; weight=80 </span></span><br></pre></td></tr></table></figure><h3 id="应用方案"><a href="#应用方案" class="headerlink" title="应用方案"></a>应用方案</h3><h4 id="服务端-session"><a href="#服务端-session" class="headerlink" title="服务端 session"></a>服务端 session</h4><p>现在回想下，你刷卡的时候发生了什么？</p><blockquote><p>其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。</p></blockquote><p>这种操作，在前后端鉴权系统中，叫 session。</p><p>典型的 session 登陆/验证流程：</p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhSL9SSvlVyK9rZpYbMEce09OVXcUR7ME0lRty0c2g2gzAdiasgqZMicvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><ul><li>浏览器登录发送账号密码，服务端查用户库，校验用户</li><li>服务端把用户登录状态存为 Session，生成一个 sessionId</li><li>通过登录接口返回，把 sessionId set 到 cookie 上</li><li>此后浏览器再请求业务接口，sessionId 随 cookie 带上</li><li>服务端查 sessionId 校验 session</li><li>成功后正常做业务处理，返回结果</li></ul><p><strong>「Session 的存储方式」</strong></p><p>显然，<strong>服务端只是给 cookie 一个 sessionId</strong>，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：</p><ul><li>Redis（推荐）：内存型数据库，redis中文官方网站。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。</li><li>内存：直接放到变量里。一旦服务重启就没了</li><li>数据库：普通数据库。性能不高。</li></ul><p><strong>「Session 的过期和销毁」</strong></p><p>很简单，只要把存储的 session 数据销毁就可以。</p><p><strong>「Session 的分布式问题」</strong></p><blockquote><p>由于服务器要存储所有用户 的sessionId,所以需要多台机器来存储用户信息，从而形成一个集群。假设小明通过手机登录系统，sessionId保存在机器A中，但是请求被转发到机器B中，就访问不到小明的id。</p></blockquote><p>通常服务端是<strong>集群</strong>，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？</p><p>这个问题现在有几种解决方式。</p><ul><li>一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。</li><li>二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。</li></ul><p>但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。</p><p>如果不保存这些sessionId，怎么<strong>验证</strong>客户端发给我的sessionId是服务端生成的。如果不去验证，就可以伪造sessionId,为所欲为。</p><p>嗯，对了，关健点就是验证！<br>比如说，小明已经登录了系统，服务端给他发一个令牌（token），里边包含了小的user id，下一次小明再次通过Http请求访问我的时候，把这个token 通过Http header 带过来进行校验就可以了。这样id就存储在了客户端，服务端只是生成token。</p><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？</p><blockquote><p>我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。</p></blockquote><p>一个登录场景，也不必往 session 存太多东西，那为什么不直接打包到 cookie 中呢？这样服务端不用存了，每次只要核验 cookie 带的「证件」<strong>有效性</strong>就可以了，也可以携带一些轻量的信息。这种方式通常被叫做 token。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh1pp5jQibGiafq4a1Fbzf8of4KJONMrkl05WgoWQUc5nicY6ENibJoqCoIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><p>token 的流程是这样的：</p><ul><li>用户登录，服务端校验账号密码，获得用户信息</li><li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li><li>此后用户请求业务接口，通过 cookie 携带 token</li><li>接口校验 token 有效性，进行正常业务接口处理</li></ul><p><strong>「客户端 token 的存储方式」</strong></p><p>在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，<strong>对 cookie 的管理能力依赖较小</strong>，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心</p><p><strong>「token 的编码」</strong></p><p>编码的方式丰俭由人。</p><p><strong>1.base64</strong></p><p>比如 node 端的 cookie-session - npm 库</p><blockquote><p>不要纠结名字，其实是个 token 库，但保持了和 express-session - npm 高度一致的用法，把要存的数据挂在 session 上</p></blockquote><p>默认配置下，当我给他一个 userid，他会存成这样：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh847kRibkcoibrtVwU5OcaVT3YibNicicSVkwXF5xehjHiac9lV9n633G51QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这里的 <code>eyJ1c2VyaWQiOiJhIn0=</code>，就是 <code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code> 的 base64 而已。</p><p><strong>2.防篡改</strong></p><blockquote><p>那问题来了，如果用户 cdd 拿<code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code>转了个 base64，再手动修改了自己的 token 为 <code>eyJ1c2VyaWQiOiJhIn0=</code>，是不是就能直接访问到 abb 的数据了？</p></blockquote><p>如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。</p><p>解决方案就是给 token 加签名，来识别 token 是否被篡改过。例如在 cookie-session - npm 库中，增加两项配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">secret: &#x27;iAmSecret&#x27;,</span><br><span class="line">signed: true, </span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhGQnmqNyYKagPYWBVJnet30xhia2ibslMtsEEyE6YUqeHC0NdxztaBfsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>但上面的做法额外增加了 cookie 数量，数据本身也没有规范的格式，所以 JSON Web Token Introduction - jwt.io 横空出世了。</p><blockquote><p>JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。</p></blockquote><p>它是一种成熟的 token 字符串生成方案，包含了我们前面提到的数据、签名。不如直接看一下一个 JWT token 长什么样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_u</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhMrU4STLto4juI9tPiabwOCewsw3f3icVQkyX79Oo7N9oxpS9tSpG6gsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>HTTP 是无状态的，为了维持前后请求，需要前端存储标记</li><li>cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石</li><li>session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题</li><li>token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性</li><li>token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案</li><li>在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验</li><li>session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比</li><li>单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket</li></ul><h2 id="cookie和storage区别"><a href="#cookie和storage区别" class="headerlink" title="cookie和storage区别"></a>cookie和storage区别</h2><ul><li><p>生命周期：</p><p>Cookie：可设置失效时间，否则默认为关闭浏览器后失效</p><p>Localstorage:除非被手动清除，否则永久保存</p><p>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</p></li><li><p>存放数据：</p><p>Cookie：4k左右</p><p>Localstorage和sessionstorage：可以保存5M的信息</p></li><li><p>http请求：</p><p>cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递</p><p>其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信</p></li><li><p>易用性：</p><p>Cookie：需要程序员自己封装，原生的cookie接口不友好</p><p>其他两个：即可采用原生接口，亦可再次封装</p></li><li><p>应用场景：</p><p>从安全性来说，因为每次http请求都会携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，<strong>不可以跨域调用</strong>，限制很多，但是识别用户登陆来说，cookie还是比storage好用，其他情况下可以用storage，localstorage可以用来在页面传递参数，sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数，</p></li></ul><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="对网页标准和标准制定机构重要性的理解"><a href="#对网页标准和标准制定机构重要性的理解" class="headerlink" title="对网页标准和标准制定机构重要性的理解"></a><strong>对网页标准和标准制定机构重要性的理解</strong></h2><p>网页标准和标准制定机构都是为了能让 web 发展的更‘健康’，开发者遵循统一的标准，降 </p><p>低开发难度，开发成本，SEO 也会更好做，也不会因为滥用代码导致各种 BUG、安全问题， </p><p>最终提高网站易用性。 </p><h2 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h2><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><h2 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><ul><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li><li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li><li>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><h2 id="src-与-href-的区别"><a href="#src-与-href-的区别" class="headerlink" title="src 与 href 的区别"></a>src 与 href 的区别</h2><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。 </p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在 </p><p>位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片 </p><p>和 frame 等元素。 </p><script src =”js.js”></script> <p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行 </p><p>完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 </p><p>js 脚本放在底部而不是头部。 </p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点） </p><p>或当前文档（链接）之间的链接，如果我们在文档中添加 </p><link href=”common.css” rel=”stylesheet”/> <p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 </p><p>这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h2><ul><li>数据体积方面<ul><li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li></ul></li><li>数据交互方面<ul><li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li></ul></li><li>数据描述方面<ul><li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li></ul></li><li>传输速度方面<ul><li><code>JSON</code>的速度要远远快于<code>XML</code></li></ul></li></ul><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h2><ol><li>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；</li><li>加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载；</li><li>link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；</li><li>可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；</li><li><code>link</code>引入的样式权重大于<code>@import</code>引入的样式。</li></ol><p>建议使用link的方式引入CSS</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><a href="https://www.imooc.com/article/68238">https://www.imooc.com/article/68238</a></p><img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg"  /><p>标准盒子模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">盒子实际内容（content）的width/height=我们设置的width/height;</span><br><span class="line">盒子总宽度/高度=width/height+padding+border+margin。</span><br></pre></td></tr></table></figure><p>IE盒子模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)</span><br><span class="line">盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin</span><br></pre></td></tr></table></figure><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>固定定位fixed：</p><p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。</p><p>相对定位relative：</p><p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p><p>绝对定位absolute：</p><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p><p>粘性定位sticky：</p><p>元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p><p>默认定位Static：</p><p>默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。</p><p>inherit:</p><p>规定应该从父元素继承position 属性的值。</p><h2 id="水平居中的方法"><a href="#水平居中的方法" class="headerlink" title="水平居中的方法"></a>水平居中的方法</h2><ul><li>元素为行内元素，设置父元素<code>text-align:center</code></li><li>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</li><li>绝对定位和移动: <code>absolute + transform</code></li><li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</li><li><code>display</code>设置为<code>tabel-cell</code></li></ul><h2 id="元素的垂直居中"><a href="#元素的垂直居中" class="headerlink" title="元素的垂直居中"></a>元素的垂直居中</h2><ul><li>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></li><li>使用<code>flex</code>布局，设置为<code>align-item：center</code></li><li>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></li><li>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</li><li>文本垂直居中设置<code>line-height</code>为<code>height</code>值</li></ul><h2 id="calc属性"><a href="#calc属性" class="headerlink" title="calc属性"></a>calc属性</h2><p>Calc用户动态计算长度值，任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p><h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><p><a href="https://blog.csdn.net/Jwhahaha/article/details/102483938">https://blog.csdn.net/Jwhahaha/article/details/102483938</a></p><h3 id="块级元素block"><a href="#块级元素block" class="headerlink" title="块级元素block"></a>块级元素block</h3><p>可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p><ul><li>每个块级元素都是独自占一行。 </li><li>元素的高度、宽度、行高和边距都是可以设置的。　　 </li><li>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,<strong>高度由内容撑开</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">h1~h6:标题标签，用于标记网页中的大标题，依次从大到小</span><br><span class="line">p：用于标记网页中的段落性文字，默认占满横向区域</span><br><span class="line">div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽</span><br><span class="line">section：区段，是用来定义文档的某个区域，章节</span><br><span class="line">nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。</span><br><span class="line">header：标签定义文档的页眉</span><br><span class="line">footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等</span><br><span class="line">pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。</span><br><span class="line">address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行</span><br><span class="line">audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。</span><br><span class="line">/ 表格标签 /</span><br><span class="line">table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸</span><br><span class="line">thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tbody：表主体，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tr：表示一行</span><br><span class="line">th：表头中的第一个单元格</span><br><span class="line">td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列</span><br><span class="line">/ 有序列表，无序列表 /</span><br><span class="line">ul：无序列表</span><br><span class="line">ol：有序列表</span><br><span class="line">li：列表项</span><br><span class="line">dl：定义列表，用于描述类表中的项目（dt（dd））</span><br></pre></td></tr></table></figure><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素 inline"></a><strong>行内元素 inline</strong></h3><p>行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： </p><ul><li><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 </p></li><li><p>行内元素的高度、宽度、行高不可设置。 </p></li><li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p></li><li><p><strong>行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以</strong></p></li></ul><p>常见行内元素有以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化</span><br><span class="line"></span><br><span class="line">a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件</span><br><span class="line">有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址</span><br><span class="line">strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容</span><br><span class="line"></span><br><span class="line">b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调</span><br><span class="line">s：删除线，仅仅是删除的效果</span><br><span class="line">del：具有删除语义，delete删除</span><br><span class="line">em：强调文本，斜体展示</span><br><span class="line">sup：上标</span><br><span class="line">sub：下标</span><br></pre></td></tr></table></figure><h3 id="行内块级元素-inline-block"><a href="#行内块级元素-inline-block" class="headerlink" title="行内块级元素 inline-block"></a><strong>行内块级元素 inline-block</strong></h3><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p><ul><li>和其他行内或行内块级元素元素放置在同一行上；</li><li>元素的高度、宽度、行高以及顶和底边距都可设置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示</span><br><span class="line">button：按钮</span><br><span class="line">input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。</span><br><span class="line"></span><br><span class="line">单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值</span><br><span class="line">type=&quot;checkbox&quot;复选框</span><br><span class="line"></span><br><span class="line">label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态</span><br><span class="line">select:下拉列表</span><br><span class="line">option:下拉选项</span><br></pre></td></tr></table></figure><h2 id="display：table和本身的table有什么区别"><a href="#display：table和本身的table有什么区别" class="headerlink" title="display：table和本身的table有什么区别"></a>display：table和本身的table有什么区别</h2><p>Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，使我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。</p><p>之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁</p><h2 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h2><p><strong>不同级别</strong></p><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式 优先级1000</p></li><li><p>id选择器                                        优先级100</p></li><li><p>   类选择器和伪类和属性                 优先级10</p></li><li><p>标签选择器和伪元素                     优先级1</p></li><li><p>通配符选择器                                优先级0</p></li><li><p>浏览器自定义或继承                    没有优先级</p><p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p></li><li><p>如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式</p></li><li><p>交集选择器的优先级 所有优先级 加起来 运算 然后比较</p></li><li><p>并集的话 就是各算各的。</p></li></ol><h2 id="使得一个-DOM-元素不显示在浏览器可视范围内"><a href="#使得一个-DOM-元素不显示在浏览器可视范围内" class="headerlink" title="使得一个 DOM 元素不显示在浏览器可视范围内"></a>使得一个 DOM 元素不显示在浏览器可视范围内</h2><p>最基本的： </p><p>设置 display 属性为 none，或者设置 visibility 属性为 hidden </p><p>技巧性： </p><p>设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000 </p><h2 id="rgba-和-opacity-的透明效果有什么不同"><a href="#rgba-和-opacity-的透明效果有什么不同" class="headerlink" title="rgba()和 opacity 的透明效果有什么不同"></a><strong>rgba()和 opacity 的透明效果有什么不同</strong></h2><p>rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的 </p><p>所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！） </p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><p><a href="https://www.jianshu.com/p/4d1dbb041bb2">https://www.jianshu.com/p/4d1dbb041bb2</a></p><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><p><strong>触发条件 (以下任意一条)</strong></p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><p><strong>BFC 特性及应用</strong></p><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%;" /><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%;" /><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%;" /><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%;" /><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%;" /><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><ul><li>伪类表状态</li><li>伪元素是真的有元素</li><li>前者单冒号，后者双冒号</li><li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li></ul><h2 id="如何实现小于12px的字体效果"><a href="#如何实现小于12px的字体效果" class="headerlink" title="如何实现小于12px的字体效果"></a>如何实现小于12px的字体效果</h2><blockquote><p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h2><p>页面的加载和渲染过程：</p><ol><li>浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM；</li><li>在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；</li><li>样式文件下载完成后，构建CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM</li><li>完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口</li></ol><p>只对外部脚本有效（引入的js文件）</p><ul><li><code>defer</code>加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</li><li><code>async</code>加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg" alt="img"></p><ul><li>蓝色线代表网络读取，</li><li>红色线代表执行时间，这俩都是针对脚本的；</li><li>绿色线代表 HTML 解析。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="JS的基本数据类型和引用数据类型"><a href="#JS的基本数据类型和引用数据类型" class="headerlink" title="JS的基本数据类型和引用数据类型"></a>JS的基本数据类型和引用数据类型</h3><ul><li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li><li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li></ul><h3 id="判断JS数据类型的四种方法"><a href="#判断JS数据类型的四种方法" class="headerlink" title="判断JS数据类型的四种方法"></a>判断JS数据类型的四种方法</h3><h4 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a><strong>1、typeof</strong></h4><p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：</p><ul><li>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</li><li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span><span class="string">&#x27;&#x27;</span>; <span class="comment">// string 有效</span></span><br><span class="line">typeof1; <span class="comment">// number 有效</span></span><br><span class="line">typeofSymbol(); <span class="comment">// symbol 有效</span></span><br><span class="line">typeoftrue; <span class="comment">//boolean 有效</span></span><br><span class="line">typeofundefined; <span class="comment">//undefined 有效</span></span><br><span class="line">typeofnull; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span>[] ; <span class="comment">//object 无效</span></span><br><span class="line">typeofnewFunction(); <span class="comment">// function 有效</span></span><br><span class="line">typeofnewDate(); <span class="comment">//object 无效</span></span><br><span class="line">typeofnewRegExp(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。因为在定义typeof时还没有null这种类型。</li></ul><p>其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，<strong>只返回了处于其原型链最顶端的 Object 类型</strong>，没有错，但不是我们想要的结果。</p><h4 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a><strong>2、instanceof</strong></h4><p>instanceof 是用来<strong>判断 A 是否为 B 的实例</strong>(不能判断一个对象实例具体属于哪种类型)</p><p>表达式为：A instanceof B。如果 A 是 B 的实例，则返回 true,否则返回 false。 </p><p>在这里需要特别注意的是：<strong>instanceof 检测的是原型</strong>，我们用一段伪代码来模拟其内部执行过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    varL = A.__proto__;</span><br><span class="line">    varR = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">// A的内部属性 __proto__ 指向 B 的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述过程可以看出，<strong>当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例</strong>，我们再来看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line">newDate() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"> </span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">newDate() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line">newPerson <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例</strong></p><p>我们来分析一下 [ ]、Array、Object 三者之间的关系：</p><p>从 instanceof 能够判断出 [ ].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：</p><p><img src="https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png" alt="img"></p><p>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，<strong>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p><h4 id="3、constructor"><a href="#3、constructor" class="headerlink" title="3、constructor"></a><strong>3、constructor</strong></h4><p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后<strong>在 prototype上添加一个 constructor 属性，并让其指向 F 的引用</strong>。如下所示：</p><p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png" alt="img"></p><p>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 <strong>F 原型上的 constructor 传递到了 f 上</strong>，因此 f.constructor == F</p><p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png" alt="img"></p><p>可以看出，<strong>F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上</strong>， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><p>同样，JavaScript 中的内置对象在内部构建时也是这样做的：</p><p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png" alt="img"></p><p><strong>细节问题：</strong></p><blockquote><ul><li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p></li><li><p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p></li></ul></blockquote><p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png" alt="img"></p><p>为什么变成了 Object？</p><p>因为 <strong>prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。</strong></p><p><strong>因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改</strong>。</p><h4 id="4、toString"><a href="#4、toString" class="headerlink" title="4、toString"></a><strong>4、toString</strong></h4><p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p><p>对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&#x27;&#x27;) ;   // [object String]</span><br><span class="line">Object.prototype.toString.call(1) ;    // [object Number]</span><br><span class="line">Object.prototype.toString.call(true) ; // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(Symbol()); //[object Symbol]</span><br><span class="line">Object.prototype.toString.call(undefined) ; // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null) ; // [object Null]</span><br><span class="line">Object.prototype.toString.call(newFunction()) ; // [object Function]</span><br><span class="line">Object.prototype.toString.call(newDate()) ; // [object Date]</span><br><span class="line">Object.prototype.toString.call([]) ; // [object Array]</span><br><span class="line">Object.prototype.toString.call(newRegExp()) ; // [object RegExp]</span><br><span class="line">Object.prototype.toString.call(newError()) ; // [object Error]</span><br><span class="line">Object.prototype.toString.call(document) ; // [object HTMLDocument]</span><br><span class="line">Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用</span><br></pre></td></tr></table></figure><h2 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h2><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p><p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p><p>懒惰实现方式：<br> 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.<br> 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。<br> 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。</p><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 </p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p>①所有<code>引用类型</code>都有一个<code>__proto__(隐式原型)</code>属性，属性值是一个普通的对象<br>②所有<code>函数</code>都有一个<code>prototype(原型)</code>属性，属性值是一个普通的对象<br>③所有<code>引用类型的__proto__</code>属性<code>指向</code>它<code>构造函数的prototype</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.__proto__ === <span class="built_in">Array</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" /><ul><li><p>instanceof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> a()</span><br><span class="line"><span class="comment">//判断实例的构造函数</span></span><br><span class="line">b <span class="keyword">instanceof</span> a</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>```js<br>function a(){}<br>let b = new a()<br>b.<strong>proto</strong>.constructor === a<br>//true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 原型链</span><br><span class="line"></span><br><span class="line">&gt; 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的`prototype`，如果还没有找到就会再在构造函数的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为`原型链`。</span><br><span class="line"></span><br><span class="line">举例，有以下代码</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function Parent(month)&#123;</span><br><span class="line">    this.month = month;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child = new Parent(&#x27;Ann&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child.month); // Ann</span><br><span class="line">console.log(child.father); // undefined</span><br></pre></td></tr></table></figure></li></ul><p>在child中查找某个属性时，会<code>执行下面步骤</code>：</p><p><img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><code>访问链路</code>为：</p><p><img src="https://img-blog.csdn.net/20180620155400807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><blockquote><p>①一直往上层查找，直到到null还没有找到，则返回<code>undefined</code><br>②<code>Object.prototype.__proto__ === null</code><br>③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象</p></blockquote><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li><p>每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> A()</span><br><span class="line">b.__proto__.constructor === A ===A.prototype.constructor</span><br><span class="line">b.constructor == A   <span class="comment">//b.__proto__.constructor ===b.constructor，原型上的 constructor 传递到了 b上</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p><a href="https://blog.csdn.net/qq_42926373/article/details/83149347">https://blog.csdn.net/qq_42926373/article/details/83149347</a></p><p> 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。</p><p> 但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p> 构造继承与原型继承组合 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子类、添加子类属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrange</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      Person.call(<span class="built_in">this</span>,name) <span class="comment">// 执行父构造，将This指向本身，拉取父私有属性；</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是，调用了arrange构造函数不等于继承了Person，arrange创建的对象的原型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new arrange() ----&gt; arrange.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure><p>必须想办法把原型链修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new arrange() ----&gt; arrange.prototype ----&gt; Person.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子类、添加子类属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrange</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      Person.call(<span class="built_in">this</span>,name) <span class="comment">// 执行父构造，将This指向本身，拉取父私有属性；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将父类实例赋值给子类原型对象</span></span><br><span class="line">    arrange.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 直接拉取父类实例继承原型</span></span><br><span class="line">    <span class="comment">// 将constructor指向本身，保证原型链不断。</span></span><br><span class="line">    arrange.prototype.constructor = arrange;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法会替换整个原型对象</span></span><br><span class="line">    <span class="comment">// arrange.prototype = &#123;</span></span><br><span class="line">    <span class="comment">//   init:function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;我会替换整个原型&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 必须在原型实例继承之后，在给子类原型添加方法，或重写方法，请使用以下方法</span></span><br><span class="line">    arrange.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;重写了此方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    arrange.prototype.addFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;添加了新方法&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> newObj = <span class="keyword">new</span> arrange(<span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(newObj)</span><br><span class="line">    newObj.eat(); <span class="comment">// 王五重写了此方法</span></span><br><span class="line">    newObj.addFn(); <span class="comment">// 王五添加了新方法</span></span><br></pre></td></tr></table></figure><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将父类实例赋值给子类原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类、添加子类属性。</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">arrange</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.goShop = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(name + <span class="string">&#x27;叫你去买&#x27;</span>+ food)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将父类实例赋值给子类原型对象</span></span><br><span class="line">   arrange.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">   <span class="comment">// 将constructor指向本身，保证原型链不断。</span></span><br><span class="line">   arrange.prototype.constructor = arrange; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建arrange新实例，也是Person实例;</span></span><br><span class="line">   <span class="keyword">var</span> newObj = <span class="keyword">new</span> arrange(<span class="string">&#x27;李四&#x27;</span>); </span><br><span class="line">   <span class="built_in">console</span>.log(newObj <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(newObj <span class="keyword">instanceof</span> arrange) <span class="comment">//true</span></span><br><span class="line">   <span class="comment">// 原型链继承成功，可以访问父类所有属性;</span></span><br><span class="line">   <span class="built_in">console</span>.log(newObj)</span><br><span class="line">   <span class="built_in">console</span>.log(newObj.name) <span class="comment">// 李四</span></span><br><span class="line">   newObj.sleep(); <span class="comment">// 李四正在睡觉！</span></span><br><span class="line">   newObj.eat(<span class="string">&#x27;苹果&#x27;</span>); <span class="comment">// 李四正在吃：苹果</span></span><br><span class="line">   newObj.goShop(<span class="string">&#x27;香蕉&#x27;</span>); <span class="comment">// 李四叫你去买香蕉</span></span><br></pre></td></tr></table></figure><h4 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h4><p>执行父构造，将This指向本身，拉取父私有属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子类、添加子类属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrange</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>,name) <span class="comment">// 执行父构造，将This指向本身，拉取父私有属性；</span></span><br><span class="line">&#125;</span><br><span class="line">arrange.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> arrange(<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br><span class="line"><span class="built_in">console</span>.log(newObj.name) <span class="comment">//李四</span></span><br><span class="line">newObj.sleep() <span class="comment">// 李四正在睡觉！</span></span><br><span class="line">newObj.getName() <span class="comment">//我叫李四</span></span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote><p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p></blockquote><ul><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li><li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li><li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li><li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li></ul><p>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false（默认），表示在冒泡阶段调用事件处理程序。</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。可以大量节省内存占用，减少事件注册</p><h3 id="onload和ready"><a href="#onload和ready" class="headerlink" title="onload和ready"></a>onload和ready</h3><p>document.ready和onload的区别——JavaScript文档加载完成事件<br>页面加载完成有两种事件:</p><ul><li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</li><li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li></ul><p><strong>jq</strong></p><ul><li><p><code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</p></li><li><p><code>$(document).ready()==DOMContentLoaded</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);<span class="comment">//jq ready()的简写</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h2><p><a href="https://www.jianshu.com/p/c8b86b09daf0">https://www.jianshu.com/p/c8b86b09daf0</a></p><p>防抖和节流是针对<strong>响应跟不上触发频率</strong>这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来<strong>之前</strong>，又一次触发了事件，就重新开始延时</p><p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg" alt="img"></p><h4 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a><strong>非立即执行版</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1134/format/webp" alt="img"></p><h4 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a><strong>立即执行版</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-067785c056f182d8.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1140/format/webp" alt="img"></p><p>将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。</p><h4 id="双剑合璧版"><a href="#双剑合璧版" class="headerlink" title="双剑合璧版"></a><strong>双剑合璧版</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率</strong></p><p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg" alt="img"></p><h4 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4842858-80423b8898a27732.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1140/format/webp" alt="img"></p><p>可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p><h4 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版:"></a>定时器版:</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4842858-bf2ed4c8ed4f0ec0.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" alt="img"></p><p>可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><h4 id="双剑合璧版-1"><a href="#双剑合璧版-1" class="headerlink" title="双剑合璧版"></a>双剑合璧版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 函数节流</span><br><span class="line"> * @param func 函数</span><br><span class="line"> * @param wait 延迟执行毫秒数</span><br><span class="line"> * @param type 1 表时间戳版，2 表定时器版</span><br><span class="line"> */</span><br><span class="line">function throttle(func, wait ,type) &#123;</span><br><span class="line">    if(type===1)&#123;</span><br><span class="line">        let previous = 0;</span><br><span class="line">    &#125;else if(type===2)&#123;</span><br><span class="line">        let timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line">        if(type===1)&#123;</span><br><span class="line">            let now = Date.now();</span><br><span class="line"></span><br><span class="line">            if (now - previous &gt; wait) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(type===2)&#123;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="MVC和MVVM"><a href="#MVC和MVVM" class="headerlink" title="MVC和MVVM"></a>MVC和MVVM</h2><p><a href="https://www.pianshen.com/article/3716256399/">https://www.pianshen.com/article/3716256399/</a></p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码。</p><ul><li><p><strong>Model（模型）</strong> ：应用程序中用于处理应用程序数据逻辑的部分</p><p>通常模型对象负责在数据库中存取数据。</p></li><li><p><strong>View（视图）</strong> ：  应用程序中处理数据显示的部分</p><p>通常视图是依据模型数据创建的。</p></li><li><p><strong>Controller（控制器）</strong>：应用程序中处理用户交互的部分。</p><p>通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af72cd60c25062?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /></li></ul><blockquote><p>1.View传送指令到Controller。</p></blockquote><blockquote><p>2.Controller完成业务逻辑后改变Model状态。</p></blockquote><blockquote><p>3.Model将新的数据发送至View,用户得到反馈。            </p></blockquote><p> <strong>优点</strong></p><p><strong>耦合性低</strong>       </p><p>视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码</p><p><strong>重用性高</strong></p><p>MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型</p><p><strong>生命周期成本低</strong></p><p>MVC使开发和维护用户接口的技术含量降低。</p><p><strong>部署快</strong></p><p>使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。</p><p><strong>可维护性高</strong></p><p>分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。</p><p><strong>缺点</strong></p><p><strong>1.m层和v层直接打交道，导致这两层耦合度高</strong></p><p><strong>2.因为所有逻辑都写在c层，导致c层特别臃肿</strong></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><img src="https://user-gold-cdn.xitu.io/2019/5/27/16af920a988c5f66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><p><strong>Model-View-ViewModel</strong>即模型-视图-视图模型。</p><ul><li><p>模型：后端传递的数据。</p></li><li><p>视图：所看到的页面。</p></li><li><p>视图模型：mvvm模式的核心，它是连接view和model的桥梁。</p><p>它有两个方向：</p><ul><li>一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：<strong>数据绑定</strong></li><li>二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：<strong>DOM 事件监听</strong></li></ul></li></ul><p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=32561255,2826043542&fm=173&app=25&f=JPEG?w=500&h=100&s=C8F78852C4B2FE207E66C9D20200D0AA" alt="img"></p><p><strong>总结</strong>：<strong>在MVVM的框架下视图和模型是不能直接通信的</strong>。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<strong>双向绑定</strong>。</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想，主要区别如下：</p><ol><li>mvvm 通过数据来驱动视图层的显示而不是节点操作。</li><li>MVC除了简单的 Model、View 以外的所有部分都被放在了 Controller 里面。Controller 负责显示界面、响应用户的操作、网络请求以及与 Model 交互。这就导致了 Controller：<ul><li>逻辑复杂，难以维护。</li><li>和 View 紧耦合，无法测试。</li></ul></li><li>MVVM与MVC<strong>最大的区别</strong>就是：MVC中大量的DOM 操作(主要是手动操作dom元素去改变view的显示)使页面渲染性能降低，加载速度变慢，影响用户体验。MVVM实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。</li></ol><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>前端主流框架 vue 和 react 中都使用了虚拟DOM（virtual DOM）技术，因为渲染真实DOM的开销是很大的，性能代价昂贵，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，而我们只需要更新修改过的那一小块dom而不要更新整个dom，这时使用diff算法能够帮助我们。</p><p><strong>DOM</strong></p><p>DOM全称<code>文档对象模型</code>，本质也是一个JS对象。每操作一次DOM都会对页面进行重新渲染，且新生成一颗DOM树。</p><p>DOM的本质： 浏览器中的概念，用js对象来表示页面上的元素，并提供操作DOM对象的API</p><p><strong>VDOM</strong></p><p>虚拟dom，通过JS模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。</p><p>vdom的本质:是框架中的概念，是程序员用js对象来模拟页面上的DOM和DOM 的嵌套</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a><strong>diff算法</strong></h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/2/171d3ca4cc6af69a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>现有一个真实的<code>DOM</code>，首先会映射为虚拟<code>DOM</code>，这个时候，我们删除了最后一个<code>p</code>节点和<code>son2</code>的节点，得到了新的一个虚拟<code>DOM</code>，新的<code>vdom</code>会和旧的<code>vdom</code>进行差异对比，得到了<code>pathes</code>对象，之后，对旧的真实<code>dom</code>进行操作，得到了新的<code>DOM</code>。</p><p><strong>diff策略</strong></p><p>React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度</p><ul><li><p>策略一（tree diff）：新旧DOM树，逐层对比的方式<br>DOM节点跨层级的移动操作特别少，可以忽略不计。</p><p> <img src="https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg" alt="img"> </p><p>只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。</p><p>当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。</p><p>这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p></li><li><p>策略二（component diff）：<br>拥有相同类的两个组件生成相似的树形结构， 拥有不同类的两个组件 生成不同的树形结构。</p></li><li><p>策略三（element diff）：<br>对于同一层级的一组子节点，通过唯一id区分。</p></li></ul><h2 id="响应式实现原理"><a href="#响应式实现原理" class="headerlink" title="响应式实现原理"></a><strong>响应式实现原理</strong></h2><p><strong>主流框架实现双向绑定（响应式）的做法</strong></p><p><strong>1. 脏值检查：</strong> angular是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。</p><p><strong>2.观察者-订阅者（数据劫持）：vue</strong>Observer 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1581589677,2197583542&fm=173&app=25&f=JPEG?w=640&h=342&s=5926347301CA614B4E65C0CA0000E0B3" alt="img"></p><p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。</p><h2 id="React与vue-js的对比"><a href="#React与vue-js的对比" class="headerlink" title="React与vue.js的对比"></a>React与vue.js的对比</h2><p><a href="https://juejin.cn/post/6844903974437388295">https://juejin.cn/post/6844903974437388295</a></p><p><a href="https://cn.vuejs.org/v2/guide/comparison.html">https://cn.vuejs.org/v2/guide/comparison.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/100228073">https://zhuanlan.zhihu.com/p/100228073</a></p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都是用了Virtual DOM。</li><li>都提供了响应式和组件化的视图组件。</li><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。</li></ul><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul><li><p>响应式+vdom</p></li><li><p>响应式，实现数据的双向绑定</p></li><li><p>vue保留了html、css、js分离的写法，模板就是普通的html。</p></li><li><p>不够动态，语法限制。优点就是优化空间大</p><p>因为已经定义好了类似v-for,v-if语法</p></li><li><p>Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。</p></li></ul><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ul><li><p>没有响应式，只有vdom，计算diff.</p></li><li><p>数据是单向数据流，所以需要状态管理器<strong>useState</strong>。</p></li><li><p>react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。</p></li><li><p>动态的，因为全部都是用js编写，可以根据开发者进行编写。但是不利于优化，每个开发者编写代码都有自己的风格。</p></li><li><p>React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树</p></li></ul><h3 id="模块化和组件化"><a href="#模块化和组件化" class="headerlink" title="模块化和组件化"></a>模块化和组件化</h3><p><strong>模块化</strong>：从 <strong>代码</strong> 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够<strong>方便代码的重用</strong>；</p><p><strong>组件化</strong>：从 <strong>UI</strong> 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方<strong>便了UI元素的重用</strong>；<strong>组件是元素的集合体</strong>；</p><p>Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；</p><ul><li>template： UI结构</li><li>script： 业务逻辑和数据</li><li>style： UI的样式</li></ul><p>React如何实现组件化：React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）</p><h3 id="开发团队方面"><a href="#开发团队方面" class="headerlink" title="开发团队方面"></a>开发团队方面</h3><ul><li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li><li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li></ul><h3 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h3><ul><li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li><li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li></ul><h2 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h2><h3 id="vue渐进式"><a href="#vue渐进式" class="headerlink" title="vue渐进式"></a>vue渐进式</h3><p>在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是<strong>Vue的使用方式</strong>，同时也体现了Vue的设计的理念。</p><h3 id="Vue的双向绑定数据的原理"><a href="#Vue的双向绑定数据的原理" class="headerlink" title="Vue的双向绑定数据的原理"></a>Vue的双向绑定数据的原理</h3><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><ul><li><code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    input.value = value;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">input.onChange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  data.text = e.target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h3><p>1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</p><p>2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</p><p>3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</p><p>4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h2 id="SPA、SSR、CSR"><a href="#SPA、SSR、CSR" class="headerlink" title="SPA、SSR、CSR"></a>SPA、SSR、CSR</h2><p><a href="https://zhuanlan.zhihu.com/p/299598903">https://zhuanlan.zhihu.com/p/299598903</a></p><p><a href="https://zhuanlan.zhihu.com/p/138356519">https://zhuanlan.zhihu.com/p/138356519</a></p><h3 id="一、SPA"><a href="#一、SPA" class="headerlink" title="一、SPA"></a>一、SPA</h3><p>single page web application，单页Web应用，就是只有一张Web页面的应用，<strong>与后台仅仅是数据的交互，不会再请求其它页面</strong>。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。</p><p>典型编写SPA的前端框架：React、Angular、Vue。</p><ul><li>概念：<ul><li>网站的效果都是显示在<code>一个静态页面</code>中的</li><li>在页面切换时，其实并没有从一个页面中跳转到另一个页面中，只是通过 <code>js</code> 动态的将内容进行了修改</li><li>在网站的源代码中是看不到任何数据的</li></ul></li></ul><p><strong>特点：</strong></p><ul><li>优点：<ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul></li><li>缺点：<ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；（vue-router 已经解决了这个问题）</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。<ul><li>因为单页应用的所有内容都在 index.html 中，页面的切换是通过 js 动态切换的</li><li>由于所有的内容切换都是通过 js 动态切换的，所以在页面的源代码中是看不到任何的数据的</li><li>由于源代码中看不到任何数据，这是非常不利于 SEO 的，所以我们说 SPA 在 SEO 上有其天然的弱势。</li><li>vue 中的 SSR 就可以用来解决这个问题。</li></ul></li></ul></li></ul><h3 id="二、SSR"><a href="#二、SSR" class="headerlink" title="二、SSR"></a>二、SSR</h3><p>Server Side Rendering，服务器端渲染，传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。</p><p>典型服务器端渲染的例子就是jsp、asp、php等各种后台模板生成的页面，前端会直接拿到整张页面，不用自己过多的去拼接DOM。</p><img src="https://pic1.zhimg.com/80/v2-b4c8866154ac2158d887e04e1e73c2f8_720w.jpg" alt="img" style="zoom:50%;" /><img src="https://pic3.zhimg.com/80/v2-26e5fd8c489d700be758d43eba801f26_720w.jpg" alt="img" style="zoom:50%;" /><p><strong>渲染流程</strong>：</p><ul><li>阶段一：浏览器请求url –&gt; 服务器路由分析、执行渲染 –&gt; 服务器返回index.html(实时渲染的内容，字符串) –&gt; 浏览器渲染</li><li>阶段二：浏览器请求bundle.js –&gt; 服务器返回bundle.js –&gt; 浏览器路由分析、生成虚拟DOM –&gt; 比较DOM变化、绑定事件 –&gt; 二次渲染</li></ul><p>尽管服务器渲染第一阶段的流程图很长，但是因为服务器渲染速度很快，因此实际耗时与客户端渲染几乎相同。<br>第一阶段结束时，服务器端返回渲染结果，用户即可看到首屏。而对于客户端渲染，需要等待一次脚本下载时间，以及在客户端的渲染时间。由于客户端的硬件以及网络条件的差异，这两段时间开销可能十分显著。<br>客户渲染与服务器渲染第二阶段基本一致。所不同的是，服务器渲染流程中，在客户端生成vdom后，并不会重新渲染，而是比较现有dom的checksum来决定是否重新渲染。</p><p><strong>原理</strong>：基于<code>Virtual DOM</code>实现了客户端与服务端的同构渲染。</p><ul><li>在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；</li><li>在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。</li></ul><h3 id="三、CSR"><a href="#三、CSR" class="headerlink" title="三、CSR"></a>三、CSR</h3><p>客户端渲染(Client Side Render)。渲染过程全部交给浏览器进行处理，服务器不参与任何渲染。页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。</p><img src="https://pic4.zhimg.com/80/v2-6a8fe007fcf263214074f72ea3971b87_720w.jpg" alt="img" style="zoom:67%;" /><p><strong>渲染流程</strong>：浏览器请求url –&gt; 服务器返回index.html(空body、白屏) –&gt; 再次请求bundle.js、路由分析 –&gt; 浏览器渲染</p><p>bundle.js体积越大，会导致浏览器白屏时间越长。</p><h3 id="四、SSR与CSR对比"><a href="#四、SSR与CSR对比" class="headerlink" title="四、SSR与CSR对比"></a>四、SSR与CSR对比</h3><p>CSR与SSR的区别简而言之，就是数据拼接HTML字符串这件事放在服务端还是客户端。</p><p><img src="https://pic2.zhimg.com/80/v2-e12ce3a06497fcffaa51d3a720b46649_720w.jpg" alt="img"></p><h2 id="前端架构-JAMStack"><a href="#前端架构-JAMStack" class="headerlink" title="前端架构 JAMStack"></a>前端架构 JAMStack</h2><p><a href="https://segmentfault.com/a/1190000022434868">https://segmentfault.com/a/1190000022434868</a></p><p><a href="http://blog.yixao.net/tech/14278.html">http://blog.yixao.net/tech/14278.html</a></p><p>JAMStack中的JAM其实是三个词的缩写，它们分别是JavaScript, APIs以及Markdown。而Stack用中文的说法就是技术栈（Tech Stack），也就是我们在构建应用的时候具体使用到的技术的集合。</p><p>JAMStack 指的是一套用于<strong>构建现代网站的技术栈</strong></p><p><strong>JavaScript</strong></p><p>在JAMStack的概念中，JavaScript指的是在客户端（client）实现动态网页效果的JavaScript，它既可以是React和Vue这种Web框架，也可以是原生的JavaScript。它主要负责网页动态的内容。</p><p><strong>APIs</strong></p><p>这里的API和我们平时开发调用的API是一样的。JAMStack的Web应用会通过JavaScript给后端API发送AJAX请求或者GraphQL query，后端API会以某种格式（一般是JSON）返回数据给前端来实现一些用户交互。</p><p><strong>Markdown</strong></p><p><a href="https://zhuanlan.zhihu.com/p/134662152/markdown_%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91">Mardown</a>是一种轻量级的标记语言。在JAMStack的世界中，Markdown类型的文件通常是用来作为生成静态HTML文件的数据源。有用过<a href="https://zhuanlan.zhihu.com/p/134662152/Hexo">hexo</a>写博客的同学对这个概念肯定不会陌生，因为hexo的原理就是将我们编写的Markdown文件根据我们指定的主题或者模板生成一些静态的HTML然后托管在github pages或者其它类似的静态网站服务器来供别人访问的。</p><p>除了Markdown文件之外，JAMStack的静态数据源还可以是其它的东西，例如我们后面说到的<a href="https://www.gatsbyjs.org/">Gatsby</a>（JAMStack的一种实现）就允许通过插件的方式使用SQL直接读取数据库的内容来生成静态页面。</p><p><strong>1. 使用网站生成器预渲染整个网站</strong></p><p>整个网站在部署前，会被<strong>网站生成器（SSG, Static Site Generators）</strong>构建和优化为一系列的静态页面和静态资源，这样整个网站可以被托管在 CDN 上，加载速度得到最大程度地优化，安全性也得到保障。</p><p><strong>2. 使用 Headless CMS（无头 CMS）管理动态内容</strong></p><p>如果想要网站承载动态内容，那么可以接入各种 Headless CMS（无头 CMS），这些 CMS 系统会对外提供 API，网站生成器可以调用这些 API 拉取数据，<strong>将动态数据渲染成为静态页面</strong>。</p><p><strong>3. 使用 HTTP API 增强网站的功能</strong></p><p>在登录注册、评论框等需要后端支持的能力上，Jamstack 网站通常会使用微服务提供的 HTTP API，或者一些第三方的 BaaS（后端即服务）能力。</p><p>除了以上三个主要特点以外，Jamstack 的网站通常还会有下面的特性：</p><ul><li>全站托管于 CDN 上</li><li>原子化发布（每次发布都是一次全量、原子性的发布）</li><li>灵活的文件缓存策略</li><li>基于 Git 的全自动构建、部署流程</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>1. 相比于纯静态网站</strong></p><p>纯静态的网站很难承载动态的内容，内容改动通常都是要直接修改页面的代码，这<strong>对于内容管理人员（很可能是非技术人员）来说非常不友好</strong>。</p><p>而 Jamstack 的网站，通常会使用无头 CMS 来将内容管理抽离出去，内容管理人员可以直接在这些 CMS 系统的 UI 界面上进行内容修改，然后触发整个网站的重新预渲染，以及部署。</p><p><strong>2. 相比于传统动态网站</strong></p><p>这里的“传统动态网站”指的是用 PHP、Ruby On Rails、JSP 甚至更古老的 CGI 构建的网站，以及基于这些技术产生的建站工具比如 WordPress、Drupal 等等。</p><p>这些传统网站的劣势在于，它们在运行时都需要一个实时在线的服务端，这些服务端负责处理请求、渲染页面，这就很大程度上降低了<strong>服务的可伸缩性和稳定性</strong>（想象一下，你迁移扩容一个在线的 WordPress 网站有多么麻烦）。</p><p>Jamstack 由于是直接使用 CDN 分发静态的页面，完全不需要渲染页面的服务，网站的伸缩性、稳定性可以得到最大的保障。</p><p><strong>3. 相比于单页应用（SPA）</strong></p><p>大概五年前，随着各种前端框架的成熟，越来越多的业务逻辑迁移到了前端处理，这也就诞生了 SPA 的概念，也就是整个网站的 UI 层，由浏览器端来完全接管。得益于 HTML5 和现代浏览器的一系列特性，这样的做法可以保证最好的用户体验。</p><p>但是 SPA 最大的问题在于它<strong>对 SEO 不友好</strong>，因为 SPA 的页面内容都是靠浏览器异步获取、渲染的，虽然 Google 为首的大多数搜索引擎渐渐地支持爬取 SPA 的内容，但是这依然是一个隐患。另外，由于 SPA 需要异步加载数据，首屏内容需要在在加载、运行 JS 之后才能看到，也给用户打开网站的体验带来影响。</p><p>而 Jamstack 的页面本质上都是托管在 CDN 上的静态页面，搜索引擎可以直接爬取这些静态内容，首屏与静态网站一样，可以直接展示内容，而不需要等到加载运行 JS 之后。</p><p><strong>4. 相比于 SSR 应用</strong></p><p>目前市面上的几大前端框架都支持了服务器端渲染，也就是 SSR 的概念，这些 SSR 技术也成为了 Jamstack 的基础之一。但是典型的 SSR 应用和传统动态网站一样，都是需要一个在线的服务来渲染页面，同样<strong>会有运维和安全性上的风险</strong>。</p><p>Jamstack 从技术角度上讲，可以认为是 SSR 技术的进阶，也就是提前用 SSR 预渲染大部分页面，然后将这些页面部署在 CDN 上，随后根据网站的数据变化，重复预渲染、部署即可。</p><p>当然，Jamstack 也不是万金油，不可能完美适应所有场景，Jamstack 最适合一些<strong>内容更新不太频繁的网站</strong>（比如新闻、电商、文档）。它不适合 Feeds 流、聊天室、论坛、个性化推荐这样高度动态化的网站，以及邮箱、编辑器这样偏重型的 Web 应用。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h1 id="框架模拟"><a href="#框架模拟" class="headerlink" title="框架模拟"></a>框架模拟</h1><h2 id="虚拟DOM-1"><a href="#虚拟DOM-1" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p><a href="https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw">https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw</a></p><h1 id="框架源码"><a href="#框架源码" class="headerlink" title="框架源码"></a>框架源码</h1><h2 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h2><p><a href="https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw">https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw</a></p><p>了解Vue设计理念及手写实现<a href="https://www.kaikeba.com/open/item?lpsc=216875">https://www.kaikeba.com/open/item?lpsc=216875</a></p><p>《Vue3响应式原理剖析》<a href="http://t.kuick.cn/ZSMD">http://t.kuick.cn/ZSMD</a></p><p>《Vue源码剖析之整体流程》<a href="http://t.kuick.cn/ZSMf">http://t.kuick.cn/ZSMf</a></p><p>vue-router前端路由原理剖析：<a href="https://t.kaikeba.com/85FV">https://t.kaikeba.com/85FV</a></p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 安全优化 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
